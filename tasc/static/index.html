<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title >Super Express trainsim</title>
  <link rel="icon" href="/static/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="/static/favicon.ico" type="image/x-icon">

  <!-- Google Fonts: Noto Sans JP Bold -->
  <link href="https://fonts.cdnfonts.com/css/a-otf-shin-go-pro" rel="stylesheet">
<style>
@import url('https://fonts.cdnfonts.com/css/a-otf-shin-go-pro');

#miniNext {
  letter-spacing: -0.08em;
}

/* === ì¥ì• ë¬¼ ì´ë²¤íŠ¸ íŒì—… === */
.obstacle-popup {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 10006;
  background: rgba(0,0,0,0.55);
  backdrop-filter: blur(12px);
}

.obstacle-popup.visible {
  display: flex;
}

.obstacle-card {
  min-width: 260px;
  max-width: 420px;
  padding: 18px 20px;
  border-radius: 14px;
  box-shadow: 0 18px 40px rgba(0,0,0,0.85);
  border: 1px solid rgba(255,255,255,0.08);
  font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', sans-serif;
}

/* ë¹¨ê°„ ê²½ê³  */
.obstacle-card.obstacle-danger {
  background:
    radial-gradient(circle at 0 0, rgba(255,94,94,0.28), transparent 60%),
    rgba(20,6,10,0.98);
  border-color: rgba(255,120,120,0.9);
}

/* ì´ˆë¡ ì •ìƒ */
.obstacle-card.obstacle-success {
  background:
    radial-gradient(circle at 0 0, rgba(80,255,170,0.24), transparent 60%),
    rgba(6,24,14,0.98);
  border-color: rgba(100,255,180,0.9);
}

.obstacle-title {
  font-weight: 700;
  font-size: 1rem;
  margin-bottom: 6px;
}

.obstacle-card.obstacle-danger .obstacle-title {
  color: #ffb3b3;
}

.obstacle-card.obstacle-success .obstacle-title {
  color: #b6ffce;
}

.obstacle-body {
  margin: 0 0 8px;
  font-size: 0.85rem;
  line-height: 1.6;
  color: #dde6ff;
}

.obstacle-hint {
  font-size: 0.78rem;
  color: #9fb6d6;
  text-align: right;
}
.unit {
  font-size: 0.7em;      /* ê¸€ì í¬ê¸° ì¤„ì´ê¸° */
  display: inline-block; /* transform ì ìš©í•˜ë ¤ë©´ í•„ìš” */
  transform: scaleX(0.7); /* ì¢Œìš°ë¡œ ì••ì¶• (0~1 ì‚¬ì´ë¡œ ì¤„ì´ë©´ ë¨) */
  transform-origin: right; /* ì••ì¶• ê¸°ì¤€ì  (ì˜µì…˜) */
  margin-left: -8px; /* â† í•„ìš”í•œ ë§Œí¼ ì¡°ì ˆ */
}

.unit-grade {
  font-size: 0.7em;        /* ìˆ«ìë³´ë‹¤ ì‘ê²Œ */
  display: inline-block;   /* transform ì ìš© ìœ„í•´ í•„ìš” */
  transform: scaleX(0.7);  /* ì¢Œìš° ì••ì¶• */
  transform-origin: right;  /* ì™¼ìª½ ê¸°ì¤€ìœ¼ë¡œ ì••ì¶• */
  margin-left: -2px;       /* ìˆ«ìì™€ ê°„ê²© ì¤„ì´ê¸° (ìƒí™© ë³´ê³  -1~-3px ì¡°ì ˆ) */
}

.zero {
  font-style: italic;
}


/* === Mini 3D HUD (top-right) === */
#cabCard {
  position: relative; /* mini HUD ê¸°ì¤€ì  */
}

.mini-hud {
  position: absolute;
  top: 10px;
  right: 10px;
  min-width: 160px;
  padding: 8px 10px;
  border-radius: 12px;
  background:
    radial-gradient(circle at 0 0, rgba(0,246,255,.18), transparent 60%),
    rgba(5,12,24,.88);
  border: 1px solid rgba(0,246,255,.45);
  box-shadow: 0 12px 26px rgba(0,0,0,.75);
  backdrop-filter: blur(8px);
  font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', sans-serif;
  font-size: 15px;
  color: #cfe4ff;
  pointer-events: none; /* ì¡°ì‘ ë°©í•´ ì•ˆ í•˜ë„ë¡ */
  z-index: 6;
  text-align: right;
  line-height: 2.0;
}

.mini-hud-header {
  font-family: 'A-OTF Shin Go Pro', sans-serif; font-style: normal; font-weight: 700; 
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 4px;
  opacity: .9;
  font-size: 11px;
  letter-spacing: .06em;
  text-transform: uppercase;
}

.mini-hud-dot {
  width: 6px;
  height: 6px;
  border-radius: 999px;
  background: radial-gradient(circle, #00f6ff, #0080ff);
  box-shadow: 0 0 10px rgba(0,246,255,.9);
}

/* .mini-hud-rows {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 4px 10px;
}

*/

.mini-row {
  display: flex;
  justify-content: space-between; /* ì¢Œ label â€” ìš° value */
  align-items: center;
  margin: 2px 0;
}

.mini-label {
  text-align: left;
  font-size: 10px;
  opacity: .75;
}

.mini-value {
  text-align: right;
  font-size: 15px;
  font-weight: 600;
  font-variant-numeric: tabular-nums;
}

/* íƒ€ì´ë¨¸ëŠ” í•œ ì¤„ë¡œ í¬ê²Œ */
.mini-row.timer {
  grid-column: 1 / 3;
  flex-direction: row;
  align-items: baseline;
  justify-content: space-between;
}

.mini-row.timer .mini-value {
  font-size: 14px;
}

.mini-row.grade .mini-value {
  font-size: 14px;
}

.mini-value.atc-limit {
  color: #ff6b6b;
}

.mini-row.timer .min,
.mini-row.timer .sec {
  font-variant-numeric: tabular-nums;
}

/* Late arrival styling - red text when timer goes negative */
.mini-value.late {
  color: #ff4444;
}

@media (max-width: 768px) {
  .mini-hud {
    top: 6px;
    right: 6px;
    padding: 6px 8px;
    min-width: 130px;
    font-size: 10px;
  }
  .mini-row .mini-value { font-size: 11px; }
}


html, body {
  margin: 0;
  background: radial-gradient(circle at 50% 20%, #0b0f14, #05070a);
  background-attachment: fixed;
  color: #e7f0ff;
  font-family: 'Orbitron', system-ui, Segoe UI, Roboto, Apple SD Gothic Neo, AppleGothic, sans-serif;
    -ms-overflow-style: none;  /* IE and Edge */
  scrollbar-width: none;  /* Firefox */
}

.html::-webkit-scrollbar {
  display: none !important; /* Chrome, Safari, Opera */
}
.body::-webkit-scrollbar {
  display: none !important; /* Chrome, Safari, Opera */
}
.game-background,.snow-background,.rain-background{background:transparent!important}
#wrap{max-width:960px;margin:18px auto;padding:0 12px}
.row{display:flex;gap:12px;align-items:center}
.card{
  background:rgba(18,24,38,.7);border:1px solid rgba(0,246,255,.15);border-radius:16px;padding:16px;
  backdrop-filter:blur(10px);box-shadow:0 8px 24px rgba(0,0,0,.5);transition:transform .2s,box-shadow .2s;
}

.card:hover{transform:translateY(-2px);box-shadow:0 12px 28px rgba(0,0,0,.7)}
canvas{width:100%;height:320px;background:linear-gradient(#0b0f14,#0a1019);}
.kbd{background:rgba(10,18,28,.8);border:1px solid #2b3f5f;color:#9fc5ff;padding:2px 6px;border-radius:6px;font-size:12px}
.stat{font-size:32px;font-weight:800;color:#fff;text-shadow:0 0 4px rgba(0,200,255,.8)}
.ok{color:#9effb5}.warn{color:#ffd18f}.bad{color:#ff9b9b}
button,.btn-primary{background:linear-gradient(135deg,#00c6ff,#0072ff);color:#fff;border:none;border-radius:12px;padding:10px 16px;font-size:15px;font-weight:600;transition:.3s background,.1s transform}
button:hover,.btn-primary:hover{background:linear-gradient(135deg,#0072ff,#00c6ff);transform:translateY(-1px)}
/* === OVERLAY: Base definition (mobile-first) === */
#overlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  background: rgba(0,0,0,.6);
  backdrop-filter: blur(8px);
  z-index: 9999;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  padding: 16px;
  animation: slideUp 0.3s ease-out;
}

#overlay.hide { display: none; }

/* === DESKTOP: top-aligned, fixed width === */
@media (min-width: 769px) {
  #overlay {
    align-items: flex-start;
    padding-top: 40px;
  }
  #overlay .card {
    width: 720px;
    max-height: 90vh;
    overflow-y: scroll;
  }
}

/* === MOBILE: bottom sheet style === */
@media (max-width: 768px) {
  #overlay {
    align-items: flex-end;
  }
  #overlay .card {
    width: 100%;
    border-radius: 24px 24px 0 0;
    max-height: 92vh;
    padding: 20px 16px 24px;
    margin: 0;
    overflow-y: scroll;
  }
}

@keyframes slideUp {
  from { opacity: 0; transform: translateY(100px); }
  to { opacity: 1; transform: translateY(0); }
}

/* === OVERLAY CARD: Main container === */
#overlay .card {
  max-height: 100vh;
  border: 1px solid rgba(0,246,255,.35);
  border-radius: 20px;
  width:1000px;
  overflow-y: scroll;

  background:
    radial-gradient(circle at 0 0, rgba(0,246,255,.14), transparent 55%),
    radial-gradient(circle at 100% 0, rgba(0,170,255,.10), transparent 45%),
    rgba(5,10,18,.94);
  box-shadow: 0 18px 40px rgba(0,0,0,.85);

  -ms-overflow-style: none;  /* IE and Edge */
  scrollbar-width: none;  /* Firefox */

}

#overlay .card::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera */
} 

/* === OVERLAY GRID: 2-column desktop, 1-column mobile === */
.overlay-grid {
  display: grid;
  grid-template-columns: minmax(0, 0.6fr) minmax(360px, 1fr);
  gap: 20px;
  align-items: stretch;
  margin-top: 14px;
}

@media (max-width: 768px) {
  .overlay-grid {
    grid-template-columns: 1fr;
    gap: 12px;
    margin-top: 12px;
  }
}

.overlay-main {
  /* overflow-y: auto; */
  padding-right: 4px;
  max-height: calc(100vh - 200px);
}

@media (max-width: 768px) {
  .overlay-main {
    max-height: unset;
    padding-right: 0;
    order: 2;
  }
}

/* === PREVIEW PANEL === */
.overlay-preview {
  position: relative;
  border-radius: 16px;
  background:
    radial-gradient(circle at 0 0, rgba(0,246,255,.16), transparent 55%),
    rgba(6,13,24,.97);
  border: 1px solid rgba(0,246,255,.3);
  box-shadow: 0 12px 30px rgba(0,0,0,.8);
  padding: 14px 14px 16px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

@media (max-width: 768px) {
  .overlay-preview {
    order: 1;
    max-height: 300px;
    overflow-y: auto;
  }
}

/* === PREVIEW IMAGE FRAME === */
.preview-image-frame {
  position: relative;
  border-radius: 12px;
  overflow: hidden;
  background: radial-gradient(circle at 50% 0, #1b2335, #05070a);
  border: 1px solid rgba(0,246,255,.25);
  min-height: 250px;
  display: flex;
  align-items: center;
  justify-content: center;
}

@media (max-width: 768px) {
  .preview-image-frame {
    min-height: 180px;
  }
}

.preview-image-frame::before {
  content: "";
  position: absolute;
  inset: -120%;
  background: conic-gradient(
    from 210deg,
    rgba(0,246,255,.5),
    transparent 35%,
    transparent 65%,
    rgba(0,246,255,.5)
  );
  opacity: .35;
  mix-blend-mode: screen;
  animation: previewGlow 12s linear infinite;
}

@keyframes previewGlow {
  to { transform: rotate(360deg); }
}

#trainPreviewImg {
  position: relative;
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
  filter: drop-shadow(0 12px 24px rgba(0,0,0,.9));
}

/* === PREVIEW TEXT & BADGES === */
.preview-title {
  font-size: .95rem;
  font-weight: 600;
  color: #e7f0ff;
}

.preview-line {
  font-size: .8rem;
  color: #9fc5ff;
}

.preview-meta-row {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 4px;
}

.badge-chip {
  font-size: .7rem;
  padding: 3px 8px;
  border-radius: 999px;
  background: rgba(5,12,24,.9);
  border: 1px solid rgba(0,246,255,.35);
  color: #cceaff;
}

.badge-chip.secondary {
  border-color: rgba(255,255,255,.15);
  color: #b7c3dd;
}

.difficulty-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
}

.diff-label {
  font-size: .7rem;
  letter-spacing: -0.02em;
  opacity: .85;
}

.diff-gauge {
  display: flex;
  gap: 2px;
}

.diagram-icon {
  font-size: .75rem;
  display: inline-flex;
  align-items: center;
}

.diagram-time {
  font-size: .65rem;
  letter-spacing: -0.02em;
  opacity: .85;
  font-weight: 500;
}

.diff-gauge .cell {
  width: 7px;
  height: 11px;
  border-radius: 3px;
  background: rgba(255,255,255,.10);
  box-shadow: 0 0 0 rgba(0,0,0,0);
  opacity: .45;
  transition: background .18s ease, opacity .18s ease, box-shadow .18s ease, transform .12s ease;
}

.diff-gauge .cell.active {
  background: var(--diff-color, #00f6ff);
  opacity: 1;
  box-shadow: 0 0 8px var(--diff-shadow, rgba(0,246,255,.75));
  transform: translateY(-1px);
}

.preview-caption {
  margin-top: 8px;
  font-size: .75rem;
  color: #8fa2c6;
  line-height: 1.5;
}

/* === FORM STYLES === */
.title {
  font-size: 1.4rem;
  font-weight: 600;
  margin-bottom: 4px;
  color: #00f6ff;
}

@media (max-width: 768px) {
  .title {
    font-size: 1.2rem;
  }
}

.subtitle {
  font-size: .8rem;
  color: #9fc5ff;
  margin-bottom: 16px;
  line-height: 1.5;
}

@media (max-width: 768px) {
  .subtitle {
    font-size: .85rem;
    margin-bottom: 12px;
  }
}

.form-label {
  display: block;
  font-size: .85rem;
  margin-bottom: 12px;
  margin-top: 4px;
  text-align: left;
  font-weight: 500;
  color: #cceaff;
}

@media (max-width: 768px) {
  .form-label {
    font-size: .8rem;
    margin-bottom: 8px;
  }
}

.form-input {
  width: 100%;
  box-sizing: border-box;
  padding: 10px 12px;
  font-size: .9rem;
  border: 1px solid rgba(0,246,255,.3);
  border-radius: 10px;
  margin-top: 4px;
  background: rgba(10,18,28,.6);
  color: #e7f0ff;
  transition: border-color 0.2s, box-shadow 0.2s;
}

.form-input:focus {
  border-color: #00f6ff;
  outline: none;
  box-shadow: 0 0 12px rgba(0,246,255,.25);
}

@media (max-width: 768px) {
  .form-input {
    font-size: .85rem;
    padding: 9px 10px;
  }
}
@keyframes snow {
  0% { transform: translateY(-20px); }
  100% { transform: translateY(100vh); }
}

.snowflakes, .raindrops {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9999;
  display: none;
  overflow: hidden;
}

.snowflakes div {
  position: absolute;
  background: #fff;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  opacity: .8;
  animation: snow 5s linear infinite;
}

.raindrops { z-index: 9998; }

.raindrops div {
  position: absolute;
  background: rgba(173,216,230,.8);
  width: 2px;
  height: 15px;
  animation: rain .5s linear infinite;
}

@keyframes rain {
  0% { transform: translateY(-20px); }
  100% { transform: translateY(100vh); }
}

/* === BODY & LAYOUT === */
body {
  overflow-x: hidden;
  overflow-y: auto;
}

@media (max-width: 768px) {
  html, body {
    height: 100%;
  }
  body {
    -webkit-overflow-scrolling: touch;
  }
  #wrap {
    padding-bottom: 100px;
  }
  canvas#hud {
    height: 42vh;
  }
}

/* Hide large right ribbon on mobile */
@media (max-width: 768px) {
  #ribbonBig { display: none !important; }
}

/* === BUTTONS === */
#btnStart {
  width: 100%;
  padding: 12px 16px;
  font-size: .95rem;
  margin-top: 12px;
  border-radius: 10px;
}

@media (max-width: 768px) {
  #btnStart {
    padding: 11px 14px;
    font-size: .9rem;
    margin-top: 8px;
  }
}

/* === KBD HELPER === */
.kbd-info {
  font-size: .75rem;
  color: #8fa2c6;
  margin-top: 8px;
  line-height: 1.4;
}

@media (max-width: 768px) {
  .kbd-info { display: none; }
}

/* === MOBILE RESTART FAB === */
.fab {
  position: fixed;
  left: 50%;
  bottom: 24px;
  transform: translateX(-50%);
  padding: 12px 20px;
  font-weight: 700;
  font-size: .9rem;
  border-radius: 999px;
  background: linear-gradient(135deg, #00c6ff, #0072ff);
  color: #fff;
  border: none;
  z-index: 10001;
  box-shadow: 0 8px 24px rgba(0,0,0,.35);
  cursor: pointer;
  pointer-events: auto;
  transition: transform 0.2s, box-shadow 0.2s;
}

.fab:active {
  transform: translateX(-50%) scale(0.95);
}

.fab.hide {
  display: none !important;
}
.mobile-control-guide{display:none;font-size:14px;color:#9fc5ff;background:rgba(18,24,38,.7);border:1px solid rgba(0,246,255,.2);padding:8px 12px;border-radius:8px;margin-bottom:12px}
@media (max-width:768px){.mobile-control-guide{display:block}}
.tasc-toggle {
  position: fixed;
  right: 20px;
  top: 60px;
  display: flex;
  align-items: center;
  gap: 6px;
  font-family: 'Orbitron', sans-serif;
  z-index: 9998;
}

@media (max-width: 768px) {
  .tasc-toggle {
    top: 555px;
    right: 8px;
  }
}
.tasc-toggle .tasc-label{font-size:12px;font-weight:600;color:#9fc5ff;user-select:none}
.tasc-toggle input{display:none}
.tasc-toggle .slider{position:relative;display:inline-block;width:46px;height:24px;background:rgba(255,255,255,.25);border-radius:24px;cursor:pointer;transition:background-color .3s;box-shadow:inset 0 0 4px rgba(0,0,0,.3)}
.tasc-toggle .slider::before{content:"";position:absolute;height:18px;width:18px;left:3px;bottom:3px;background:#fff;border-radius:50%;transition:transform .3s;box-shadow:0 1px 3px rgba(0,0,0,.4)}
.tasc-toggle input:checked + .slider{background:linear-gradient(135deg,#00c6ff,#0072ff)}
.tasc-toggle input:checked + .slider::before{transform:translateX(22px)}

.emoji { width: 1.4em; height: 1.4em; vertical-align: middle; transition: transform 0.2s;}
.emoji:hover { transform: scale(1.3);}

@media (max-width: 768px) {
  .title {
    font-size: 1.2em !important;
    padding-top: 60px;
  }
}

.title { font-size: 1.7em; font-family: 'A-OTF Shin Go Pro', sans-serif; font-style: normal; font-weight: 700; color: #0168B7; display: flex; align-items: center; gap: 8px;}

.line {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin: 4px 0;
}
.line .value {
  text-align: right;
  padding-right: 40px;  /* ğŸ‘ˆ ì˜¤ë¥¸ìª½ì— ì—¬ë°± ì£¼ê¸° (ë¼ë”ìº”ë²„ìŠ¤+ê°„ê²©) */
  min-width: 110px;     /* ğŸ‘ˆ ìˆ«ì ì¹¸ ìµœì†Œ ë„ˆë¹„ ì¡ì•„ì£¼ë©´ ë” ì•ˆì •ì  */
  max-width: 240px;
  /* Use fixed-width digits so numbers don't shift when digits change */
  font-variant-numeric: tabular-nums;
  -moz-font-feature-settings: "tnum" 1;
  -webkit-font-feature-settings: "tnum" 1;
  font-feature-settings: "tnum";
}
.line .unit {
  margin-left: 4px;
  opacity: 0.8;
  font-size: 14px;
  letter-spacing:-2px;
}

#timer .sep {
  margin: 0 8px; /* ì½œë¡  ì¢Œìš° ê°„ê²©ë§Œ ì¡°ì • */
}

@media (max-width:768px){
  .line .value { padding-right: 50px; }
}

#hud, #brakeLadder {
  touch-action: none; /* iOS 13+ / ìµœì‹  ì‚¬íŒŒë¦¬ */
  -ms-touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}

.score-overlay {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  z-index: 8;

  opacity: 0;
  transform: translateY(-15vh) scale(0.94);
  transition: opacity 0.3s ease-out, transform 0.3s ease-out;
}

.score-overlay.visible {
  opacity: 1;
  transform: translateY(-15vh) scale(1);
}

/* ì¹´ë“œ ì „ì²´: ì—­ ì•ˆë‚´íŒ/ì¢…ì´ ìŠ¹ì°¨ê¶Œ ê°™ì€ ëŠë‚Œ */
.score-card {
  min-width: 220px;
  max-width: 460px;
  padding: 22px 28px 24px;
  border-radius: 16px;

  /* ë”°ëœ»í•œ í•˜ì–€ìƒ‰ + ì‚´ì§ ì¢…ì´ ëŠë‚Œ ê·¸ë¼ë°ì´ì…˜ */
  background:
    linear-gradient(180deg,
      rgba(255,255,255,0.62),
      rgba(250,247,238,0.65)
    );

  /* ì‚´ì§ ë°˜íˆ¬ëª…í•˜ê²Œ */
  opacity: 0.96;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);

  /* ì•„ë‚ ë¡œê·¸ ë³´ë“œ ê°™ì€ í…Œë‘ë¦¬ */
  border: 1px solid rgba(185, 178, 155, 0.95);
  box-shadow:
    0 10px 26px rgba(0,0,0,0.32),
    0 0 0 1px rgba(255,255,255,0.65) inset;

  text-align: center;
  font-family: 'A-OTF Shin Go Pro', system-ui, -apple-system, 'Segoe UI', sans-serif;
  position: relative;
}

/* ìƒë‹¨ ì–‡ì€ ìƒ‰ ë¼ì¸ (ì¼ë³¸ ì—­ ì•ˆë‚´íŒ í¬ì¸íŠ¸ ì»¬ëŸ¬)
.score-card::before {
  content: "";
  position: absolute;
  left: 14px;
  right: 14px;
  top: 10px;
  height: 3px;
  border-radius: 999px;
  background: linear-gradient(90deg, #c83f2e, #f0a030);
  opacity: 0.9;
} */

/* ì¢Œìš° ì‘ì€ ì¸ì‡„ êµ¬ë©(?) / í‹°ì¼“ ëŠë‚Œ ì¥ì‹ */
.score-card::after {
  content: "";
  position: absolute;
  top: 50%;
  left: 6px;
  right: 6px;
  height: 0;
  border-top: 1px dashed rgba(180, 172, 150, 0.7);
  opacity: 0.7;
}

/* ë¼ë²¨: ì‘ì€ ë¬¸ì, ì¼ë³¸ì‹ ì•ˆë‚´ í°íŠ¸ ëŠë‚Œ */
.score-label {
  margin-top: 8px;
  font-size: 0.78rem;
  letter-spacing: 0.22em;
  text-transform: uppercase;
  color: #686055;
  opacity: 0.9;
}

/* ë©”ì¸ ì ìˆ˜: ì•„ë‚ ë¡œê·¸ ìˆ«ì ê³„ê¸°íŒ ëŠë‚Œ */
.score-value {
  margin-top: 6px;
  font-size: clamp(2.8rem, 4.4vw, 3.8rem);
  font-weight: 800;
  letter-spacing: 0.12em;
  font-variant-numeric: tabular-nums;

  color: #222222;

  /* ì‚´ì§ ëˆŒë¦° ì¸ì‡„ ëŠë‚Œ */
  text-shadow:
    0 0.5px 0 rgba(0, 0, 0, 1),
    0 1.5px 0 rgba(0,0,0,1);
}

/* ì ìˆ˜ì— ë”°ë¼ JSê°€ ë„£ì–´ì£¼ëŠ” ìƒ‰ (ë¹¨ê°•~ì£¼í™©~ì´ˆë¡ ê·¸ë¼ë°ì´ì…˜) */
.score-overlay[data-color] .score-value {
  color: var(--score-color, #222222);
  text-shadow:
    0 0.5px 0 rgba(0, 0, 0, 1),
    0 1.5px 0 rgba(0,0,0,1),
    0 0 14px var(--score-glow, rgba(0,0,0,0.08));
}

/* ì„œë¸Œ ë¬¸êµ¬: í•œ ì¤„ ì•ˆë‚´ ë¬¸êµ¬ (ì •ì°¨ í‰ê°€) */
.score-sub {
  margin-top: 10px;
  font-size: 0.95rem;
  color: #403a33;
  font-weight: 600;
}

/* ë©”íƒ€ ì •ë³´: ì •ì§€ ì˜¤ì°¨ ë“± */
.score-meta {
  margin-top: 4px;
  font-size: 0.82rem;
  color: #7a7264;
}

.score-arrival {
  margin-top: 8px;
  font-size: 0.85rem;
  font-weight: 500;
  text-align: center;
}

/* ì‘ì€ ì¡°ëª… ì¸ë””ì¼€ì´í„° ëŠë‚Œ (ì˜µì…˜: í•„ìš” ì—†ìœ¼ë©´ ì§€ì›Œë„ ë¨)
.score-meta::before {
  content: "â—";
  display: inline-block;
  margin-right: 6px;
  font-size: 0.6rem;
  color: #c83f2e;
  vertical-align: baseline;
} */

/* === 3D ìº”ë²„ìŠ¤ ì•ˆì— ë¶™ëŠ” ì‘ì€ ë¸Œë ˆì´í¬ ê³¡ì„  HUD === */
#cab3d #hud {
  position: absolute;
  right: 16px;
  bottom: 16px;
  width: 360px !important;
  height: 200px !important;
  background:
    radial-gradient(circle at 0 0, rgba(0,246,255,.18), transparent 60%),
    rgba(5,10,18,.92);
  border-radius: 12px;
  border: 1px solid rgba(0,246,255,.45);
  box-shadow: 0 10px 26px rgba(0,0,0,.85);
  pointer-events: none; /* ì¡°ì‘ì€ 3D ìº”ë²„ìŠ¤ë¡œ ê·¸ëŒ€ë¡œ */
  z-index: 7; /* cabOverlayFull(5) + miniHud(6) ë³´ë‹¤ ìœ„ */
}

/* B í‚¤ë¡œ ìˆ¨ê¸¸ ë•Œ ì‚¬ìš©í•˜ëŠ” í´ë˜ìŠ¤ */
#cab3d #hud.hud-hidden {
  display: none !important;
}

#cab3d {
  position: relative; /* three.js ìº”ë²„ìŠ¤ ê¸°ì¤€ì  */
}

/* three.js ìœ„ë¥¼ ê½‰ ë®ëŠ” ìš´ì „ì‹¤ íŒ¨ë„ */
#cabOverlayFull {
  position: absolute;
  inset: 0;
  pointer-events: none; /* ì¡°ì‘ì€ three.js ìº”ë²„ìŠ¤ë¡œ ê·¸ëŒ€ë¡œ ì „ë‹¬ */
  z-index: 5; /* three.js canvas(1) ìœ„, HUD(ë¯¸ë‹ˆì°½) ì•„ë˜/ìœ„ëŠ” í•„ìš”ì— ë”°ë¼ ì¡°ì • ê°€ëŠ¥ */
}

</style>

  <!-- Modern UI overrides: Inter font + refined glassmorphism -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
  <style id="modernize-ui">
  :root{
    --bg-0: #071022;
    --bg-1: linear-gradient(180deg,#071022 0%, #061826 60%);
    --card: rgba(255,255,255,0.04);
    --card-border: rgba(255,255,255,0.06);
    --glass-blur: 8px;
    --accent: #36c5ff;
    --accent-2: #6b8cff;
    --muted: #9fb6d6;
  }
  html,body{height:100%;}
  body{
    font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Noto Sans KR', sans-serif;
    margin:0;padding:0;
    color:#e8f2ff;background:var(--bg-1);-webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  }

  /* Global card refresh */
  .card{
    background: var(--card) !important;
    border: 1px solid var(--card-border) !important;
    border-radius:14px !important;
    padding:14px !important;
    box-shadow: 0 10px 30px rgba(4,10,20,0.6) !important;
    backdrop-filter: blur(var(--glass-blur)) saturate(1.05) !important;
  }

  /* Header / overlay */
  #overlay .card{max-width:1000px;padding:20px 20px 18px;border-radius:16px}
  .title{font-size:1.4rem;color:var(--accent);display:flex;align-items:center;gap:10px}
  .subtitle{color:var(--muted);margin-bottom:14px}

  /* Buttons */
  .btn-primary, button{background:linear-gradient(90deg,var(--accent),var(--accent-2)) !important;color:#fff !important;border:none;border-radius:12px;padding:10px 14px;font-weight:600;cursor:pointer}
  .btn-primary:hover, button:hover{transform:translateY(-2px);box-shadow:0 8px 24px rgba(18,38,76,0.45)}

  /* Inputs */
  .form-input{background:rgba(255,255,255,0.03) !important;border:1px solid rgba(255,255,255,0.04) !important;padding:10px !important;border-radius:10px !important;color:inherit}
  .form-label{color:var(--muted) !important}

  /* Preview card */
  .overlay-preview{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)) !important;border-radius:12px}
  .preview-image-frame{border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,0.04)}
  .preview-title{font-weight:700;color:#fff}
  .preview-line{color:var(--muted)}

  /* HUD cards: larger numbers, clearer spacing */
  .stat{font-size:28px;font-weight:700;color:#ffffff}
  .line{display:flex;justify-content:space-between;align-items:center;margin:8px 0}

  /* Ensure HUD numbers use tabular (fixed-width) digits for stable layout */
  .stat, #rem, #spd, #timer { font-variant-numeric: tabular-nums; font-feature-settings: "tnum"; -moz-font-feature-settings: "tnum" 1; -webkit-font-feature-settings: "tnum" 1; }

  /* Keyboard look */
  .kbd{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.06);padding:6px 8px;border-radius:8px;font-weight:600}

  /* Floating action button moved to bottom-right */
  .fab{left:auto;right:20px;bottom:20px;transform:none;border-radius:999px;padding:14px 16px}

  /* Make the overlay visually lighter and centered */
  #overlay{align-items:center;justify-content:center;padding:20px}

  /* Responsive tweaks */
  @media (max-width:840px){
    .overlay-grid{grid-template-columns:1fr !important}
    #wrap{padding:12px}
    .card{padding:12px}
  }

  /* Small helper accents */
  .badge-chip{background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);color:var(--muted);padding:6px 10px;border-radius:999px}

  /* Snow weather: page background flips to white and text becomes dark */
  body.weather-snow {
    background: #ffffff !important;
    color: #06202a !important;
  }

  .weather-snow .card{
    background: rgba(255,255,255,0.96) !important;
    border-color: rgba(10,20,30,0.06) !important;
    box-shadow: 0 10px 30px rgba(12,18,28,0.06) !important;
    color: #08202a !important;
  }

  /* Use a subtle, refined shadow for dark-on-light text (less neon, more natural) */
  .weather-snow .title,
  .weather-snow .preview-title,
  .weather-snow .stat:not(#notch),
  .weather-snow .preview-line,
  .weather-snow .form-label,
  .weather-snow .kbd,
  .weather-snow .badge-chip{
    color: #06202a !important;
    text-shadow: 0 2px 6px rgba(6,16,20,0.08) !important;
  }

  .weather-snow .kbd{ background: rgba(0,0,0,0.04) !important; border-color: rgba(0,0,0,0.06) !important; }
  .weather-snow .badge-chip{ background: rgba(2,20,30,0.03) !important; border-color: rgba(2,20,30,0.06) !important; }
  .weather-snow .overlay-preview{ background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(250,250,252,0.95)) !important; }


  </style>
</head>
<body>
<!-- === BVE SOUND ENGINE LOADING SCREEN === -->
<div id="bveLoadingScreen" style="
  position: fixed;
  inset: 0;
  background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 100%);
  display: none; /* hidden until Start is pressed */
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 99999;
  font-family: 'Segoe UI', system-ui, sans-serif;
">
  <div style="text-align: center;">
    <div style="margin-bottom: 30px;">
      <div style="font-size: 32px; font-weight: 300; color: #60a5fa; margin-bottom: 8px; letter-spacing: 1px;">
        ğŸš„ Preparing your Train...
      </div>
      <div style="font-size: 13px; color: #94a3b8; letter-spacing: 0.5px;">
        <span id="bveLoadStatus">Initializing audio context...</span>
      </div>
    </div>
    
    <div style="
      width: 240px;
      height: 4px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      overflow: hidden;
      margin: 0 auto 20px auto;   /* <-- centers it */
    ">
      <div id="bveLoadBar" style="
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #3b82f6, #60a5fa, #3b82f6);
        background-size: 200% 100%;
        animation: shimmer 2s infinite;
        border-radius: 2px;
        transition: width 0.3s ease-out;
      "></div>
    </div>

    
    <div style="font-size: 12px; color: #64748b; margin-top: 15px;">
      <span id="bveLoadPercent">0</span>% complete
    </div>
  </div>
</div>

<style>
@keyframes shimmer {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}
</style>

<canvas id="ribbonBig" style="position:fixed; right:0; top:0; bottom:0; width:27px; height:100vh; pointer-events:none; z-index:10002; display:flex; align-items:right; justify-content:center;"></canvas>
<!-- BEGIN PATSH: Cab 3D Card -->
<style>
/* Make the cab card tighter so the 3D view fills it with minimal padding */
#cabCard {
  padding: 2px 4px !important;
  margin: 0 !important;
  box-sizing: border-box;
  min-width: 0;
  align-items: stretch;
  /* display: fle/; Flex/ox layout to stretch the child */
}

#cabCard > #cab3d {
  width: 95% !important;  /* Use full width of the parent */
  margin: 0 !important;
  padding: 0 !important;
  aspect-ratio: 16/9 !important;
  box-sizing: border-box !important;
  display: block;
}

/* Slightly different spacing on very small screens */
@media (max-width: 480px) {
  #cabCard { padding: 4px !important; }
}
/* *******************************************************************
   FIXED LAYOUT: when you want the 3D view to remain the same size/pos
   regardless of browser resizing, add the `fixed-3d` class to #cabCard.
   This forces a fixed pixel width/height and pins the card to the
   viewport so it won't scale with responsive layout changes.
   *******************************************************************/
#cabCard.fixed-3d {
  position: fixed !important;
  left: 50% !important;
  top: 80px !important;             /* tweak this to change vertical position */
  transform: translateX(-50%) !important;
  width: 800px !important;          /* fixed width */
  height: 450px !important;         /* fixed height */
  z-index: 10003 !important;
  padding: 2px !important;
  margin: 0 !important;
  box-shadow: 0 12px 32px rgba(0,0,0,0.6) !important;
}

/* ensure inner 3D mount fills the fixed card exactly */
#cabCard.fixed-3d > #cab3d {
  width: 100% !important;
  height: 100% !important;
  aspect-ratio: unset !important;
  margin: 0 !important;
  padding: 0 !important;
  box-sizing: border-box !important;
  display: block !important;
}
/* ë‘ í† ê¸€ì„ í•œ ì¤„ì— ì˜¤ë¥¸ìª½ ìƒë‹¨ ë°°ì¹˜ */
.toggle-bar {
  position: fixed;
  right: 120px;
  top: 60px;
  display: flex;
  align-items: center;
  font-size: 12px;
  font-weight: 600;
  color: #9fc5ff;
  user-select: none;
  gap: 10px;
  z-index: 9998;
}

@media (max-width: 768px) {
  .toggle-bar {
    top: 555px;
    font-size: 11px;
    right: 100px;
    z-index: 9998;
  }
}

/* ëœë¤ í† ê¸€ì€ TASCì™€ ë™ì¼í•œ ëª¨ì–‘ ì¬ì‚¬ìš© */
.rnd-toggle{ display:flex; align-items:center; gap:6px; font-family:'Orbitron',sans-serif; }
.rnd-toggle input{ display:none; }
.rnd-toggle .slider{
  position:relative; display:inline-block; width:46px; height:24px;
  background:rgba(255,255,255,.25); border-radius:24px; cursor:pointer; transition:background-color .3s;
  box-shadow:inset 0 0 4px rgba(0,0,0,.3)
}
.rnd-toggle .slider::before{
  content:""; position:absolute; height:18px; width:18px; left:3px; bottom:3px; background:#fff; border-radius:50%;
  transition:transform .3s; box-shadow:0 1px 3px rgba(0,0,0,.4)
}
.rnd-toggle input:checked + .slider{ background:linear-gradient(135deg,#00c6ff,#0072ff) }
.rnd-toggle input:checked + .slider::before{ transform:translateX(22px) }
</style>

<script>


let scoreOverlayEl = null;
let scoreValueEl = null;
let scoreSubEl = null;
let scoreMetaEl = null;
let scoreAnimId = null;
let scoreAnimStartTs = null;
let scoreAnimFrom = 0;
let scoreAnimTo = 0;
let lastFinishedFlag = false; // ws ìƒíƒœì˜ finished ë³€í™”ë¥¼ ê°ì§€

function initScoreOverlayDom() {
  scoreOverlayEl = document.getElementById("scoreOverlay");
  scoreValueEl = document.getElementById("scoreOverlayValue");
  scoreSubEl = document.getElementById("scoreOverlaySub");
  scoreMetaEl = document.getElementById("scoreOverlayMeta");
}

function lerpChannel(a, b, t) {
  return Math.round(a + (b - a) * t);
}


function colorFromScore(score) {
  const s = Math.max(0, Math.min(100, score || 0)) / 100;

  // ëì  ìƒ‰ìƒ
  const red = { r: 0xff, g: 0x4b, b: 0x4b }; // #ff4b4b (ë‚®ì€ ì ìˆ˜)
  const mid = { r: 0xff, g: 0xb8, b: 0x4d }; // #ffb84d (ì˜ˆìœ ì£¼í™©+ë…¸ë‘)
  const green = { r: 0x4c, g: 0xd9, b: 0x64 }; // #4cd964 (ë†’ì€ ì ìˆ˜)

  let c;
  if (s <= 0.5) {
    // 0~50ì : ë¹¨ê°• â†’ ì£¼í™©
    const t = s / 0.5;
    c = {
      r: lerpChannel(red.r, mid.r, t),
      g: lerpChannel(red.g, mid.g, t),
      b: lerpChannel(red.b, mid.b, t),
    };
  } else {
    // 50~100ì : ì£¼í™© â†’ ì´ˆë¡
    const t = (s - 0.5) / 0.5;
    c = {
      r: lerpChannel(mid.r, green.r, t),
      g: lerpChannel(mid.g, green.g, t),
      b: lerpChannel(mid.b, green.b, t),
    };
  }

  const rgb = `rgb(${c.r}, ${c.g}, ${c.b})`;
  const glow = `rgba(${c.r}, ${c.g}, ${c.b}, 0.92)`;
  return { rgb, glow };
}
function formatScore(n) {
  const v = Math.max(0, Math.min(100, Math.round(n)));
  return v.toString().padStart(1, "0");
}

function chooseSubMessage(score, stopErr) {
  // const s = Math.max(0, Math.min(100, score || 0));
  // const e = Math.abs(stopErr ?? 0);

  // if (e <= 0.15 && s >= 98) return "ğŸ’ Perfect stop!";
  // if (e <= 0.3 && s >= 95) return "ğŸ¯ Almost perfect!";
  // if (s >= 90) return "ğŸš† Great braking control!";
  // if (s >= 75) return "ğŸ‘ Nice run. Can be smoother.";
  // if (s >= 50) return "ğŸ“ Try to brake a bit earlier.";
  // return "ğŸ’¡ Watch distance & brake in steps.";
  return "Press Space to continue"
}

function showScoreOverlay(finalScore, stopErr) {
  if (!scoreOverlayEl || !scoreValueEl || !scoreSubEl || !scoreMetaEl) {
    initScoreOverlayDom();
    if (!scoreOverlayEl) return;
  }

  // ì• ë‹ˆë©”ì´ì…˜ ì´ˆê¸°í™”
  if (scoreAnimId) cancelAnimationFrame(scoreAnimId);
  scoreAnimStartTs = null;
  scoreAnimFrom = 0;
  scoreAnimTo = Math.max(0, Math.min(100, finalScore || 0));

  const subMsg = chooseSubMessage(scoreAnimTo, stopErr);
  scoreSubEl.textContent = subMsg;

  const errText = (typeof stopErr === "number")
    ? `Stop error: ${stopErr.toFixed(2)} m`
    : "";
  scoreMetaEl.textContent = errText;

  // ë„ì°© ì‹œê°„ ìƒíƒœ í‘œì‹œ
  const arrivalEl = document.getElementById("scoreOverlayArrival");
  if (arrivalEl && typeof window.__miniTimerRemaining === "number") {
    const remaining = window.__miniTimerRemaining;
    if (remaining >= 0) {
      arrivalEl.textContent = "On time";
      arrivalEl.style.color = "#4CAF50"; // ë…¹ìƒ‰
    } else {
      const lateSeconds = Math.abs(remaining);
      arrivalEl.textContent = `${lateSeconds} seconds late`;
      arrivalEl.style.color = "#f44336"; // ë¹¨ê°„ìƒ‰
    }
  }

  scoreOverlayEl.classList.add("visible");

  const duration = 1200; // ms

  function step(ts) {
    if (!scoreAnimStartTs) scoreAnimStartTs = ts;
    const t = Math.min(1, (ts - scoreAnimStartTs) / duration);
    const current = scoreAnimFrom + (scoreAnimTo - scoreAnimFrom) * t;
    const c = colorFromScore(current);

    scoreValueEl.textContent = formatScore(current);
    scoreOverlayEl.style.setProperty("--score-color", c.rgb);
    scoreOverlayEl.style.setProperty("--score-glow", c.glow);
    scoreOverlayEl.dataset.color = "on";

    if (t < 1) {
      scoreAnimId = requestAnimationFrame(step);
    } else {
      scoreAnimId = null;
    }
  }
  scoreAnimId = requestAnimationFrame(step);
}

function hideScoreOverlay() {
  if (!scoreOverlayEl) initScoreOverlayDom();

  // DOM ìª½ ìƒíƒœ ê°•ì œ ë¦¬ì…‹
  if (scoreOverlayEl) {
    scoreOverlayEl.classList.remove("visible");
    scoreOverlayEl.style.opacity = ""; // íŠ¸ëœì§€ì…˜ ë¬´ì‹œí•˜ê³  ë°”ë¡œ 0
    scoreOverlayEl.style.transform = "";
    scoreOverlayEl.dataset.color = "";
  }

  // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ë„ ì™„ì „íˆ ì •ì§€
  if (scoreAnimId) {
    cancelAnimationFrame(scoreAnimId);
    scoreAnimId = null;
  }
}

// ğŸ”´ğŸŸ¢ ì„ ë¡œ ì¥ì• ë¬¼ ìƒíƒœ ê´€ë¦¬
let hazardInfo = {
  active: false, // ì´ë²ˆ ëŸ°ì—ì„œ ì¥ì• ë¬¼ ì¡´ì¬ ì—¬ë¶€
  dist: null, // ì¥ì• ë¬¼ ìœ„ì¹˜ (remaining_m ê¸°ì¤€)
  handled: false, // ì„±ê³µ/ì‹¤íŒ¨ ì´ë²¤íŠ¸ ì´ë¯¸ ì²˜ë¦¬í–ˆëŠ”ì§€
  timeoutId: null, // 5ì´ˆ í›„ ì œê±° íƒ€ì´ë¨¸
  success: false // ì¥ì• ë¬¼ ì• ì •ìƒ ì •ì§€ ì—¬ë¶€
};

// íŒì—… DOM ìºì‹œ
let obstacleFailPopup = null;
let obstacleSuccessPopup = null;

// DOM ì¤€ë¹„ë˜ë©´ ìºì‹œ
window.addEventListener("DOMContentLoaded", () => {
  obstacleFailPopup = document.getElementById("obstacleFailPopup");
  obstacleSuccessPopup = document.getElementById("obstacleSuccessPopup");

  // í´ë¦­ìœ¼ë¡œë„ ë‹«ê¸°(ë°– ì˜ì—­ í´ë¦­ ì‹œ)
  [obstacleFailPopup, obstacleSuccessPopup].forEach(p => {
    if (!p) return;
    p.addEventListener("click", (ev) => {
      if (ev.target === p) hideObstaclePopups();
    });
  });
});


function resetHazardState() {
  if (hazardInfo.timeoutId) {
    clearTimeout(hazardInfo.timeoutId);
    hazardInfo.timeoutId = null;
  }
  hazardInfo.active = false;
  hazardInfo.dist = null;
  hazardInfo.handled = false;
  hazardInfo.success = false; // success í”Œë˜ê·¸ ì¶”ê°€í–ˆë‹¤ë©´ ê°™ì´ ì´ˆê¸°í™”
}

function anyObstaclePopupVisible() {
  return (obstacleFailPopup && obstacleFailPopup.classList.contains("visible")) ||
         (obstacleSuccessPopup && obstacleSuccessPopup.classList.contains("visible"));
}

function hideObstaclePopups() {
  if (obstacleFailPopup) obstacleFailPopup.classList.remove("visible");
  if (obstacleSuccessPopup) obstacleSuccessPopup.classList.remove("visible");

  //  ì´ ì‹œì ì—ì„œ ì´ë²ˆ ì¥ì• ë¬¼ ì‹œë‚˜ë¦¬ì˜¤ëŠ” ì™„ì „íˆ ëë‚œ ê²ƒìœ¼ë¡œ ê°„ì£¼
  if (window.hazardInfo) {
    hazardInfo.handled = true; // ë‹¤ì‹œëŠ” ê°™ì€ ì¥ì• ë¬¼ë¡œ ì´ë²¤íŠ¸ ì•ˆ ëœ¸
    hazardInfo.active = false;
    if (hazardInfo.timeoutId) {
      clearTimeout(hazardInfo.timeoutId);
      hazardInfo.timeoutId = null;
    }
  }

  // ğŸ”§ ì¥ì• ë¬¼ ë©”ì‰¬ë„ ë°”ë¡œ ì§€ìš°ê¸° (êµ³ì´ í™”ë©´ì— ë” ë‘ê³  ì‹¶ì§€ ì•Šìœ¼ë©´)
  try {
    if (typeof clearEmergencyObstacle === "function") {
      clearEmergencyObstacle();
    }
  } catch (e) {}
}

function showObstacleWarning() {
  if (obstacleFailPopup) obstacleFailPopup.classList.add("visible");
    if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type: "cmd",
      payload: { name: "obstacleStopFail" }
    }));
  }
}

function showObstacleSuccess() {
  if (hazardInfo) {
    hazardInfo.success = true; 
  }
  if (obstacleSuccessPopup) obstacleSuccessPopup.classList.add("visible");
    //  ì„œë²„ì— â€œì¥ì• ë¬¼ ì• ì •ìƒ ì •ì§€í–ˆë‹¤â€ ì‹ í˜¸ ë³´ë‚´ê¸°
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type: "cmd",
      payload: { name: "obstacleStopSuccess" }
    }));
  }
}

// 5ì´ˆ ë’¤ ì¥ì• ë¬¼ ì‚­ì œ ìŠ¤ì¼€ì¤„
function scheduleObstacleClear() {
  if (hazardInfo.timeoutId) return;
  hazardInfo.timeoutId = setTimeout(() => {
    try {
      clearEmergencyObstacle();
    } catch (e) {}
    hazardInfo.active = false;
    hazardInfo.dist = null;
    hazardInfo.timeoutId = null;
  }, 5000);
}

// ìƒíƒœ(State) ë“¤ì–´ì˜¬ ë•Œë§ˆë‹¤ í˜¸ì¶œí•´ì„œ ì´ë²¤íŠ¸ íŒë‹¨
function handleObstacleState(st) {
  if (!hazardInfo.active || hazardInfo.handled || !st) return;
    //  ì´ë¯¸ ëë‚œ ëŸ°ì´ë©´ ì¥ì• ë¬¼ íŒì • ì•ˆ í•¨
  if (st.finished) return;
  const rem = Number(st.remaining_m ?? 0);
  const speed = Number(st.v ?? 0); // m/s
  const hazardDist = hazardInfo.dist;
  if (hazardDist == null) return;

  //  ì•ˆì „ ì •ì§€ ì¡°ê±´: ì¥ì• ë¬¼ ìœ„ì¹˜ ê¸°ì¤€ 200m ì´ë‚´ì—ì„œ ì†ë„ 0 ê·¼ì²˜
  // rem: ì •ì°¨ ìœ„ì¹˜ê¹Œì§€ì˜ ë‚¨ì€ ê±°ë¦¬
  // hazardDist: ì¥ì• ë¬¼ ìœ„ì¹˜ê¹Œì§€ì˜ ë‚¨ì€ ê±°ë¦¬
  // â†’ rem âˆˆ [hazardDist, hazardDist+200] & vâ‰ˆ0
  if (rem >= hazardDist && rem <= hazardDist + 350 && speed > 0.1 && speed < 0.2) {
    hazardInfo.handled = true;
    showObstacleSuccess();
    scheduleObstacleClear();
    return;
  }

  //  ì¶©ëŒ ì¡°ê±´: ì¥ì• ë¬¼ ìœ„ì¹˜ë¥¼ ì§€ë‚˜ì³ë²„ë¦¼ (rem < hazardDist)
  if (rem < hazardDist) {
    hazardInfo.handled = true;
    showObstacleWarning();
    scheduleObstacleClear();
  }
}

// ğŸ”¹ Get ATC max speed based on remaining distance
// Find the most restrictive speed limit where remaining_m <= distance
// If remaining_m exceeds all thresholds, return null (no limit yet)
function getAtcMaxSpeed(remaining_m) {
  if (!window.__routeAtcData || !Array.isArray(window.__routeAtcData)) {
    return null;
  }
  
  let matchedSpeed = null;
  
  // Find all thresholds where remaining_m <= distance, pick the one with smallest distance
  // (most restrictive limit that applies at this distance)
  for (const entry of window.__routeAtcData) {
    if (typeof entry.distance === 'number' && typeof entry.atc_change === 'number') {
      // If remaining distance is within this threshold
      if (remaining_m <= entry.distance) {
        // Keep the smallest distance threshold (most restrictive)
        if (matchedSpeed === null || entry.distance < matchedSpeed.distance) {
          matchedSpeed = entry;
        }
      }
    }
  }
  
  return matchedSpeed ? { speed: Math.round(matchedSpeed.atc_change), bell: matchedSpeed.atc_bell || 0 } : null;
}

/* Defensive runtime enforcement to override any inline width:50% */
(function(){
  const cab = document.getElementById('cab3d');
  const cabCard = document.getElementById('cabCard');
  if (cabCard) cabCard.style.padding = '2px 4px';
  if (cab) {
    cab.style.width = '100%';  /* Ensure 3D view takes up full available width */
    cab.style.margin = '0';
    cab.style.padding = '0';
    cab.style.boxSizing = 'border-box';
    // mark dataset to indicate whether fixed layout is enabled
    try { cab.dataset.fixed = cabCard && cabCard.classList.contains('fixed-3d') ? 'true' : 'false'; } catch(e){}
  }
})();
</script>
<div class="card" id="cabCard" style="flex:0 1 auto;" align="center">
  <div id="cab3d" style="background:#000;overflow:hidden">
  <!-- ğŸ”¹ 3D ì˜¤ë¥¸ìª½ ìœ„ ë¯¸ë‹ˆ HUD -->
  <div id="miniHud" class="mini-hud">
<div class="mini-hud-header">
  <span id="miniHudTitle">RUN STATUS</span>
  <span class="mini-hud-dot"></span>
</div>
    <div class="mini-hud-rows">
      <div class="mini-row">
        <span class="mini-label"></span>
        <span class="mini-value" id="miniClock">--:--:--</span>
      </div>
      <div class="mini-row timer">
        <span class="mini-label">To Next Sta.</span>
        <span class="mini-value" id="miniTimer">
          <span class="min">00</span>
          <span class="sep">:</span><span class="sec">00</span>
        </span>
      </div>

      <div class="mini-row">
        <span class="mini-label">Next</span>
        <span class="mini-value" id="miniNext">â€”</span>
      </div>

      
      <div class="mini-row">
        <span class="mini-label">Speed</span>
        <span class="mini-value" id="miniSpeed">â€”</span>
      </div>
      
      <div class="mini-row">
        <span class="mini-label">Max Speed</span>
        <span class="mini-value atc-limit" id="miniMaxSpeed">â€”</span>
      </div>
      
      <!-- <div class="mini-row">
        <span class="mini-label">Next Limit</span>
        <span class="mini-value" id="miniNextLimit">â€”</span>
      </div> -->

      <div class="mini-row">
        <span class="mini-label">Distance</span>
        <span class="mini-value" id="miniRemain">â€”</span>
      </div>

      <div class="mini-row grade">
        <span class="mini-label">Grade</span>
        <span class="mini-value" id="miniGrade">â€”</span>
      </div>

      <div class="mini-row">
        <span class="mini-label">Notch</span>
        <span class="mini-value" id="miniNotch">-</span>
      </div>
    </div>
  </div>


    <!-- ğŸ”¹ 3D ì˜¤ë¥¸ìª½ ì•„ë˜ ë¸Œë ˆì´í¬ ê³¡ì„  HUD -->
    <canvas id="hud"></canvas>

        <!-- ğŸ”¹ ê²Œì„ ì¢…ë£Œ ì‹œ ì¤‘ì•™ ì ìˆ˜ ì˜¤ë²„ë ˆì´ -->
    <div id="scoreOverlay" class="score-overlay">
      <div class="score-card">
        <div class="score-label">FINAL SCORE</div>
        <div class="score-value" id="scoreOverlayValue">000</div>
        <div class="score-sub" id="scoreOverlaySub">Perfect stop!</div>
        <div class="score-meta" id="scoreOverlayMeta"></div>
        <div class="score-arrival" id="scoreOverlayArrival"></div>
      </div>
    </div>

</div>


  <div class="hint" style="font-size:12px;color:#9fc5ff;margin-top:6px">
    <!-- 200m ì§€ì ë¶€í„° 50m ê°„ê²©ìœ¼ë¡œ ì°¸ê³  í‘œì§€íŒì´ ì„¤ì¹˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤. -->
  </div>
</div>




<!-- Runtime: lock current pixel size so the card and 3D mount stop resizing with viewport
     This sets inline width/height in pixels (no visual change) and exposes
     window.__cab3d_forced_fixed used by the renderer's resize() to keep renderer size stable. -->
<script>
  (function(){
    try {
      const cabCard = document.getElementById('cabCard');
      const cab = document.getElementById('cab3d');
      if (!cabCard || !cab) return;
      // measure current layout size (includes padding/border box due to box-sizing)
      const rect = cabCard.getBoundingClientRect();
      const w = Math.max(16, Math.round(rect.width));
      const h = Math.max(16, Math.round(rect.height));

      // Lock the card to this pixel size without changing its visual placement
      cabCard.style.width = w + 'px';
      cabCard.style.height = h + 'px';
      // prevent flex container from shrinking/growing it
      cabCard.style.flex = '0 0 ' + w + 'px';
      cabCard.style.minWidth = w + 'px';
      cabCard.style.maxWidth = w + 'px';
      cabCard.style.boxSizing = 'border-box';

      // ensure internal mount fills the card
      cab.style.width = '100%';
      cab.style.height = '100%';
      cab.style.boxSizing = 'border-box';

      // let three.js resize() use this fixed size
      window.__cab3d_forced_fixed = { width: w, height: h };
    } catch (e) {
      console.debug('cab3d lock failed', e);
    }
  })();
</script>

<!-- END PATSH: Cab 3D Card -->
<div id="wrap" class="row" style="flex-direction:column">
  <div class="row" style="gap:16px;flex-wrap:wrap">

 <!--   <div class="mobile-control-guide" id="mobileGuide">
      ğŸ“± <b>ëª¨ë°”ì¼ ì¡°ì‘ ì•ˆë‚´:</b> ìº”ë²„ìŠ¤(ê·¸ë˜í”„) ìœ„ë¥¼ í„°ì¹˜í•˜ì„¸ìš”.<br>
      ìœ„ìª½ í„°ì¹˜ â†’ ë¸Œë ˆì´í¬ ê°•í™” ğŸ”¼ / ì•„ë˜ìª½ í„°ì¹˜ â†’ ì™„í™” ğŸ”½<br>
      ì •ì°¨ í›„ ì•„ë˜ í™”ë©´ì—ì„œ í”¼ë“œë°±ì„ í™•ì¸í•˜ì„¸ìš”.
    </div> -->

<div class="card" style="flex:1 1 260px; position: relative; display: none;">
    
  <div id="carName" style="font-size:20px; font-family: 'A-OTF Shin Go Pro', sans-serif; font-style: normal;" class="stat">ì°¨ëŸ‰ ë¡œë”© ì¤‘...</div>

<div class="line">
  <span id="labelRemainTime">ë„ì¿„ì—­</span>
  <span class="stat value" id="timer">
    <span class="min">00</span><span class="sep">:</span><span class="sec">00</span>
  </span>
</div>

<div class="line">
  <span id="labelSpeed">ì†ë„</span>
  <span class="stat value"><span id="spd">â€”</span><span class="unit"> km/h</span></span>
</div>
<div class="line">
  <span id="labelRemainDist">ì •ì°¨</span>
  <span class="stat value" id="rem">â€”</span>
</div>

<div class="line">
  <span id="labelGrade">êµ¬ë°°</span>
  <span class="stat value"><span id="grade_percent">â€”</span><span class="unit"> â€°</span></span>
</div>
<div class="line">
  <span id="labelNotch">ë…¸ì¹˜</span>
  <span class="stat value" id="notch">-</span>
</div>
  <div style="margin-top:8px">
    <!-- <span id="labelControls">ì¡°ì‘:</span> -->
    <span class="kbd">Space</span> <span id="labelStartKey">ì¬ì‹œì‘</span> Â·
    <span class="kbd">W</span> <span id="labelUp">ì œë™ ì²´ê²°</span> Â·
    <span class="kbd">S</span> <span id="labelDown">ì œë™ ì™„í•´</span> Â·
    <span class="kbd">A</span> <span id="labelRestart">6ë‹¨ ì œë™</span> Â·
    <span class="kbd">B</span> <span id="labelRestart">ì œë™ê³¡ì„ </span>
    <!-- <span id="labelRelease">ì¤‘ë¦½</span> <span class="kbd">N</span> -->
  </div>

  <canvas id="brakeLadder" style="position:absolute; right:10px; top:30px; width:28px; height:70%;"></canvas>
  <!-- í° ìš°ì¸¡ ë¦¬ë³¸: í˜ì´ì§€ ì˜¤ë¥¸ìª½ì— ê³ ì •ë˜ì–´ HUDì˜ ë¦¬ë³¸/ë‹¤ì´ì•„ëª¬ë“œë¥¼ ë” í¬ê²Œ í‘œì‹œí•©ë‹ˆë‹¤ -->
</div>

<!-- <div class="card" style="flex:2 1 520px"><canvas id="hud"></canvas></div> -->
<div class="card" style="flex:1 1 240px"><div><b>Feedback</b></div><div id="fb">Spaceë¡œ ì‹œì‘. W/Së¡œ ë¸Œë ˆì´í¬ ì¡°ì ˆí•˜ì„¸ìš”.</div></div>
</div>
</div>

<!-- ì˜¤ë²„ë ˆì´ -->
<div id="overlay">
  <div class="card">
<h2 class="title">
  <img id="trainIcon" src="/static/logos/e233_logo.png" alt="E233" class="emoji">
  Super Express trainsim
</h2>

    <p class="subtitle" id="subtitleIntro">
      TASCê°€ í™œì„±í™”ëœ ìƒíƒœì—ì„œë„, ìš´ì „ìëŠ” ìˆ˜ë™ ì¡°ì‘ìœ¼ë¡œ ìš´ì „ì— ê°œì…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    </p>

    <!-- í† ê¸€ ë°”: Random / TASC (ê¸°ì¡´ ê·¸ëŒ€ë¡œ ì‚¬ìš©) -->
    <div class="toggle-bar">
      <div class="rnd-toggle">
        <input type="checkbox" id="rndToggle" />
        <label for="rndToggle" class="slider"></label>
        <span class="tasc-label" style="font-family: 'A-OTF Shin Go Pro', sans-serif; font-style: normal; font-weight: 700; ">â± Drive Mode</span>
      </div>
    </div>

    <div class="tasc-toggle">
      <input type="checkbox" id="tascToggle" unchecked />
      <label for="tascToggle" class="slider"></label>
      <span class="tasc-label" id="labelTASC" style="font-family: 'A-OTF Shin Go Pro', sans-serif; font-style: normal; font-weight: 700; ">TASC</span>
    </div>

    <!-- ğŸ‘‡ ì¢Œâ€“ìš° 2ì—´ ë ˆì´ì•„ì›ƒ -->
    <div class="overlay-grid">
      <!-- ì¢Œì¸¡: ì…ë ¥ í¼ -->
      <div class="overlay-main">
        <!-- 3D on/off -->
        <label class="form-label" style="display: none;"><span>3D Graphics</span>
          <select id="syncMode" class="form-input">
            <option value="on" selected>Enable (PC Recommended)</option>
            <option value="off">Disable</option>
          </select>
        </label>

        <!-- ì „ë™ì°¨ / ì‹œë¦¬ì¦ˆ -->
        <label class="form-label"><span id="labelTrain">ì „ë™ì°¨</span>
          <select id="trainFamily" class="form-input">
            <option value="E233" selected>E233ê³„</option>
            <option value="E235">E235ê³„</option>
            <option value="N700S">ì‹ ì¹¸ì„¼ N700Sê³„</option> 
            <option value="3000">ì„œìš¸êµí†µê³µì‚¬ 3000í˜¸ëŒ€ VVVF ì „ë™ì°¨</option>
            <option value="100000">í•œêµ­ì² ë„ê³µì‚¬ 100000í˜¸ëŒ€ ì „ë™ì°¨</option> 
            <!-- <option value="E721">E721ê³„</option> -->
            <!-- <option value="EF510">EF510í˜• ì „ê¸°ê¸°ê´€ì°¨ + E26ê³„ ê°ì°¨</option>  -->
            <!-- <option value="GE999">ì´ˆì°¨ì›ê¸°ê´€ ë³´ì¼ëŸ¬ GR-0999-SV</option>  -->
          </select>
        </label>

        <label class="form-label"><span id="labelSeries">ì‹œë¦¬ì¦ˆ</span>
          <select id="trainSeries" class="form-input"></select>
        </label>

        <!-- ì†ë„ / ê±°ë¦¬ / ê²½ì‚¬ -->
        <label class="form-label"><span id="labelInitSpeed">ì´ˆê¸° ì†ë„ (km/h)</span>
          <input id="inputSpeed" type="number" value="80" min="40" max="300" step="5" class="form-input">
        </label>

        <label class="form-label"><span id="labelInitDist">ê±°ë¦¬ (m)</span>
          <input id="inputDist" type="number" value="600" min="150" max="60000" step="100" class="form-input">
        </label>

        <label class="form-label"><span id="labelGradeInput">ê²½ì‚¬ë„ (â€°)</span>
          <input id="inputGrade" type="number" value="0.0" min="-10" max="10" step="0.1" class="form-input">
        </label>

        <label class="form-label"><span id="labelTimeofDay">ì‹œê°„ëŒ€</span>
          <select id="timeOfDaySelect" class="form-input">
            <option value="day" selected>ì£¼ê°„</option>
            <option value="night">ì•¼ê°„</option>
          </select>
        </label>

        <!-- ë‚ ì”¨ / íƒ‘ìŠ¹ë¥  -->
        <label class="form-label"><span id="labelWeather">ë‚ ì”¨</span>
          <select id="weatherSelect" class="form-input">
            <option value="ë§‘ìŒ">ë§‘ìŒ</option>
            <option value="ëˆˆì˜´">ê°•ì„¤/ë¹™íŒ</option>
            <option value="ë¹„ì˜´">ìš°ì²œ</option>
          </select>
        </label>


        <label class="form-label"><span id="labelLoadRate">ìŠ¹ê° íƒ‘ìŠ¹ë¥  (%)</span>
          <input id="inputLoadRate" type="number" value="70" min="0" max="120" step="1" class="form-input">
        </label>

        <!-- í¸ì„± -->
        <label class="form-label"><span id="labelTrainLength">í¸ì„±</span>
          <select class="form-input" id="trainLength" onchange="updateTrainLength()"></select>
        </label>

        <div class="kbd-info">
          <span class="kbd">W</span> ì œë™ ì²´ê²° Â·

          <span class="kbd">A</span> 6ë‹¨(5ë‹¨) ìƒìš© ì œë™ Â·

          <span class="kbd">B</span> ì œë™ê³¡ì„  ì¼œê¸°/ë„ê¸° Â·

          <span class="kbd">E</span> ë¹„ìƒ ì œë™ Â·

          <span class="kbd">S</span> ì œë™ í•´ì œ ë° ê°€ì† Â·

          <span class="kbd">Q</span> ìµœëŒ€ìƒìš©ê°€ì† Â·

          <span class="kbd">N</span> ì¤‘ë¦½ ê¸°ì–´ Â·

          <span class="kbd">H</span> ê²½ì  Â·

          <span class="kbd">Space</span> ì¬ì‹œì‘ Â·

          <span class="kbd">F5</span> ì—´ì°¨ ë³€ê²½
        </div>

        <button id="btnStart" class="btn-primary" type="button" style="margin-top:8px">
          Start (Space)
        </button>
      </div>

      <!-- ìš°ì¸¡: ì—´ì°¨ í”„ë¦¬ë·° íŒ¨ë„ -->
      <aside class="overlay-preview" aria-label="Selected train preview">
        <div class="preview-image-frame">
          <!-- ê¸°ë³¸ ì¸ë„¤ì¼ (ì´ˆê¸°ê°’) â€“ JSì—ì„œ trainSeries ì„ íƒ ì‹œ êµì²´ -->
          <img id="trainPreviewImg" src="/static/emu_db/e233_1000.png" alt="Train preview">
        </div>

        <div class="preview-title" id="trainPreviewName" style="font-family: 'A-OTF Shin Go Pro', sans-serif; font-style: normal; font-weight: 700; ">
          JR EAST E233-1000
        </div>

        <div class="preview-line" id="trainPreviewLine">
          ê²Œì´íŒí† í˜¸ì¿ ì„ Â·ë„¤ê¸°ì‹œì„ 
        </div>

        <div class="preview-meta-row">
          <!-- 1: ê³„ì—´ -->
          <span class="badge-chip" id="trainPreviewFamily">E233ê³„</span>

          <!-- 2: í¸ì„± -->
          <span class="badge-chip secondary" id="trainPreviewFormation">10ëŸ‰ í¸ì„±</span>

          <!-- 3: ì œë™ ë‚œì´ë„ -->
          <span class="badge-chip difficulty-badge" id="brakeDiffBadge">
            <span class="diff-label">ì œë™ ë‚œì´ë„</span>
            <span class="diff-gauge" id="brakeDiffGauge">
              <span class="cell"></span>
              <span class="cell"></span>
              <span class="cell"></span>
              <span class="cell"></span>
              <span class="cell"></span>
            </span>
          </span>

          <!-- 4: ì¡°ì‘ ë‚œì´ë„ -->
          <span class="badge-chip difficulty-badge secondary" id="ctrlDiffBadge">
            <span class="diff-label">ì¡°ì‘ ë‚œì´ë„</span>
            <span class="diff-gauge" id="ctrlDiffGauge">
              <span class="cell"></span>
              <span class="cell"></span>
              <span class="cell"></span>
              <span class="cell"></span>
              <span class="cell"></span>
            </span>
          </span>

          <!-- 5: ë‹¤ì´ì–´ê·¸ë¨ ì†Œìš”ì‹œê°„ -->
          <span class="badge-chip secondary" id="diagramTimeBadge" style="display: none;">
            <span class="diagram-icon">â±</span>
            <span class="diagram-time" id="diagramTimeText"></span>
          </span>
        </div>

        <p class="preview-caption" id="trainPreviewCaption">
          ì „ë™ì°¨ ê³„ì—´ê³¼ ì‹œë¦¬ì¦ˆ, í¸ì„±ì„ ë³€ê²½í•˜ë©´ ì´ ì˜ì—­ì— í•´ë‹¹ ì—´ì°¨ì˜ ì™¸í˜• ì´ë¯¸ì§€ì™€ ë…¸ì„  ì •ë³´ê°€ ë¯¸ë¦¬ë³´ê¸°ë¡œ í‘œì‹œë©ë‹ˆë‹¤.
        </p>
      </aside>
    </div>

    <!-- ë‚ ì”¨ ì´í™íŠ¸ DOM (ê¸°ì¡´ ìœ ì§€) -->
    <div class="game-background"></div>
    <div class="snowflakes"></div>
    <div class="raindrops">
      <div style="animation-delay:0s;left:5%"></div><div style="animation-delay:.2s;left:15%"></div>
      <div style="animation-delay:.4s;left:25%"></div><div style="animation-delay:.6s;left:35%"></div>
      <div style="animation-delay:.8s;left:45%"></div><div style="animation-delay:1s;left:55%"></div>
      <div style="animation-delay:1.2s;left:65%"></div><div style="animation-delay:1.4s;left:75%"></div>
      <div style="animation-delay:1.6s;left:85%"></div><div style="animation-delay:1.8s;left:95%"></div>
    </div>
  </div>
</div>



<!-- ì¬ì‹œì‘ FAB -->
<button id="btnMobileRestart" class="fab hide" type="button">ì¬ì‹œì‘</button>


<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<script>

/* ===== WebSocket & TASC ===== */

//ì—¬ê¸°ì•¼
const CAB_LAYOUTS = {
  default: {
    src: "/static/photos/cab.png", // TODO: ì‹¤ì œ ê²½ë¡œë¡œ ìˆ˜ì •
    size: { width: 1920, height: 1080 }, // TODO: PNG ì›ë³¸ í•´ìƒë„
    windowPoly: [
      [
[534, 150], [550, 741], [712, 740], [596, 567], [584, 568], [581, 674], [575, 670], [575, 590], 
[571, 400], [571, 388], [570, 318], [572, 325], [586, 488], [594, 485], [597, 560], [603, 572], 
[721, 741], [879, 742], [1028, 742], [1181, 742], [1383, 742], [1497, 740], [1562, 741], 
[1640, 740], [1740, 738], [1847, 738], [1920, 735], [1920, 150]
  ],
  [
    [0, 534], [24, 533], [26, 547], [45, 550], [46, 567], [69, 565], [63, 582], [56, 595], 
[56, 607], [63, 616], [83, 622], [103, 623], [115, 623], [126, 621], [139, 613], [156, 607], 
[172, 784], [173, 832], [166, 859], [150, 892], [140, 913], [123, 930], [93, 947], [57, 970], 
[26, 989], [0, 1004]

  ],
  [
    [0, 357], [8, 357], [7, 274], [25, 272], [39, 272], [89, 280], [88, 232], [67, 214], 
[49, 210], [0, 200]

  ],
  [
    [75, 589], [98, 577], [122, 567], [148, 561], [157, 563], [154, 579], [150, 592], [134, 602], 
[125, 609], [105, 612], [87, 613], [77, 607], [70, 594]

  ]

    ],
    speedText: { x: 710, y: 1014, fontSize: 24, letterSpacing: 3, color: '#000000', fontWeight: '700' },
    
    needle: {
      img: "/static/photos/black_needle.png", // ë°”ëŠ˜ PNG ê²½ë¡œ
      width: 40, // SVG ì•ˆì—ì„œ ë°”ëŠ˜ í¬ê¸°
      height: 52.04,

      // cab.png ê¸°ì¤€ ê³„ê¸°íŒ ì¤‘ì‹¬ (ì„ì‹œ ê°’)
      cx: 698,
      cy: 964,

      // needle.png ì•ˆì—ì„œ ë°”ëŠ˜ ì¶• ìœ„ì¹˜ (ì„ì‹œ ê°’: ì´ë¯¸ì§€ ì¤‘ì•™)
      px: 7.511,
      py: 43.039,

      // íšŒì „ ë²”ìœ„ + í’€ìŠ¤ì¼€ì¼ ì†ë„
      minAngle: -161, // 0 km/hì¼ ë•Œ ê°ë„
      maxAngle: 95, // maxSpeedì¼ ë•Œ ê°ë„
      maxSpeed: 140 // ê³„ê¸°íŒ ëì†ë„
    },
  },
  e233: {
    src: "/static/photos/e233_cab.png", // TODO: ì‹¤ì œ ê²½ë¡œë¡œ ìˆ˜ì •
    size: { width: 1920, height: 1080 }, // TODO: PNG ì›ë³¸ í•´ìƒë„
    windowPoly: [[
[568, 674],
[1920, 674],
[1920, 153],
[539, 153],
[535, 106],
[474, 106],],
[
[0, 1005],
[90, 947],
[109, 922],
[122, 882],
[126, 799],
[115, 370],
[101, 322],
[84, 288],
[57, 259],
[0, 247],
]
    ],
    speedText: { x: 767, y: 1010, fontSize: 33, letterSpacing: 3 },
    
    needle: {
      img: "/static/photos/needle.png", // ë°”ëŠ˜ PNG ê²½ë¡œ
      width: 60, // SVG ì•ˆì—ì„œ ë°”ëŠ˜ í¬ê¸°
      height: 36.184,

      // cab.png ê¸°ì¤€ ê³„ê¸°íŒ ì¤‘ì‹¬ (ì„ì‹œ ê°’)
      cx: 745,
      cy: 959,

      // needle.png ì•ˆì—ì„œ ë°”ëŠ˜ ì¶• ìœ„ì¹˜ (ì„ì‹œ ê°’: ì´ë¯¸ì§€ ì¤‘ì•™)
      px: 50.2,
      py: 26.95,

      // íšŒì „ ë²”ìœ„ + í’€ìŠ¤ì¼€ì¼ ì†ë„
      minAngle: -54, // 0 km/hì¼ ë•Œ ê°ë„
      maxAngle: 187, // maxSpeedì¼ ë•Œ ê°ë„
      maxSpeed: 160 // ê³„ê¸°íŒ ëì†ë„
    },
  },
  n700s: {
    src: "/static/photos/n700s_cab.png",
    size: { width: 1880, height: 1040 },
    windowPoly: [
[
  [579, 0],
[770, 522],
[1203, 526],
[1605, 536],
[1880, 248],
[1880, 0]
  ],
  [
  [0, 543],
[137, 558],
[409, 573],
[530, 543],
[710, 528],
[470, 0],
[0, 0]
  ],
  [
[1690, 539],
 [1880, 376],
[1880, 550]
  ]

    ],
    speedText: { x: 897, y: 905, fontSize: 24, letterSpacing: 2 },
    maxSpeed: { 
      x: 905, 
      y: 797, 
      fontSize: 20, 
      fontWeight: "700",
      letterSpacing: 1,
      fill: "#698b40",
      textHeight: 200,
      textWidth: 120
    },
  },
  ktx: {
    src: "/static/photos/ktx_cab.png",
    size: { width: 1915, height: 993 },
    windowPoly: [
[247, 168],
[957, 101],
[1658, 172],
[1633, 210],
[1648, 212],
[1436, 538],
[584, 536],
[538, 540],
[480, 531],
[450, 511],
[258, 218],
[266, 210],
    ],
    speedText: { x: 865, y: 745, fontSize: 36, letterSpacing: 4 },
        needle: {
      img: "/static/photos/ktx_needle.png", // ë°”ëŠ˜ PNG ê²½ë¡œ
      width: 45, // SVG ì•ˆì—ì„œ ë°”ëŠ˜ í¬ê¸°
      height: 22,

      // cab.png ê¸°ì¤€ ê³„ê¸°íŒ ì¤‘ì‹¬ (ì„ì‹œ ê°’)
      cx: 836,
      cy: 675,

      // needle.png ì•ˆì—ì„œ ë°”ëŠ˜ ì¶• ìœ„ì¹˜ (ì„ì‹œ ê°’: ì´ë¯¸ì§€ ì¤‘ì•™)
      px: 35.29,
      py: 9.56,

      // íšŒì „ ë²”ìœ„ + í’€ìŠ¤ì¼€ì¼ ì†ë„
      minAngle: -25, // 0 km/hì¼ ë•Œ ê°ë„
      maxAngle: 235, // maxSpeedì¼ ë•Œ ê°ë„
      maxSpeed: 300 // ê³„ê¸°íŒ ëì†ë„
    },
  },
    ef510: {
    src: "/static/photos/ef510_cab.png",
    size: { width: 1920, height: 1080 },
    windowPoly: [[
[0, 805], [82, 1010], [122, 994], [168, 984], [275, 974], [349, 964],
[472, 951], [614, 937], [810, 931], [927, 925], [1078, 915], [1132, 909],
[1289, 777], [1372, 710], [1422, 670], [1445, 650], [1489, 616], [1555, 549],
[1563, 539], [1578, 541], [1598, 424], [1609, 400], [1632, 322], [1637, 290],
[1644, 289], [1644, 306], [1638, 324], [1600, 545], [1598, 551], [1644, 550],
[1654, 553], [1646, 561], [1637, 563], [1590, 601], [1567, 724], [1556, 796],
[1555, 813], [1549, 839], [1546, 824], [1545, 810], [1549, 804], [1549, 771],
[1553, 740], [1547, 727], [1562, 627], [1499, 679], [1496, 689], [1314, 843],
[1305, 850], [1245, 904], [1355, 902], [1367, 895], [1387, 884], [1416, 877],
[1465, 873], [1535, 876], [1589, 880], [1649, 883], [1682, 882], [1733, 883],
[1777, 881], [1825, 875], [1875, 870], [1918, 870], [1917, 46], [1155, 26],
[1042, 25], [1006, 25], [830, 21], [653, 16], [180, 7], [130, 5], [3, 1]],
[

[1554, 570], [1573, 586], [1569, 610], [1520, 652], [1496, 673],
[1489, 676], [1217, 904], [1214, 895], [1440, 674], [1446, 660],
[1489, 624], [1497, 616]

],
[
  [1599, 440], [1582, 541], [1590, 547], [1598, 515], [1603, 486]

],
[
  [1566, 624], [1554, 691], [1556, 700], [1567, 675], [1573, 647], [1576, 625]

],
[
  [1595, 559], [1620, 559], [1599, 581]

]

    ],
    speedText: { x: 865, y: 745, fontSize: 0, letterSpacing: 4 },
  },
  s3000: {
    src: "/static/photos/s3000_cab.png",
    size: { width: 4320, height: 2432 },
    
    windowPoly: [
[0, 1101], [76, 1092], [142, 1104], [205, 1140], [286, 1179], [340, 1203], [427, 1203], [523, 1194], [610, 1179], [967, 1176], [1186, 1176], [1657, 1170], [3277, 1161], [3340, 1158], [3397, 1131], [3442, 1098], [3508, 1050], [3586, 1032], [3697, 1023], [4320, 1092], [4320, 0], [0, 0]
    ],
    speedText: { x: 2250, y: 1680, fontSize: 50, letterSpacing: 4 },
  },

  e721: {
    src: "/static/photos/e721_cab.png",
    size: { width: 1890, height: 1080 },
    windowPoly: [
[
[542, 62],
[1275, 62],
[1268, 656],
[578, 656],
[565, 523],
[559, 406],
[548, 293],
[542, 185],
  ],
  [
[1546, 609],
[1547, 644],
[1625, 675],
[1646, 699],
[1651, 754],
[1886, 843],
[1886, 633],
[1733, 616],
[1733, 567],
[1655, 567],
[1642, 616],
  ]
    ],
    speedText: { x: 1890, y: 1081, fontSize: 0, letterSpacing: 2 },
    needle: {
      img: "/static/photos/analog_needle.png", // ë°”ëŠ˜ PNG ê²½ë¡œ
      width: 70, // SVG ì•ˆì—ì„œ ë°”ëŠ˜ í¬ê¸°
      height: 103,

      // cab.png ê¸°ì¤€ ê³„ê¸°íŒ ì¤‘ì‹¬ (ì„ì‹œ ê°’)
      cx: 623,
      cy: 985,

      // needle.png ì•ˆì—ì„œ ë°”ëŠ˜ ì¶• ìœ„ì¹˜ (ì„ì‹œ ê°’: ì´ë¯¸ì§€ ì¤‘ì•™)
      px: 31.27, //265
      py: 69.8, //593

      // íšŒì „ ë²”ìœ„ + í’€ìŠ¤ì¼€ì¼ ì†ë„
      minAngle: -148, // 0 km/hì¼ ë•Œ ê°ë„
      maxAngle: 100, // maxSpeedì¼ ë•Œ ê°ë„
      maxSpeed: 160 // ê³„ê¸°íŒ ëì†ë„
    },
  },
};

// vehicle JSON íŒŒì¼ ê²½ë¡œ â†’ ë ˆì´ì•„ì›ƒ key ë§¤í•‘
function getCabLayoutKeyFromVehicle(filePath) {
  const lower = (filePath || "").toLowerCase();
  if (lower.includes("n700s")) return "n700s";
  if (lower.includes("ktx1") || lower.includes("999")) return "ktx";
  if (lower.includes("e721")) return "e721";
  if (lower.includes("e233")) return "e233";
  if (lower.includes("e26")) return "ef510";
  if (lower.includes("s3000")) return "s3000";

  // í•„ìš”í•˜ë©´ EF510, ì„œìš¸ 3000 ë“±ë„ ì—¬ê¸°ì— else-ifë¡œ ì¶”ê°€
  return "default";
}

function buildCabOverlay(layoutKey) {
  // Store current layout key for later use (e.g., checking train type)
  window.__currentCabLayoutKey = layoutKey;
  
  const mount = document.getElementById("cab3d");
  if (!mount) {
    console.warn("buildCabOverlay: #cab3d not found");
    return;
  }

  // ê¸°ì¡´ ì˜¤ë²„ë ˆì´ ì œê±°
  let existing = document.getElementById("cabOverlayFull");
  if (existing) existing.remove();

  const config = CAB_LAYOUTS[layoutKey] || CAB_LAYOUTS.default;
  const { src, size, windowPoly, speedText, needle } = config;
  const CAB_W = size.width;
  const CAB_H = size.height;

  // ì˜¤ë²„ë ˆì´ ì»¨í…Œì´ë„ˆ
  const overlay = document.createElement("div");
  overlay.id = "cabOverlayFull";
  overlay.style.position = "absolute";
  overlay.style.inset = "0";
  overlay.style.pointerEvents = "none"; // í´ë¦­ì€ three.jsë¡œ
  mount.appendChild(overlay);

  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("viewBox", `0 0 ${CAB_W} ${CAB_H}`);
  svg.setAttribute("width", "100%");
  svg.setAttribute("height", "100%");
  svg.setAttribute("preserveAspectRatio", "xMidYMid slice");

  // === 1) cab ì°½ë¬¸ clipPath (ê¸°ì¡´ ì½”ë“œ ë³µì›) ===
  const defs = document.createElementNS(svgNS, "defs");
  const cp = document.createElementNS(svgNS, "clipPath");
  cp.setAttribute("id", "cabWindowClip");
  cp.setAttribute("clipPathUnits", "userSpaceOnUse");

  const path = document.createElementNS(svgNS, "path");

  // ì „ì²´ ì‚¬ê°í˜• + windowPolyë¡œ êµ¬ë© ëš«ê¸°
  let d = `M0 0 H${CAB_W} V${CAB_H} H0 Z `;

  let polygons = [];
  if (windowPoly && windowPoly.length > 0) {
    const isSinglePoly = typeof windowPoly[0][0] === "number";
    polygons = isSinglePoly ? [windowPoly] : windowPoly;
  }

  polygons.forEach(poly => {
    poly.forEach(([x, y], i) => {
      d += (i === 0 ? ` M${x} ${y}` : ` L${x} ${y}`);
    });
    d += " Z ";
  });

  path.setAttribute("d", d);
  path.setAttribute("fill", "black");
  path.setAttribute("fill-rule", "evenodd");
  path.setAttribute("clip-rule", "evenodd");

  cp.appendChild(path);
  defs.appendChild(cp);
  svg.appendChild(defs);

  // === 2) cab PNG ì´ë¯¸ì§€ ===
  const img = document.createElementNS(svgNS, "image");
  img.setAttributeNS("http://www.w3.org/1999/xlink", "href", src);
  img.setAttribute("x", "0");
  img.setAttribute("y", "0");
  img.setAttribute("width", CAB_W);
  img.setAttribute("height", CAB_H);
  img.setAttribute("clip-path", "url(#cabWindowClip)");
  svg.appendChild(img);

  // === 3) ì†ë„ ìˆ«ì í…ìŠ¤íŠ¸ ===
  const spCfg = speedText || {
    x: CAB_W / 2,
    y: CAB_H / 2,
    fontSize: 80,
    letterSpacing: 8,
  };
  const speedTextNode = document.createElementNS(svgNS, "text");
  speedTextNode.setAttribute("id", "svgSpeed");
  speedTextNode.setAttribute("x", spCfg.x);
  speedTextNode.setAttribute("y", spCfg.y);
  speedTextNode.setAttribute("text-anchor", "end");
  speedTextNode.setAttribute("fill", spCfg.color || "#eaffff");
  speedTextNode.setAttribute(
    "font-family",
    `'Orbitron', system-ui, sans-serif`
  );
  speedTextNode.setAttribute("font-size", spCfg.fontSize);
  speedTextNode.setAttribute("letter-spacing", spCfg.letterSpacing);
  speedTextNode.setAttribute("font-weight", spCfg.fontWeight || "700");
  speedTextNode.setAttribute("font-style", "italic");
  speedTextNode.textContent = "0";
  svg.appendChild(speedTextNode);

  // === 3.5) ìµœê³  ì†ë„ ìˆ«ì í…ìŠ¤íŠ¸ (n700së§Œ í‘œì‹œ) ===
  const maxSpeedConfig = CAB_LAYOUTS[layoutKey]?.maxSpeed;
  if (maxSpeedConfig) {
    const maxSpeedTextNode = document.createElementNS(svgNS, "text");
    maxSpeedTextNode.setAttribute("id", "svgMaxSpeed");
    maxSpeedTextNode.setAttribute("x", maxSpeedConfig.x);
    maxSpeedTextNode.setAttribute("y", maxSpeedConfig.y);
    maxSpeedTextNode.setAttribute("text-anchor", "end");
    maxSpeedTextNode.setAttribute("fill", maxSpeedConfig.fill || "#00ff00");
    maxSpeedTextNode.setAttribute(
      "font-family",
      `'Orbitron', system-ui, sans-serif`
    );
    maxSpeedTextNode.setAttribute("font-size", maxSpeedConfig.fontSize);
    maxSpeedTextNode.setAttribute("letter-spacing", maxSpeedConfig.letterSpacing);
    maxSpeedTextNode.setAttribute("font-weight", maxSpeedConfig.fontWeight || "700");
    maxSpeedTextNode.textContent = "â€”";
    svg.appendChild(maxSpeedTextNode);
    
    // ì „ì—­ì— ì €ì¥í•´ì„œ updateInstrumentHUDì—ì„œ ì“¸ ìˆ˜ ìˆê²Œ
    window.__svgMaxSpeedElem = maxSpeedTextNode;
    window.__svgMaxSpeedConfig = maxSpeedConfig;
  } else {
    window.__svgMaxSpeedElem = null;
    window.__svgMaxSpeedConfig = null;
  }

  // === 4) ì†ë„ê³„ ë°”ëŠ˜ (needle) ===
  if (needle) {
    const { img: nImg, width, height, cx, cy, px, py } = needle;

    const needleGroup = document.createElementNS(svgNS, "g");
    needleGroup.setAttribute("id", "svgSpeedNeedle");
    needleGroup.setAttribute("transform", `translate(${cx}, ${cy}) rotate(0)`);

    const needleImg = document.createElementNS(svgNS, "image");
    needleImg.setAttributeNS("http://www.w3.org/1999/xlink", "href", nImg);
    needleImg.setAttribute("width", width);
    needleImg.setAttribute("height", height);
    needleImg.setAttribute("x", -px);
    needleImg.setAttribute("y", -py);

    needleGroup.appendChild(needleImg);
    svg.appendChild(needleGroup);

    // ì „ì—­ì— ì €ì¥í•´ì„œ updateInstrumentHUDì—ì„œ ì“¸ ìˆ˜ ìˆê²Œ
    window.__svgNeedleElem = needleGroup;
    window.__svgNeedleConfig = needle;
  } else {
    window.__svgNeedleElem = null;
    window.__svgNeedleConfig = null;
  }

  // === 5) SVGë¥¼ overlayì— ë¶™ì´ê¸° ===
  overlay.appendChild(svg);
  // ----------------------------------------------------
  // ğŸ”½ KTX / N700S ì œì™¸í•˜ê³  mini brake ladderë¥¼ SVGë¡œ ê³ ì •
  // ----------------------------------------------------
  if (layoutKey !== "ktx" && layoutKey !== "n700s" && layoutKey !== "ef510" && layoutKey !== "s3000") {
    // í˜¹ì‹œ ì˜ˆì „ ìº”ë²„ìŠ¤ ë²„ì „ì´ ë‚¨ì•„ìˆë‹¤ë©´ ë¹„í™œì„±í™”
    window.drawMiniBrakeLadder = undefined;

    let ladderX = CAB_W - 1188; // ì˜¤ë¥¸ìª½ì—ì„œ ì‚´ì§ ì•ˆìª½
    let ladderY = CAB_H - 180; // ì•„ë˜ì—ì„œ ì¡°ê¸ˆ ìœ„
    let ladderW = 34;
    let ladderH = 125;

    if (vehicle.name.toLowerCase().includes("e233")) {
      // E233 ì°¨ëŸ‰ì¼ ê²½ìš° ë‹¤ë¥¸ ê°’ ì ìš©
      ladderX = CAB_W - 1396; // ì˜¤ë¥¸ìª½ì—ì„œ ì‚´ì§ ì•ˆìª½
      ladderY = CAB_H - 198; // ì•„ë˜ì—ì„œ ì¡°ê¸ˆ ìœ„
      ladderW = 34;
      ladderH = 131;
    }
        
    // ë°°ê²½ ë°•ìŠ¤
    const bg = document.createElementNS(svgNS, "rect");
    bg.setAttribute("x", ladderX);
    bg.setAttribute("y", ladderY);
    bg.setAttribute("width", ladderW);
    bg.setAttribute("height", ladderH);
    bg.setAttribute("rx", "4");
    bg.setAttribute("ry", "4");
    bg.setAttribute("fill", "rgba(0,0,0,0.40)");
    if (!vehicle.name.toLowerCase().includes("e233") && !vehicle.name.toLowerCase().includes("e235")) {
    svg.appendChild(bg);
    }
    

    // ë¸”ë¡/í…ìŠ¤íŠ¸ ê·¸ë£¹
    const ladderGroup = document.createElementNS(svgNS, "g");
    ladderGroup.setAttribute("id", "miniLadderSvg");
    svg.appendChild(ladderGroup);

    // notch ê°œìˆ˜ ê³„ì‚°
    const accArr = (window.vehicle && Array.isArray(window.vehicle.notch_accels))
      ? window.vehicle.notch_accels
      : null;
    const notches = accArr
      ? accArr.length
      : (window.vehicle && Number.isInteger(window.vehicle.notches)
          ? window.vehicle.notches
          : 10);

    const ebIdx = Math.max(1, vehicle.notches - 1); // EB ì¸ë±ìŠ¤
    const blocks = ebIdx;

    const pad = 4;
    const gap = 4;
    const bH = (ladderH - pad * 2 - gap * (blocks - 1)) / blocks;
    const bW = ladderW - pad * 2;
    const x = ladderX + pad;
    if (vehicle.name.toLowerCase().includes("e233")) {
      const rotateAngle = 3; // ì›í•˜ëŠ” ê°ë„ (ì˜ˆ: 10ë„)
      const centerX = ladderX + ladderW / 2; // íšŒì „ ì¤‘ì‹¬ X
      const centerY = ladderY + ladderH / 2; // íšŒì „ ì¤‘ì‹¬ Y

      // ladderGroupì— íšŒì „ transform ì¶”ê°€
      ladderGroup.setAttribute("transform", `rotate(${rotateAngle} ${centerX} ${centerY})`);
    }
    if (vehicle.name.toLowerCase().includes("e235")) {
      const skewAngle = -16; // ê¸°ìš¸ê¸° ê°ë„ (ë„)
      // skewXë¥¼ ì‚¬ìš©í•˜ë©´ ì¢Œìš° ë³€ë§Œ ê¸°ìš¸ì–´ì ¸ì„œ í‰í–‰ì‚¬ë³€í˜• í˜•íƒœê°€ ë¨
      ladderGroup.setAttribute("transform", `skewX(${skewAngle})`);
    }

    const normalBlocks = []; // B1~B(EB-1) ì‚¬ê°í˜•
    const normalTexts = []; // ê·¸ ìœ„ì— ì˜¬ë¼ê°ˆ ìˆ«ì í…ìŠ¤íŠ¸
    let ebBlock = null; // EB ì‚¬ê°í˜•
    let ebText = null; // EB í…ìŠ¤íŠ¸

    // --- B1 ~ B(EB-1) ---
    for (let k = 1; k <= ebIdx - 1; k++) {
      const i = k - 1;
      const y = ladderY + ladderH - pad - (i + 1) * bH - i * gap;

      const rect = document.createElementNS(svgNS, "rect");
      rect.setAttribute("x", x);
      rect.setAttribute("y", y);
      rect.setAttribute("width", bW);
      rect.setAttribute("height", bH);
      rect.setAttribute("fill", "rgba(60,80,100,0.35)");
      rect.setAttribute("stroke", "rgba(20,30,45,0.6)");
      rect.setAttribute("stroke-width", "1");
      rect.dataset.notch = String(k);
      ladderGroup.appendChild(rect);
      normalBlocks.push(rect);

      // ê°€ìš´ë° ìˆ«ì í…ìŠ¤íŠ¸ (ì²˜ìŒì—” ë¹„ì›Œë‘ )
      const txt = document.createElementNS(svgNS, "text");
      txt.setAttribute("x", x + bW / 2);
      txt.setAttribute("y", y + bH / 2 + 0.5); // ì‚´ì§ ì•„ë˜ë¡œ
      txt.setAttribute("text-anchor", "middle");
      txt.setAttribute("dominant-baseline", "middle");
      txt.setAttribute("font-family", "A-OTF Shin Go Pro, system-ui, sans-serif");
      txt.setAttribute("font-size", String(bH * 0.8));
      txt.setAttribute("font-weight", "700");
      txt.setAttribute("fill", "#000000");
      txt.setAttribute("opacity", "0"); // ê¸°ë³¸ì€ ì•ˆ ë³´ì´ê²Œ
      ladderGroup.appendChild(txt);
      normalTexts.push(txt);
    }

    // --- EB ë¸”ë¡ ---
    {
      const i = ebIdx - 1;
      const yEB = ladderY + ladderH - pad - (i + 1) * bH - i * gap;

      const rectEB = document.createElementNS(svgNS, "rect");
      rectEB.setAttribute("x", x);
      rectEB.setAttribute("y", yEB);
      rectEB.setAttribute("width", bW);
      rectEB.setAttribute("height", bH);
      rectEB.setAttribute("fill", "rgba(60,80,100,0.35)");
      rectEB.setAttribute("stroke", "rgba(20,30,45,0.6)");
      rectEB.setAttribute("stroke-width", "1.2");
      rectEB.dataset.notch = "EB";
      ladderGroup.appendChild(rectEB);
      ebBlock = rectEB;

      const tEB = document.createElementNS(svgNS, "text");
      tEB.setAttribute("x", x + bW / 2);
      tEB.setAttribute("y", yEB + bH / 2 + 0.5);
      tEB.setAttribute("text-anchor", "middle");
      tEB.setAttribute("dominant-baseline", "middle");
      tEB.setAttribute("font-family", "A-OTF Shin Go Pro, system-ui, sans-serif");
      tEB.setAttribute("font-size", String(bH * 0.8));
      tEB.setAttribute("font-weight", "700");
      tEB.setAttribute("fill", "#000000");
      tEB.setAttribute("opacity", "0");
      ladderGroup.appendChild(tEB);
      ebText = tEB;
    }

    //  ìƒíƒœì— ë”°ë¼ ìƒ‰/í…ìŠ¤íŠ¸ ê°±ì‹ í•˜ëŠ” í•¨ìˆ˜
    window.updateInstrumentLadder = function(st) {
      if (!st) return;
      const cur = Math.max(0, Math.min(ebIdx, st.lever_notch | 0));

      // 1) ì „ì²´ ì´ˆê¸°í™”: ë‹¤ íšŒìƒ‰, í…ìŠ¤íŠ¸ ìˆ¨ê¹€
      normalBlocks.forEach((rect, idx) => {
        rect.setAttribute("fill", "rgba(60,80,100,0.35)");
        rect.setAttribute("stroke", "rgba(20,30,45,0.6)");
        const txt = normalTexts[idx];
        txt.textContent = "";
        txt.setAttribute("opacity", "0");
      });

      if (ebBlock && ebText) {
        ebBlock.setAttribute("fill", "rgba(60,80,100,0.35)");
        ebBlock.setAttribute("stroke", "rgba(20,30,45,0.6)");
        ebText.textContent = "";
        ebText.setAttribute("opacity", "0");
      }

      // 2) ë ˆë²„ ìƒíƒœì— ë”°ë¼ ë‹¤ì‹œ ì¹ í•˜ê¸°
      // - cur == 0 or ìŒìˆ˜(ì—­í–‰) => ê·¸ëƒ¥ íšŒìƒ‰ ìœ ì§€
      // - 1..EB-1: ì•„ë˜ëŠ” ë…¸ë€ìƒ‰, ë§¨ ìœ„ ì¹¸ì—ë§Œ ìˆ«ì í‘œì‹œ
      // - EB: EB ì¹¸ ë¹¨ê°„ìƒ‰ + "EB" í…ìŠ¤íŠ¸
      if (cur > 0 && cur < ebIdx) {
        // ì„œë¹„ìŠ¤ ë¸Œë ˆì´í¬ êµ¬ê°„
        for (let k = 1; k <= ebIdx - 1; k++) {
          const idx = k - 1;
          const rect = normalBlocks[idx];
          // cur ì´í•˜ ì¹¸ì€ ë…¸ë€ìƒ‰
          if (k <= cur) {
            rect.setAttribute("fill", "#ffd34d");
            rect.setAttribute("stroke", "rgba(110,80,10,0.85)");
          }
          // ê°€ì¥ ìœ„ ì¹¸(k === cur)ì—ë§Œ ìˆ«ì í…ìŠ¤íŠ¸
          const txt = normalTexts[idx];
          if (k === cur) {
            txt.textContent = String(cur);
            txt.setAttribute("opacity", "1");
          } else {
            txt.textContent = "";
            txt.setAttribute("opacity", "0");
          }
        }
      } else if (cur === ebIdx && ebBlock && ebText) {
        // EB
        ebBlock.setAttribute("fill", "#ff5757");
        ebBlock.setAttribute("stroke", "#9b0000");
        ebText.textContent = "éå¸¸";
        ebText.setAttribute("opacity", "1");
      }
    };
  }
}


function updateInstrumentHUD({ speed, maxSpeed }) {
  const v = Number(speed ?? 0);

  // 1) ë””ì§€í„¸ ìˆ«ì
  const s = document.getElementById("svgSpeed");
  if (s) {
    s.textContent = String(Math.round(v));
  }

  // 1.5) ìµœê³  ì†ë„ í…ìŠ¤íŠ¸ (SVG)
  const maxSpeedElem = window.__svgMaxSpeedElem;
  if (maxSpeedElem) {
    if (maxSpeed !== null && typeof maxSpeed === 'number') {
      maxSpeedElem.textContent = String(Math.round(maxSpeed));
    } else {
      maxSpeedElem.textContent = "â€”";
    }
  }

  // 2) ì•„ë‚ ë¡œê·¸ ë°”ëŠ˜ íšŒì „
  const needleGroup = window.__svgNeedleElem;
  const cfg = window.__svgNeedleConfig;

  if (needleGroup && cfg) {
    const { minAngle, maxAngle, maxSpeed: cfgMaxSpeed, cx, cy } = cfg;

    const clamped = Math.max(0, Math.min(cfgMaxSpeed, v));
    const t = clamped / cfgMaxSpeed;
    const angle = minAngle + (maxAngle - minAngle) * t;

    needleGroup.setAttribute(
      "transform",
      `translate(${cx}, ${cy}) rotate(${angle})`
    );
  }
}
window.updateInstrumentHUD = updateInstrumentHUD;

const ws = new WebSocket((location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws");

// --- Low-speed noise: Web Audio ê¸°ë°˜ ë¶€ë“œëŸ¬ìš´ ë£¨í”„ + í˜ì´ë“œ ---
// ëª©í‘œ: ì†ë„ <= 10 km/h ì¼ ë•Œ ë£¨í”„ ì¬ìƒ, 10 km/h ë¶€ê·¼ì—ì„œ ë¶€ë“œëŸ½ê²Œ í˜ì´ë“œì•„ì›ƒ
const NOISE_PATH = '/static/E233/OriginalData/Sound/Noise.wav';
// ìµœëŒ€ ìŒëŸ‰: 1.0ì€ unity(ë¬´ì¦í­). ì‚¬ìš©ìê°€ ìš”ì²­ì— ë”°ë¼ í¬ê²Œ ì¦í­í•©ë‹ˆë‹¤.
// ì£¼ì˜: ê³¼ë„í•œ ì¦í­ì€ í´ë¦¬í•‘/ë””ìŠ¤í† ì…˜ì„ ìœ ë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
const MAX_VOL = 6.0;      // ì¦í­ê°’ â€” í•„ìš”í•˜ë©´ ë” ì¡°ì •í•˜ì„¸ìš”
const FADE_TIME = 2;   // ì´ˆ ë‹¨ìœ„ í˜ì´ë“œ ì‹œê°„
let lastSpeedKmh = 999;

// HTMLAudioElement + AudioContext(Gain)ë¥¼ ì‚¬ìš©í•´ ë³¼ë¥¨ì„ ë¯¸ì„¸ ì œì–´
const zeroNoiseEl = new Audio(NOISE_PATH);
zeroNoiseEl.loop = true;
zeroNoiseEl.preload = 'auto';
zeroNoiseEl.volume = 1.0;

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const gainNode = audioCtx.createGain();
gainNode.gain.value = 0.0; // ì´ˆê¸° ë¬´ìŒ
let sourceNode = null;
try {
  sourceNode = audioCtx.createMediaElementSource(zeroNoiseEl);
  sourceNode.connect(gainNode);
  gainNode.connect(audioCtx.destination);
} catch (e) {
  // ì¼ë¶€ í™˜ê²½/ë¸Œë¼ìš°ì €ì—ì„œëŠ” ì‹¤íŒ¨í•  ìˆ˜ ìˆìŒ; ê·¸ ê²½ìš°ì—ë„ zeroNoiseEl ì§ì ‘ ì œì–´ë¡œ í´ë°±
  console.debug('MediaElementSource unavailable, falling back to element playback.', e);
}

let zeroNoiseAllowed = false; // ì‚¬ìš©ìê°€ ëª…ì‹œì ìœ¼ë¡œ í—ˆìš©í–ˆëŠ”ì§€
let pauseAfterFadeTimeout = null;

// UI ë²„íŠ¼ ì—†ì´ ìë™ í—ˆìš©(ì‚¬ìš©ì ìƒí˜¸ì‘ìš© ë°”ì¸ë”©)ìœ¼ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.

function _enableZeroNoiseOnUserGesture() {
  zeroNoiseAllowed = true;
  // resume audio context (ë¸Œë¼ìš°ì €ì— ë”°ë¼ í•„ìš”)
  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume().catch(()=>{});
  }
  // try to play immediately if speed is low
  _updateNoiseForSpeed(lastSpeedKmh / 3.6);
}

function _setGainSmooth(targetVol) {
  try {
    const t0 = audioCtx.currentTime;
    gainNode.gain.cancelScheduledValues(t0);
    // ì‹œì‘ê°’ì„ í˜„ì¬ ê°’ìœ¼ë¡œ ê³ ì •
    gainNode.gain.setValueAtTime(gainNode.gain.value, t0);
    gainNode.gain.linearRampToValueAtTime(Math.max(0, Math.min(MAX_VOL, targetVol)), t0 + FADE_TIME);
  } catch (e) {
    // ignore if audioCtx not usable
  }
}

function _tryPlayZeroNoise() {
  if (!zeroNoiseAllowed) {
    // ì•„ì§ í—ˆìš©ë˜ì§€ ì•Šìœ¼ë©´ ì•„ë¬´ ë™ì‘ ì—†ì´ ë¦¬í„´
    return;
  }
  try {
    if (zeroNoiseEl.paused) {
      zeroNoiseEl.play().catch(()=>{});
    }
  } catch (e) {}
}

function _pauseAfterFade() {
  if (pauseAfterFadeTimeout) clearTimeout(pauseAfterFadeTimeout);
  pauseAfterFadeTimeout = setTimeout(() => {
    try { if (!zeroNoiseEl.paused) { zeroNoiseEl.pause(); zeroNoiseEl.currentTime = 0; } } catch (e) {}
  }, (FADE_TIME + 0.05) * 1000);
}

function _updateNoiseForSpeed(v_ms) {
  // v_ms: m/s
  lastSpeedKmh = v_ms * 3.6;
  const v_kmh = lastSpeedKmh;
  if (v_kmh == 0) {
    // 0..10km/h ì‚¬ì´ì—ì„œ ë³¼ë¥¨ ë¹„ë¡€ (10â†’0)
    const ratio = Math.max(0, Math.min(1, 1 - v_kmh / 10.0));
    const targetVol = MAX_VOL * ratio;
    _tryPlayZeroNoise();
    _setGainSmooth(targetVol);
    // clear any pending pause
    if (pauseAfterFadeTimeout) { clearTimeout(pauseAfterFadeTimeout); pauseAfterFadeTimeout = null; }
  } else {
    // above threshold â†’ fade to 0 and then pause
    _setGainSmooth(0.0);
    _pauseAfterFade();
  }
}

// ë©”ì‹œì§€ ìˆ˜ì‹ ì—ì„œ ìƒíƒœë¥¼ ë³´ê³  ì†ë„(v)ê°€ ì„ê³„ì¹˜ ì´í•˜ì´ë©´ ì¬ìƒ, ì•„ë‹ˆë©´ í˜ì´ë“œì•„ì›ƒ
ws.addEventListener('message', (ev) => {
  try {
    const msg = JSON.parse(ev.data);
    if (msg && msg.type === 'state' && msg.payload) {
      const v = Number(msg.payload.v) || 0; // m/s
      _updateNoiseForSpeed(v);
    }
  } catch (e) {
    // ignore invalid JSON or other parsing errors
  }
});

const icons = [
  "/static/logos/e233_logo.png",
  "/static/logos/n700s_icon.png",
  "/static/logos/500.png",
  "/static/logos/e7.png",
];
const randIcon = icons[Math.floor(Math.random() * icons.length)];
document.getElementById("trainIcon").src = randIcon;

ws.addEventListener('open', () => {
  //  ë³´ì •í‘œ(IDW) í•œ ë²ˆë§Œ ì„¸íŒ…í•˜ë©´ ì´í›„ ìë™ ì œí•œì‹œê°„ ì‚°ì¶œ
  ws.send(JSON.stringify({
    type: "cmd",
    payload: {
      name: "setTimerCalib",
      points: [
        { v: 40, L: 150, t: 35 },
        { v: 60, L: 200, t: 37 },
        { v: 70, L: 300, t: 40 },
        { v: 90, L: 500, t: 48 },
        { v: 130, L: 900, t: 57 }
      ],
      norm_v: 100,
      norm_L: 300,
      idw_power: 2.0,
      blend_threshold: 1.5
    }
  }));
  // íƒ€ì´ë¨¸ í™œì„±í™”
  ws.send(JSON.stringify({ type: "cmd", payload: { name: "toggleTimer", enabled: true } }));
});

const tascToggle = document.getElementById("tascToggle");
tascToggle.addEventListener("change", () => {
  const enabled = tascToggle.checked;
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "cmd", payload: { name: "setTASC", enabled } }));
  }
});
// function forceManualOverride(){
//   if (tascToggle.checked){
//     tascToggle.checked=false;
//     if (ws.readyState===WebSocket.OPEN){
//       ws.send(JSON.stringify({type:"cmd",payload:{name:"setTASC",enabled:false}}));
//     }
//   }
// }

/* ===== ë‚ ì”¨ ì´í™íŠ¸ ===== */
const snowflakesContainer=document.querySelector('.snowflakes');
function generateSnowflake(){
  // avoid creating snowflakes when not visible or disabled to reduce DOM churn
  if (!snowflakesContainer) return;
  if (snowflakesContainer.style.display !== 'block') return;
  if (document.visibilityState !== 'visible') return;
  // cap active flakes to avoid unbounded DOM growth
  if (snowflakesContainer.children.length > 30) return;

  const s = document.createElement('div');
  s.style.animationDelay = (Math.random() * 2) + 's';
  s.style.animationDuration = (Math.random() * 5 + 5) + 's';
  s.style.left = Math.floor(Math.random() * 101) + '%';
  s.style.position = 'absolute';
  s.style.top = '-10px';
  s.style.width = '10px';
  s.style.height = '10px';
  s.style.backgroundColor = 'rgba(255,255,255,.8)';
  s.style.borderRadius = '50%';
  snowflakesContainer.appendChild(s);
  setTimeout(() => { try { if (s.parentNode) snowflakesContainer.removeChild(s); } catch (e) {} }, 7000);
}
// throttle snow generation to reduce CPU/DOM pressure
setInterval(generateSnowflake, 400);

/* ===== Haptics (ëª¨ë°”ì¼) ===== */
const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
function canVibrate() { return isMobile && typeof navigator.vibrate === "function" && document.visibilityState === "visible"; }
function vibrate(pattern) { if (!canVibrate()) return false; return navigator.vibrate(pattern) !== false; }
function hapticForNotch(delta) { if (delta !== 0) vibrate([80, 10, 80]); }
function hapticForEB() { vibrate([80, 100, 80]); }

/* ===== ì°¨ëŸ‰ JSON ë¡œë“œ (ìºì‹œ ë¬´ì‹œ) ===== */
let vehicle=null; let brakeDecels={};
const cacheBust=()=>`?v=${Date.now()}`;
// fetch('/static/e233_1000.json'+cacheBust(),{cache:'no-store'})
//   .then(r=>r.json()).then(data=>{
//     vehicle=data; document.getElementById('carName').textContent=vehicle.name;
//     if(vehicle.notch_accels && vehicle.notches){
//       brakeDecels={}; for(let i=0;i<vehicle.notches;i++){ brakeDecels[i]=Math.abs(vehicle.notch_accels[vehicle.notches-1-i]??0); }
//     }
//   }).catch(console.error);

/* ===== DOM ===== */
const remEl=document.getElementById("rem"),
      spdEl=document.getElementById("spd"),
      notchEl=document.getElementById("notch"),
      fb=document.getElementById("fb"),
      timerEl=document.getElementById("timer");

// ğŸ”¹ mini HUD ìš”ì†Œ
const miniTimer = document.getElementById("miniTimer"),
      miniSpeed = document.getElementById("miniSpeed"),
  miniRemain = document.getElementById("miniRemain"),
  miniClock = document.getElementById("miniClock"),
      miniGrade = document.getElementById("miniGrade"),
      miniNotch = document.getElementById("miniNotch"),
      miniNext = document.getElementById("miniNext"),
      miniMaxSpeed = document.getElementById("miniMaxSpeed");
      miniTitle = document.getElementById("miniHudTitle");
const overlay=document.getElementById("overlay"),
      btnStart=document.getElementById("btnStart"),
      canvas=document.getElementById("hud"),
      ctx=canvas.getContext("2d");

(() => {
  const mount = document.getElementById('cab3d');
  const modeSel = document.getElementById('syncMode');
  const cabCard = document.getElementById('cabCard');

  // ON/OFF â†’ 3D í‘œì‹œ/ìˆ¨ê¹€
  function applyCabToggle(){
    const on = (modeSel?.value === 'on');
    cabCard.style.display = on ? 'block' : 'none';
  }
  modeSel?.addEventListener('change', applyCabToggle);
  applyCabToggle();

  // --- Three.js ê¸°ë³¸ ---
const scene = new THREE.Scene();

  let timeOfDay = "day";
  let daySkyTex, nightSkyTex;

  const platformLights = [];
  const platformPillars = []; // ğŸ‘ˆ ìƒˆë¡œ ì¶”ê°€
  let platformRoof = null; // ğŸ‘ˆ ì§€ë¶• Mesh ì €ì¥ìš©


  function createSkyTexture(isDay) {
    const cw = 1024, ch = 512;
    const cvs = document.createElement('canvas'); 
    cvs.width = cw; 
    cvs.height = ch;
    const cx = cvs.getContext('2d');

    if (isDay) {
      // â˜€ ì£¼ê°„ í•˜ëŠ˜
      const g = cx.createLinearGradient(0,0,0,ch);
      g.addColorStop(0, '#7fb7ff');
      g.addColorStop(0.5, '#9dd1ff');
      g.addColorStop(1, '#16304a');
      cx.fillStyle = g;
      cx.fillRect(0,0,cw,ch);

      const sx = Math.floor(cw*0.85), sy = Math.floor(ch*0.18);
      const rg = cx.createRadialGradient(sx, sy, 10, sx, sy, 220);
      rg.addColorStop(0, 'rgba(255,250,220,0.85)');
      rg.addColorStop(0.2, 'rgba(255,240,200,0.25)');
      rg.addColorStop(1, 'rgba(255,240,200,0)');
      cx.fillStyle = rg; 
      cx.fillRect(0,0,cw,ch);
    } else {
      // ğŸŒ™ ì•¼ê°„ í•˜ëŠ˜
      const g = cx.createLinearGradient(0,0,0,ch);
      g.addColorStop(0, '#050713');
      g.addColorStop(0.4, '#040716');
      g.addColorStop(1, '#000000');
      cx.fillStyle = g;
      cx.fillRect(0,0,cw,ch);

      // ê°€ë²¼ìš´ ë³„ë“¤
      cx.fillStyle = 'rgba(255,255,255,0.9)';
      for (let i = 0; i < 120; i++) {
        const x = Math.random() * cw;
        const y = Math.random() * ch * 0.6;
        const r = Math.random() * 1.5 + 0.3;
        cx.beginPath();
        cx.arc(x, y, r, 0, Math.PI*2);
        cx.fill();
      }
    }

    const tex = new THREE.CanvasTexture(cvs);
    tex.encoding = THREE.sRGBEncoding;
    return tex;
  }

  daySkyTex = createSkyTexture(true);
  nightSkyTex = createSkyTexture(false);
  scene.background = daySkyTex;

  // use actual mount size for correct aspect ratio so canvas fills its container
  const initialW = mount.clientWidth || Math.max(800, window.innerWidth);
  const initialH = mount.clientHeight || Math.max(450, Math.round(initialW * 9/16));
 const camera = new THREE.PerspectiveCamera(
  45,           // FOV (Field of View): 45ë„ (ìì—°ìŠ¤ëŸ¬ìš´ ì‹œì•¼, ì „ë°©ê³¼ ì£¼ë³€ì„ ì˜ ë³¼ ìˆ˜ ìˆë„ë¡ ì„¤ì •)
  initialW / initialH, // ì¢…íš¡ë¹„ (í™”ë©´ì˜ ë„ˆë¹„ì™€ ë†’ì´ ë¹„ìœ¨)
  0.1,          // Near plane: 0.1 (ì¹´ë©”ë¼ê°€ ë³¼ ìˆ˜ ìˆëŠ” ê°€ì¥ ê°€ê¹Œìš´ ê±°ë¦¬)
  1000          // Far plane: 300 (ì¹´ë©”ë¼ê°€ ë³¼ ìˆ˜ ìˆëŠ” ê°€ì¥ ë¨¼ ê±°ë¦¬, ì „ì²  ì‹œë®¬ì—ì„œëŠ” ì¶©ë¶„íˆ ë¨¼ ê±°ë¦¬)
);

  
// ğŸš‚ ê¸°ê´€ì‚¬ ì‹œì  í—¤ë“œë¼ì´íŠ¸ (ì¹´ë©”ë¼ì— ë¶™ëŠ” ìŠ¤í¬íŠ¸ë¼ì´íŠ¸)
  const headlight = new THREE.SpotLight(0xffffff, 0);
  headlight.angle = Math.PI / 5; // ë¹” ê°ë„
  headlight.distance = 120; // ë¹„ì¶”ëŠ” ë²”ìœ„
  headlight.penumbra = 0.7;
  headlight.decay = 2;
  headlight.castShadow = false;

  // ì¹´ë©”ë¼ ê¸°ì¤€ ì•ìª½ìœ¼ë¡œ í–¥í•˜ê²Œ
  headlight.target.position.set(0, -0.05, -1.0);
  
  const headlightTarget = new THREE.Object3D();
  headlightTarget.position.set(0, -0.1, -1.0);
  camera.add(headlight);
  camera.add(headlightTarget);
  headlight.position.set(0, 0, 0);
  headlight.target = headlightTarget;
  scene.add(camera); // ì¹´ë©”ë¼ë„ ì”¬ì— ë„£ì–´ì¤˜ì•¼ ìì‹ ë¼ì´íŠ¸ê°€ ì ìš©ë¨

  // const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
  const renderer = new THREE.WebGLRenderer({
  antialias: true, // ì €ì‚¬ì–‘ì—ì„œ í° íš¨ê³¼
  alpha: false,
  depth: true,
  stencil: false, // ìŠ¤í…ì‹¤ ë„ê¸°
  powerPreference: "high-performance", // ê³ ì„±ëŠ¥ GPU ìš°ì„ 
  failIfMajorPerformanceCaveat: false
});

  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.setPixelRatio(1);
  mount.appendChild(renderer.domElement);
  // runtime-adjustable target DPR for the auto-scaler (initialized to current setting)
  let targetDPR = renderer.getPixelRatio();





  function resize(){
    // If a runtime-forced fixed size exists, use it (we lock size without changing UI)
    try {
      const forced = window.__cab3d_forced_fixed;
      if (forced && Number.isFinite(forced.width) && Number.isFinite(forced.height)) {
        const w = Math.max(16, mount.clientWidth || window.innerWidth);
    const h = Math.max(16, mount.clientHeight || Math.round(w * 9/16));
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h, false);
    // ensure DOM canvas uses full container size (avoid CSS pixel mismatch)
    renderer.domElement.style.width = '100%';
    renderer.domElement.style.height = '100%';
        return;
      }
      // Backwards-compatible: also respect explicit CSS class if present
      const cabCardEl = document.getElementById('cabCard');
      const isFixed = cabCardEl && cabCardEl.classList.contains('fixed-3d');
      if (isFixed) {
        const cs = getComputedStyle(cabCardEl);
        const w = Math.max(16, Math.round(parseFloat(cs.width) || 800));
        const h = Math.max(16, Math.round(parseFloat(cs.height) || 450));
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h, false);
        renderer.domElement.style.width = w + 'px';
        renderer.domElement.style.height = h + 'px';
        return;
      }
    } catch (e) {
      // fall back to responsive behavior below
    }

    // match renderer/camera to the mount element's actual layout size so the 3D view fills it
    const w = Math.max(16, mount.clientWidth || window.innerWidth);
    const h = Math.max(16, mount.clientHeight || Math.round(w * 9/16));
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h, false);
    // ensure DOM canvas uses full container size (avoid CSS pixel mismatch)
    renderer.domElement.style.width = '100%';
    renderer.domElement.style.height = '100%';
  }
  addEventListener('resize', resize);
  // also observe mount size changes in case layout changes without window resize
  const ro = new ResizeObserver(()=> resize());
  ro.observe(mount);
  resize();

  // --- ë¼ì´íŠ¸: ìì—°ê´‘ + ì†Œí”„íŠ¸ ì„€ë„ìš° (í–‡ë¹› ëŠë‚Œ) ---
  // hemisphere: í•˜ëŠ˜/ì§€ë©´ ìƒ‰ìƒìœ¼ë¡œ ì „ì²´ fillì„ ë¶€ë“œëŸ½ê²Œ í•´ì¤Œ
  // const hemi = new THREE.HemisphereLight(0xbfdfff, 0x403020, 0.9);
  // scene.add(hemi);

  // directional: íƒœì–‘ê´‘. ì„€ë„ìš°ë¥¼ í™œì„±í™”í•´ì„œ í˜„ì‹¤ê°ì„ ë†’ì¸ë‹¤.
  const dir = new THREE.DirectionalLight(0xfff6e6, 1.0);
  dir.position.set(6, 20, 10);
  dir.castShadow = false;
  dir.shadow.mapSize.width = 1024;
  dir.shadow.mapSize.height = 1024;
  dir.shadow.camera.left = -40;
  dir.shadow.camera.right = 40;
  dir.shadow.camera.top = 40;
  dir.shadow.camera.bottom = -40;
  dir.shadow.camera.near = 1;
  dir.shadow.camera.far = 200;
  dir.shadow.radius = 4;
  scene.add(dir);

  // renderer: ì„€ë„ìš° ì‚¬ìš©
  renderer.shadowMap.enabled = false;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

// ê°„ë‹¨í•œ ë™ì  ìŠ¤ì¼€ì¼ëŸ¬
let lastFpsCheck = performance.now();
let frames = 0;

  // --- í…ìŠ¤ì²˜ ë¡œë” ---
  const texLoader = new THREE.TextureLoader();

// =======================
// ğŸ‘¤ ì‚¬ëŒ í…ìŠ¤ì²˜ ì—¬ëŸ¬ ê°œ ë¡œë”©
// =======================
const personTextureFiles = [
  "/static/textures/person01.png",
  "/static/textures/1000010896.png",
  "/static/textures/1000010897.png",
  "/static/textures/1000010898.png",
  "/static/textures/1000010899.png",
  "/static/textures/1000010900.png",
  "/static/textures/1000010901.png",
  "/static/textures/1000010902.png",
  "/static/textures/1000010903.png",
  "/static/textures/1000010904.png",
  "/static/textures/1000010905.png",
  "/static/textures/1000010907.png",
  "/static/textures/1000010908.png",
  "/static/textures/1000010914.png",
  "/static/textures/1000010917.png",
  "/static/textures/1000010918.png",
  "/static/textures/1000010911.png",
  "/static/textures/1000010995.png",
  "/static/textures/1000010996.png",
  "/static/textures/1000010997.png",
  "/static/textures/1000010998.png",
  "/static/textures/1000011008.png",
  "/static/textures/1000011009.png",
  "/static/textures/1000011010.png",
  "/static/textures/1000011011.png",
  "/static/textures/1000011012.png",
  "/static/textures/1000011013.png",
  "/static/textures/1000011014.png",
  "/static/textures/1000011016.png",
]

// PNG â†’ Texture
const personTextures = personTextureFiles.map(path => {
  const tex = texLoader.load(path);
  tex.colorSpace = THREE.SRGBColorSpace; // three r160 ê¸°ì¤€
  tex.transparent = true;
  tex.magFilter = THREE.LinearFilter;
  tex.minFilter = THREE.LinearMipMapLinearFilter;
  return tex;
});

// Texture â†’ Material
const personMaterials = personTextures.map(tex => new THREE.MeshBasicMaterial({
  map: tex,
  transparent: true,
  depthWrite: false, // í”Œë«í¼ ë’¤ë‘ ì˜ ì„ì´ê²Œ
  side: THREE.DoubleSide // í˜¹ì‹œ ë’·ë©´ë§Œ ë³´ì´ëŠ” ìƒí™© ë°©ì§€
}));



// ì‚¬ëŒ í•œ ëª… ê¸°ì¤€ ë†’ì´(1.7m)ì§œë¦¬ Plane
const personHeight = 1.7;
const personWidth = 0.45; // ë¹„ìœ¨ì€ PNGì— ë§ê²Œ ì¡°ì •
const personGeo = new THREE.PlaneGeometry(personWidth, personHeight);


// --- ë¹„ìƒ ì¥ì• ë¬¼(ë°”ìœ„/ë¶ˆ) ê´€ë¦¬ìš© --- 
let emergencyObstacle = null; // ë©”ì‰¬(ë°”ìœ„ ë˜ëŠ” ë¶ˆ)
let emergencyObstacleLight = null; // ë¶ˆì¼ ë•Œë§Œ ì“°ëŠ” í¬ì¸íŠ¸ ë¼ì´íŠ¸

// í•„ìš”í•˜ë©´ í…ìŠ¤ì²˜ ì‚¬ìš© (ì—†ìœ¼ë©´ ì¼ë‹¨ ì£¼ì„ë§Œ ë‘ê³  ë‹¨ìƒ‰ìœ¼ë¡œë„ ê°€ëŠ¥)
const fireTex = texLoader.load("/static/textures/fall.png");
fireTex.colorSpace = THREE.SRGBColorSpace; // ìµœì‹  three.js ë°©ì‹
fireTex.transparent = true;

function clearEmergencyObstacle() {
  if (emergencyObstacle) {
    scene.remove(emergencyObstacle);
    if (emergencyObstacle.geometry) emergencyObstacle.geometry.dispose();
    emergencyObstacle = null;
  }
  if (emergencyObstacleLight) {
    scene.remove(emergencyObstacleLight);
    emergencyObstacleLight = null;
  }

// ğŸ”„ ì¥ì• ë¬¼ ìƒíƒœ ì´ˆê¸°í™”
  resetHazardState();
}


function maybeSpawnEmergencyObstacle(initialDist) {
  // ì´ì „ ì¥ì• ë¬¼ ê¹¨ë—ì´ ì •ë¦¬
  clearEmergencyObstacle();

  // ì¡°ê±´ ë¶€ì¡±í•˜ë©´ ìƒì„± ì•ˆ í•¨
  if (!initialDist || initialDist <= 20) return;

  // if (Math.random() > 0.001) return;
  if (true) return;

  // 140m ~ 210m ì‚¬ì´ì—ì„œë§Œ ì¥ì• ë¬¼ ìœ„ì¹˜ ì„ íƒ
  const minRange = 140;
  const maxRange = 210;

  // ì‹¤ì œ ê°€ëŠ¥í•œ ìµœëŒ€ ê±°ë¦¬ (ì´ˆê¸° ë‚¨ì€ê±°ë¦¬ë³´ë‹¤ í´ ìˆ˜ ì—†ìŒ)
  const usableMax = Math.min(initialDist, maxRange);
  if (usableMax <= minRange) return;

  // hazardDist: ì •ì°¨ ìœ„ì¹˜ê¹Œì§€ì˜ ë‚¨ì€ ê±°ë¦¬(remaining_m) ê¸°ì¤€ ì¥ì• ë¬¼ ì¢Œí‘œ
  const hazardDist = minRange + Math.random() * (usableMax - minRange);

  // zì¢Œí‘œ ë³€í™˜: remaining_m â†’ zWorld
  const zWorld = 200 - hazardDist;
  const xTrack = 0; // ì¤‘ì•™ ì„ ë¡œ ê¸°ì¤€

  // ğŸ§  ìƒíƒœ ì €ì¥ (ì´ê±¸ë¡œ ws stateì—ì„œ íŒì •)
  hazardInfo.active = true;
  hazardInfo.dist = hazardDist;
  hazardInfo.handled = false;
  hazardInfo.timeoutId = null;
  //  ì„œë²„ì— ì¥ì• ë¬¼ ìœ„ì¹˜ ì•Œë ¤ì£¼ê¸°
if (ws.readyState === WebSocket.OPEN) {
  ws.send(JSON.stringify({
    type: "cmd",
    payload: { name: "setHazard", dist: hazardDist }
  }));
}


  // í…ìŠ¤ì²˜ ëª©ë¡ ì¤‘ í•˜ë‚˜ ëœë¤
  const texturePaths = [
    "/static/textures/fall.png",
    "/static/textures/fall_woman.png",
    "/static/textures/rock.png",
    "/static/textures/fire.png",
    "/static/textures/fire2.png",
  ];
  const randomPath = texturePaths[Math.floor(Math.random() * texturePaths.length)];
  const tex = texLoader.load(randomPath);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.transparent = true;

  // ì¥ì• ë¬¼ ë©”ì‰¬ ìƒì„± (ì¹´ë©”ë¼ ë°”ë¼ë³´ëŠ” billboard)
  const geo = new THREE.PlaneGeometry(1.7, 1.7);
  const mat = new THREE.MeshBasicMaterial({
    map: tex,
    transparent: true,
    depthWrite: false
  });
  const mesh = new THREE.Mesh(geo, mat);

  // ì¢Œìš°ë¡œ ì‚´ì§ ëœë¤ ì˜¤í”„ì…‹ ì¤˜ì„œ ë„ˆë¬´ ì •ì¤‘ì•™ë§Œ ë‚˜ì˜¤ì§€ ì•Šê²Œ
  const offsetX = (Math.random() * 2 - 1); // -1 ~ +1
  mesh.position.set(xTrack + offsetX, 0.9, zWorld);

  mesh.userData.type = "hazard";
  mesh.userData.billboard = true;

  emergencyObstacle = mesh;
  scene.add(mesh);
}

// startRun()ì—ì„œ í˜¸ì¶œí•  ìˆ˜ ìˆë„ë¡ ì „ì—­ì— ë…¸ì¶œ
window.maybeSpawnEmergencyObstacle = maybeSpawnEmergencyObstacle;
window.clearEmergencyObstacle = clearEmergencyObstacle;

// --- ì§€ë°˜(ì½˜í¬ë¦¬íŠ¸ ë‹¨ìƒ‰) ---
const groundMat = new THREE.MeshStandardMaterial({
  color: 0x8d8d8d,   // ë°ì€ íšŒìƒ‰ (ì½˜í¬ë¦¬íŠ¸ ëŠë‚Œ)
  roughness: 0.95,   // í‘œë©´ ê±°ì¹ ê¸° ë†’ê²Œ
  metalness: 0.0     // ê¸ˆì†ì„± ì—†ìŒ
});

const ground = new THREE.Mesh(new THREE.PlaneGeometry(20, 120000, 1, 1), groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.2;
//ì§„ì§œ ë•…
ground.position.z = 200;
ground.receiveShadow = false;
ground.castShadow = false;
scene.add(ground);

  // --- íŠ¸ë™ í…ìŠ¤ì²˜(ì¹¨ëª©+ë ˆì¼ì„ í•˜ë‚˜ì˜ í…ìŠ¤ì²˜ë¡œ í•©ì³ì„œ ì²˜ë¦¬) ---
function createTrackCanvasTexture() {
  const tileW = 1024, tileH = 256;
  const cvs = document.createElement('canvas'); 
  cvs.width = tileW; 
  cvs.height = tileH;
  const c = cvs.getContext('2d');

  // background: ballast-ish
  c.fillStyle = '#6b6b5f';
  c.fillRect(0, 0, tileW, tileH);

    // draw two metallic rails centered
    const railCenterX = tileW/2;
    const railOffset = 120; // pixel offset from center
    // function drawRail(cx){
    //   // base dark strip
    //   // c.fillStyle = '#2a2a2a';
    //   // c.fillRect(cx-6, tileH*0.2, 12, tileH*0.6);
    //   // highlight
    //   const grad = c.createLinearGradient(cx-6,0,cx+6,0);
    //   grad.addColorStop(0, 'rgba(255,255,255,0.10)');
    //   grad.addColorStop(0.5, 'rgba(255,255,255,0.35)');
    //   grad.addColorStop(1, 'rgba(255,255,255,0.10)');
    //   c.fillStyle = grad;
    //   c.fillRect(cx-2, tileH*0.25, 4, tileH*0.5);
    // }
    // drawRail(railCenterX - railOffset);
    // drawRail(railCenterX + railOffset);

    // subtle grime overlay
    c.fillStyle = 'rgba(10,10,12,0.05)';
    c.fillRect(0,0,tileW,tileH);

    const tex = new THREE.CanvasTexture(cvs);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(1, 40);
    const MAX_ANISO = Math.min(4, renderer.capabilities.getMaxAnisotropy());
    tex.anisotropy = MAX_ANISO;
    tex.encoding = THREE.sRGBEncoding;
    return tex;
  }

  const trackTex = createTrackCanvasTexture();

  // track plane: a narrow strip representing sleepers+ballast; rails will still have metallic highlights
  const trackMat = new THREE.MeshStandardMaterial({ map: trackTex, roughness: 0.85, metalness: 0.05 });
  const trackWidth = 2.5;
  const trackLen = 120000;
  const trackGeo = new THREE.PlaneGeometry(trackWidth, trackLen, 1, 1);
  const track = new THREE.Mesh(trackGeo, trackMat);
  track.rotation.x = -Math.PI/2;
  track.position.y = 0.01;
  track.position.z = 200;
  track.receiveShadow = false;
  scene.add(track);

  const track2 = new THREE.Mesh(trackGeo, trackMat);
  track2.position.set(4, 0.01, 200);
  track2.rotation.x = -Math.PI/2;
  track2.position.y = 0.01;
  track2.position.z = 200;
  track2.receiveShadow = false;
  scene.add(track2);

  // const track3 = new THREE.Mesh(trackGeo, trackMat);
  // track3.position.set(-6.5, 0.01, 200);
  // track3.rotation.x = -Math.PI/2;
  // track3.position.y = 0.01;
  // track3.position.z = 200;
  // track3.receiveShadow = false;
  // scene.add(track3);

  // rails (thin metallic extrusions) on top of the track plane for specular highlights and correct shading
  const railMat = new THREE.MeshStandardMaterial({ color:0xe0e5e5, metalness:0.95, roughness:0.28 });
  const railH = 0.14, railW = 0.045, railLen = 120000;
  const railGeo = new THREE.BoxGeometry(railW, railH, railLen);
  const railL = new THREE.Mesh(railGeo, railMat);
  const railR = new THREE.Mesh(railGeo, railMat);
  const s = 0.5335; // narrow gauge ê¸°ì¤€ ë ˆì¼ ê°„ê²© ì ˆë°˜
  railL.position.set(-s, railH/2 + 0.1, 200); //ì§€ìƒìœ¼ë¡œ ë¶€í„° 10cm ë„ì›Œì„œ í…ìŠ¤ì²˜ì˜ ê²¹ì¹¨í˜„ìƒ ë°©ì§€
  railR.position.set( s, railH/2 + 0.1, 200);
  railL.castShadow = false; railL.receiveShadow = false;
  railR.castShadow = false; railR.receiveShadow = false;
  scene.add(railL, railR);
  
  const railL2 = new THREE.Mesh(railGeo, railMat);
  const railR2 = new THREE.Mesh(railGeo, railMat);
  railL2.position.set(-s+4, railH/2 + 0.1, 200);
  railR2.position.set( s+4, railH/2 + 0.1, 200);
  railL2.castShadow = false; railL2.receiveShadow = false;
  railR2.castShadow = false; railR2.receiveShadow = false;
  scene.add(railL2, railR2);

  // const railL3 = new THREE.Mesh(railGeo, railMat);
  // const railR3 = new THREE.Mesh(railGeo, railMat);
  // railL3.position.set(-0.535-6.5, railH/2 + 0.01, 200);
  // railR3.position.set( 0.535-6.5, railH/2 + 0.01, 200);
  // railL3.castShadow = false; railL3.receiveShadow = false;
  // railR3.castShadow = false; railR3.receiveShadow = false;
  // scene.add(railL3, railR3);

//   // --- ì¹¨ëª©(InstancedMesh) ---
//   const sleeperMat = new THREE.MeshStandardMaterial({
//     map: loadTex(TX.sleeper, {aniso:true, repeat:{x:1, y:1}}),
//     roughness: 0.9, metalness: 0.0
//   });
//   const sleeperGeo = new THREE.BoxGeometry(2.0, 0.08, 0.22); // ê¸¸ì´xë†’ì´xë‘ê»˜(ê°€ì‹œì )
//   const sleeperCount = 2000; // 0.5~0.6m ê°„ê²©ìœ¼ë¡œ 400m
//   const sleepers = new THREE.InstancedMesh(sleeperGeo, sleeperMat, sleeperCount);
//   sleepers.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
//   scene.add(sleepers);
//   const pitch = 0.65;
//   for (let i=0;i<sleeperCount;i++){
//   const z = 200 - i*pitch; // z âˆˆ [200, 200-1000]
//   if (z < -300) break; // -300mê¹Œì§€ë§Œ ë°°ì¹˜í•˜ë©´ ì¶©ë¶„
//   const m = new THREE.Matrix4().makeTranslation(0, 0.02, z);
//   sleepers.setMatrixAt(i, m);
// }


// === ê°€ì„¤ ì „ì°¨ì„  ì „ë´‡ëŒ€ + ì „ì„  ì¶”ê°€ ===
  // âš  PNG íŒŒì¼ ê²½ë¡œëŠ” ë„¤ê°€ ê°€ì§„ ì‹¤ì œ íŒŒì¼ëª…ìœ¼ë¡œ ê³ ì³ ì¨ì¤˜!
  const leftPoleTex = texLoader.load("/static/textures/pole_left.png");
  const rightPoleTex = texLoader.load("/static/textures/pole_right.png");

  [leftPoleTex, rightPoleTex].forEach(tex => {
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.transparent = true;
    tex.magFilter = THREE.LinearFilter;
    tex.minFilter = THREE.LinearMipMapLinearFilter;
  });

  const poleHeight = 5.5; // ì „ë´‡ëŒ€ ë†’ì´ 5m
  const poleWidth = 2.7; // ì „ë´‡ëŒ€ ë‘ê»˜(í™”ë©´ìƒ í­)

  const poleGeo = new THREE.PlaneGeometry(poleWidth, poleHeight);
  const leftPoleMat = new THREE.MeshBasicMaterial({
    map: leftPoleTex,
    transparent: true,
    side: THREE.DoubleSide
  });
  const rightPoleMat = new THREE.MeshBasicMaterial({
    map: rightPoleTex,
    transparent: true,
    side: THREE.DoubleSide
  });

  // ì„ ë¡œ ê¸°ì¤€ x ìœ„ì¹˜ (ì™¼ìª½/ì˜¤ë¥¸ìª½ ë°”ê¹¥ìª½ì— ì„¸ì›€)
  // ê°€ìš´ë° ì„ ë¡œê°€ xâ‰ˆ0, ì˜¤ë¥¸ìª½ ì„ ë¡œê°€ xâ‰ˆ4 ì´ë¼ì„œ
  // ì‚´ì§ ë°”ê¹¥ìª½ìœ¼ë¡œ ë¹¼ì„œ ë°°ì¹˜
  const xLeftPole = -0.8; // í”Œë«í¼ ìˆëŠ” ìª½, ì„ ë¡œ ë°”ê¹¥
  const xRightPole = 5.1; // ì˜¤ë¥¸ìª½ ì„ ë¡œ ë°”ê¹¥


  // z ê¸°ì¤€: ì •ì°¨ ìœ„ì¹˜ê°€ z=200
  // 50m ê°„ê²©ìœ¼ë¡œ 50m ~ 600m ì „ê¹Œì§€ ì „ë´‡ëŒ€ ì„¤ì¹˜ (ì›í•˜ë©´ ë²”ìœ„ ì¡°ì ˆ ê°€ëŠ¥)
const poleInterval = 55;
const poleMinDistRight = -100;  // ê¸°ì¡´
const poleMinDistLeft = -100;   // ë³€ê²½
const poleMaxDist = 60000;
// ğŸ‘‰ platRemoveë¥¼ ì „ì—­ ë³€ìˆ˜ë¡œ
let platRemove = 215;

// ğŸ‘‰ ì™¼ìª½ í´ë“¤ì„ ë‚˜ì¤‘ì— ë‹¤ ì§€ìš°ê¸° ìœ„í•´ ë°°ì—´ë¡œ ì €ì¥
const leftPoles = [];
/** ì˜¤ë¥¸ìª½ ì „ë´‡ëŒ€ëŠ” í•œ ë²ˆë§Œ ë§Œë“¤ë©´ ë¨ */
function buildRightPoles() {
  for (let d = poleMinDistRight; d <= poleMaxDist; d += poleInterval) {
    const z = 200 - d;
    const rp = new THREE.Mesh(poleGeo, rightPoleMat);
    rp.position.set(xRightPole, poleHeight / 2, z);
    rp.renderOrder = 2;
    scene.add(rp);
  }
}

/** platRemove ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ ì „ë´‡ëŒ€ ì¬ìƒì„± */
function rebuildLeftPoles(newPlatRemove) {
  if (typeof newPlatRemove === "number") {
    platRemove = newPlatRemove;
  }

  // 1) ê¸°ì¡´ í´ ì œê±°
  leftPoles.forEach(p => {
    scene.remove(p);
    if (p.geometry) p.geometry.dispose();
  });
  leftPoles.length = 0;

  // 2) ìƒˆ platRemove ê¸°ì¤€ìœ¼ë¡œ ë‹¤ì‹œ ìƒì„±
  for (let d = poleMinDistLeft; d <= poleMaxDist; d += poleInterval) {
    if (d <= platRemove && d >= -10) {
      // í”Œë«í¼ ì˜ì—­: ë¹ˆ ê³µê°„ìœ¼ë¡œ ë‘ 
      continue;
    }
    const z = 200 - d;
    const lp = new THREE.Mesh(poleGeo, leftPoleMat);
    lp.position.set(xLeftPole, poleHeight / 2, z);
    lp.renderOrder = 2;
    scene.add(lp);
    leftPoles.push(lp);
  }
}

// ì´ˆê¸° ìƒì„±
buildRightPoles();
rebuildLeftPoles(215);

// ì™¸ë¶€ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•˜ê²Œ export
window.rebuildLeftPoles = rebuildLeftPoles;
  // === ì „ì°¨ì„ (ì–‡ì€ ê²€ì€ìƒ‰ ì„ ) ì¶”ê°€ ===
  // ì„ ë¡œ ì¤‘ì‹¬ì€ x â‰ˆ 0, x â‰ˆ 4 ì´ë¼ì„œ ê° ì„ ë¡œ ìœ„ì— í•˜ë‚˜ì”©
  const wireY = 4.6345; // ë†’ì´ 4.6345
  const wireRadius = 0.015; // ì•„ì£¼ ì–‡ê²Œ

  // ì „ì„ ì€ 'í”Œë«í¼ ì „'ë¿ ì•„ë‹ˆë¼ 'í”Œë«í¼ ëê¹Œì§€' ì´ì–´ì§€ê²Œ ê¸¸ê²Œ ë½‘ì
  // ì˜ˆì‹œ: ì •ì°¨ ìœ„ì¹˜ ê¸°ì¤€ -800m ì§€ì ë¶€í„° +100m ì§€ì ê¹Œì§€
  const wireZStart = 200 - 60000; // ë©€ë¦¬
  const wireZEnd = 200 + 100; // ì •ì°¨ ì§€ì  ì•½ê°„ ì§€ë‚˜ì„œ
  const wireLen = Math.abs(wireZEnd - wireZStart);
  const wireZMid = (wireZStart + wireZEnd) / 2;

  const wireGeo = new THREE.CylinderGeometry(wireRadius, wireRadius, wireLen, 8);
  const wireMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
  leftHeightOffset = 0.1;
  rightHeightOffset = 0.2;

  // 1ë²ˆ ì„ ë¡œ ìœ„ ì „ì„  (x â‰ˆ 0)
  const wire1 = new THREE.Mesh(wireGeo, wireMat);
  wire1.position.set(0.4, wireY + rightHeightOffset, wireZMid);
  wire1.rotation.x = Math.PI / 2; // ê¸°ë³¸ì´ Yì¶• ë°©í–¥ì´ë¼ Zì¶•ìœ¼ë¡œ ëˆ•í˜
  wire1.castShadow = false;
  scene.add(wire1);

  poleOffset = 0.7
  // 3ë²ˆ ì„ ë¡œ ìœ„ ì „ì„  (x â‰ˆ 0)
  const wire3 = new THREE.Mesh(wireGeo, wireMat);
  wire3.position.set(0.4, wireY - poleOffset + rightHeightOffset, wireZMid);
  wire3.rotation.x = Math.PI / 2; // ê¸°ë³¸ì´ Yì¶• ë°©í–¥ì´ë¼ Zì¶•ìœ¼ë¡œ ëˆ•í˜
  wire3.castShadow = false;
  scene.add(wire3);

///////////////////

  // 2ë²ˆ ì„ ë¡œ ìœ„ ì „ì„  (x â‰ˆ 4)
  const wire2 = new THREE.Mesh(wireGeo, wireMat);
  wire2.position.set(3.4, wireY + leftHeightOffset + 0.2, wireZMid);
  wire2.rotation.x = Math.PI / 2;
  wire2.castShadow = false;
  scene.add(wire2);


  // 4ë²ˆ ì„ ë¡œ ìœ„ ì „ì„  (x â‰ˆ 4)
  const wire4 = new THREE.Mesh(wireGeo, wireMat);
  wire4.position.set(3.4, wireY - poleOffset + leftHeightOffset, wireZMid);
  wire4.rotation.x = Math.PI / 2;
  wire4.castShadow = false;
  scene.add(wire4);


  // --- í”Œë«í¼ (ì •ì°¨ë²½ ê¸°ì¤€ -platformLen ~ 0m, ì˜¤ë¥¸ìª½ì— ë°°ì¹˜) ---
let platformLen = 210; // í”Œë«í¼ ê¸¸ì´
const platH = 1; // í”Œë«í¼ ë†’ì´ (1.13më¡œ ì„¤ì •)
const platW = 3.0; // í”Œë«í¼ í­
const platZ = 0 + 200; // ì„¸ê³„ì¢Œí‘œ ë³´ì • (ground/railê³¼ ì¼ì¹˜)

// Materials
const platMatTop = new THREE.MeshStandardMaterial({ color: 0xd8dbe1, roughness: 0.95, metalness: 0.0 });
const platMatEdge = new THREE.MeshStandardMaterial({ color: 0xf0d060, roughness: 0.6, metalness: 0.0 }); // ë…¸ë€ ë¼ì¸

// ì¢Œì¸¡ í”Œë«í¼ (ë†’ì´ëŠ” ê·¸ëŒ€ë¡œ 1.13më¡œ ìœ ì§€)
const plat = new THREE.Mesh(new THREE.BoxGeometry(platW, platH, platformLen), platMatTop);
// plat.position.set(+2.4 + 4.9415, platH / 2, platZ - platformLen / 2); // ë°”ë‹¥ì—ì„œ 1.13më¡œ ì„¤ì •, ë†’ì´ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€
// plat.receiveShadow = false; plat.castShadow = false;
// scene.add(plat);

// // ì¢Œì¸¡ ë…¸ë€ ë¼ì¸
const platLine = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.01, platformLen), platMatEdge);
// platLine.position.set(+1.55 + 4.9415, platH+ 0.01, platZ - platformLen / 2); // ë…¸ë€ ë¼ì¸ ìœ„ì¹˜ë„ ê¸¸ì´ì— ë§ì¶° ì¡°ì •
// platLine.receiveShadow = false; platLine.castShadow = false; 
// scene.add(platLine);

// ìš°ì¸¡ í”Œë«í¼ (ì¢Œì¸¡ê³¼ ë™ì¼í•œ ë†’ì´ì™€ Yì¶• ê¸¸ì´ ìœ ì§€)
const platR = new THREE.Mesh(new THREE.BoxGeometry(platW, platH, platformLen), platMatTop);
platR.position.set(-2.9415-0.3, platH / 2, platZ - platformLen / 2); // ë°”ë‹¥ì—ì„œ 1.13më¡œ ì„¤ì •, ì¢Œì¸¡ê³¼ ë™ì¼í•œ ë†’ì´ë¡œ ì„¤ì •
platR.receiveShadow = false; platR.castShadow = false; scene.add(platR);

// ìš°ì¸¡ ë…¸ë€ ë¼ì¸
const platLineR = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.01, platformLen), platMatEdge);
platLineR.position.set(-2.0915-0.3, platH +0.01, platZ - platformLen / 2); // ì¢Œì¸¡ê³¼ ë™ì¼í•œ ë†’ì´ë¡œ ì„¤ì •
platLineR.receiveShadow = false; platLineR.castShadow = false; scene.add(platLineR);


// í”Œë«í¼ ê¸¸ì´ ë™ì  ë³€ê²½ í—¬í¼
window.__updatePlatformLength = function(newLen) {
  try {
    // ì¢Œì¸¡ í”Œë«í¼ ê¸¸ì´ì™€ ë¼ì¸ ì—…ë°ì´íŠ¸
    if (plat.geometry) plat.geometry.dispose();
    if (platLine.geometry) platLine.geometry.dispose();

    plat.geometry = new THREE.BoxGeometry(platW, platH, newLen);
    plat.position.set(+2.4 + 4.9415, platH / 2, platZ - newLen / 2);

    platLine.geometry = new THREE.BoxGeometry(0.2, 0.01, newLen);
    platLine.position.set(+1.55 + 4.9415, platH + 0.01, platZ - newLen / 2);

    // ìš°ì¸¡ í”Œë«í¼ ê¸¸ì´ì™€ ë¼ì¸ ì—…ë°ì´íŠ¸
    if (platR.geometry) platR.geometry.dispose();
    if (platLineR.geometry) platLineR.geometry.dispose();

    platR.geometry = new THREE.BoxGeometry(platW, platH, newLen);
    platR.position.set(-2.9415, platH / 2, platZ - newLen / 2);

    platLineR.geometry = new THREE.BoxGeometry(0.2, 0.01, newLen);
    platLineR.position.set(-2.0915, platH + 0.01, platZ - newLen / 2);

      //  1) í˜„ì¬ í”Œë«í¼ ê¸¸ì´ ìƒíƒœ ê°±ì‹ 
    platformLen = newLen;

    //  2) ì‚¬ëŒ ë‹¤ì‹œ ë¿Œë¦¬ê¸° (ê¸¸ì´ì— ë¹„ë¡€í•´ì„œ ì¸ì› ìˆ˜ ì¡°ì ˆ)
    if (window.spawnPeopleOnPlatform) {
      const baseCount = 30; // 210mì¼ ë•Œ 30ëª…
      const factor = newLen / 210; // ê¸¸ì´ ë¹„ë¡€
      window.spawnPeopleOnPlatform(Math.round(baseCount * factor));
    }

    //  3) ê¸°ë‘¥ + ì§€ë¶• + ë¨í”„ë„ ìƒˆ ê¸¸ì´ì— ë§ê²Œ ë¦¬ë¹Œë“œ
    if (window.__rebuildPlatformRoof) {
      window.__rebuildPlatformRoof(newLen);
    }

  } catch(e) { /* non-fatal */ }
};
  // --- í”Œë«í¼ ê¸°ë‘¥ ë° ì§€ë¶• ì¶”ê°€ (ê°„ë‹¨í•œ êµ¬ì¡°ë¡œ ë¶„ìœ„ê¸° í–¥ìƒ) ---
(function initPlatformRoof(){

  // ì¬ì§ˆ/ê¸°í•˜ í•œ ë²ˆë§Œ ë§Œë“¤ì–´ì„œ ì¬ì‚¬ìš©
  const pillarMat = new THREE.MeshStandardMaterial({
    color: 0xdddddd,
    metalness: 0.2,
    roughness: 0.6
  });
  const roofMat = new THREE.MeshStandardMaterial({
    color: 0xf1f3f6,
    metalness: 0.05,
    roughness: 0.8
  });
  const pillarGeo = new THREE.BoxGeometry(0.3, 3.5, 0.3);

  function buildPlatformRoofAndLights(len) {
    // 1) ì´ì „ ê¸°ë‘¥ ì œê±°
    platformPillars.forEach(p => {
      scene.remove(p);
      if (p.geometry) p.geometry.dispose();
    });
    platformPillars.length = 0;

    // 2) ì´ì „ ë¨í”„ ì œê±°
    platformLights.forEach(l => scene.remove(l));
    platformLights.length = 0;

    // 3) ì´ì „ ì§€ë¶• ì œê±°
    if (platformRoof) {
      scene.remove(platformRoof);
      if (platformRoof.geometry) platformRoof.geometry.dispose();
      platformRoof = null;
    }

    // ìƒˆ ì‹œì‘/ë zëŠ” í”Œë«í¼ ê¸¸ì´(len)ì— ë§ì¶°
    const startZ = platZ - 2;
    const endZ = platZ - len + 2;
    const spacing = 20.0;
    let pillarIndex = 0;

    for (let z = startZ; z > endZ; z -= spacing) {
      pillarIndex++;
      if (pillarIndex % 2 !== 0) continue;

      // ì˜¤ë¥¸ìª½ í”Œë«í¼ ê¸°ë‘¥ (ì§€ê¸ˆ ì‚¬ìš© ì¤‘ì¸ ìª½)
      const pR = new THREE.Mesh(pillarGeo, pillarMat);
      pR.position.set(-2.7, 2.5, z);
      pR.castShadow = false;
      pR.receiveShadow = false;
      scene.add(pR);
      platformPillars.push(pR);

      // ğŸ’¡ ì§€ë¶• ì•„ë˜ í”Œë«í¼ ì¡°ëª…
      const lampHeight = platH + 2.7;
      const lampRange = 22;
      const lampColor = 0xfff1c4;

      const lampL = new THREE.PointLight(lampColor, 0, lampRange, 2.0);
      lampL.position.set(-2.2, lampHeight, z);
      lampL.castShadow = false;
      scene.add(lampL);
      platformLights.push(lampL);
    }

    // ì§€ë¶•ë„ len ê¸°ì¤€ìœ¼ë¡œ ë‹¤ì‹œ ìƒì„±
    const roofGeo = new THREE.BoxGeometry(platW * 1.5, 0.12, len + 6);
    platformRoof = new THREE.Mesh(roofGeo, roofMat);
    platformRoof.position.set(-2.25, platH + 3.0, platZ - len / 2);
    platformRoof.rotation.z = THREE.MathUtils.degToRad(5);
    platformRoof.castShadow = false;
    platformRoof.receiveShadow = false;
    scene.add(platformRoof);
  }
  // ì´ˆê¸° í•œ ë²ˆ: í˜„ì¬ platformLen ê¸°ì¤€ìœ¼ë¡œ ìƒì„±
  buildPlatformRoofAndLights(platformLen);

  // ë‚˜ì¤‘ì— ê¸¸ì´ ë°”ê¿€ ë•Œ ì“°ë ¤ê³  export
  window.__rebuildPlatformRoof = buildPlatformRoofAndLights;
    // const roofL = new THREE.Mesh(roofGeo, roofMat);
    // roofL.position.set(6.25, platH + 3.0, platZ - platformLen/2);
    // roofL.rotation.z = THREE.MathUtils.degToRad(-5);   // 5ë„ ê¸°ìš¸ì´ê¸°
    // roofL.castShadow = false; roofL.receiveShadow = false;
    // scene.add(roofL);

    const peopleGroup = new THREE.Group();
scene.add(peopleGroup);

function spawnPeopleOnPlatform(count) {
  // ê¸°ì¡´ ì‚¬ëŒë“¤ ì œê±°
  while (peopleGroup.children.length) {
    const child = peopleGroup.children.pop();
    if (child.geometry) child.geometry.dispose();
    // materialì€ ì¬ì‚¬ìš© ì¤‘ì´ë©´ disposeí•˜ì§€ ë§ê³  ê·¸ëŒ€ë¡œ ë‘¬ë„ ë¨
  }

  for (let i = 0; i < count; i++) {

    const mat = personMaterials[Math.floor(Math.random() * personMaterials.length)];
    const mesh = new THREE.Mesh(personGeo, mat);

    // z: í”Œë«í¼ ì „ì²´ ê¸¸ì´ ì•ˆì—ì„œ ëœë¤
    const z = platZ - (Math.random() * (platformLen - 10));

    // x: ë…¸ë€ ì„ ì—ì„œ ì¡°ê¸ˆ ë’¤ìª½
    // ì˜¤ë¥¸ìª½ í”Œë«í¼ ê¸°ì¤€ (ì§€ê¸ˆ ì—´ì°¨ê°€ ì˜¤ë¥¸ìª½ì— ë¶™ì–´ìˆìœ¼ë‹ˆê¹Œ)
    const min = -3.5;
    const max = -2.5;

    // Math.random() â†’ 0 ì´ìƒ 1 ë¯¸ë§Œ
    const x = Math.random() * (max - min) + min; // í•„ìš”í•˜ë©´ ì‚´ì§ ì¡°ì •
    const y = platH + personHeight / 2; // ë°œì€ í”Œë«í¼ ìœ„ì— ë‹¿ê²Œ

    mesh.position.set(x, y, z);

    // ì²˜ìŒì—ëŠ” ì¹´ë©”ë¼ ìª½ì„ ë³´ê²Œ
    mesh.lookAt(camera.position.x, y, camera.position.z);

    peopleGroup.add(mesh);
  }
}

// ì „ì—­ì—ì„œ ë‹¤ì‹œ í˜¸ì¶œí•  ìˆ˜ ìˆê²Œ export
window.spawnPeopleOnPlatform = spawnPeopleOnPlatform;

// ì²˜ìŒ í•œ ë²ˆ ì‚¬ëŒ 15ëª… ì •ë„
spawnPeopleOnPlatform(30);


  })();



  
const ambient = new THREE.AmbientLight(0xffffff, 0.05);

// â˜€/ğŸŒ™ ì‹œê°„ëŒ€ì— ë”°ë¥¸ ì¡°ëª… ì„¸íŒ…
  function applyTimeOfDay(mode) {
    timeOfDay = mode;

    if (mode === "night") {
      scene.background = nightSkyTex;

      // í•´ëŠ” ì•„ì£¼ ì•½í•˜ê²Œ, ì „ì²´ í™˜ê²½ì€ ì‚´ì§ ë°ê²Œ
      dir.color.setHex(0xbfd4ff);
      dir.intensity = 0.08;

      ambient.intensity = 0.02;

      // í—¤ë“œë¼ì´íŠ¸ ì˜¨
      headlight.intensity = 1000.0;
    } else {
      scene.background = daySkyTex;

      dir.color.setHex(0xfff6e6);
      dir.intensity = 1.0;

      ambient.intensity = 0.05;

      // í—¤ë“œë¼ì´íŠ¸ ì˜¤í”„
      headlight.intensity = 0.0;
    }

    
    // ğŸ’¡ í”Œë«í¼ ì¡°ëª… on/off (ì•¼ê°„ì—ë§Œ ì¼œê¸°)
    if (Array.isArray(platformLights)) {
      platformLights.forEach(l => {
        if (!l) return;
        l.intensity = (mode === "night") ? 2.4 : 0.0;
      });
    }
  }

  // ì „ì—­ì—ì„œ ë¶€ë¥¼ ìˆ˜ ìˆê²Œ ë…¸ì¶œ
  window.setTimeOfDay = applyTimeOfDay;

  // ì´ˆê¸°ëŠ” ì£¼ê°„
  applyTimeOfDay("day");

scene.add(ambient);

// // --- ì£¼ë³€ ë„ì‹œ ê±´ë¬¼ (ë„ì¿„ì—­ ì£¼ë³€) ---
// (function addBuildings() {
//   const buildingCount = 100; // ğŸ‘ˆ 20 â†’ 10 ìœ¼ë¡œ ì ˆë°˜
//   const texLoader = new THREE.TextureLoader();

//   // ì‚¬ìš©í•  í…ìŠ¤ì²˜ (1~2ê°œë§Œ)
//   const facadeList = [
//     '/static/textures/facade.jpg',
//     '/static/textures/facade2.jpg',
//     '/static/textures/facade5.jpg',
//     '/static/textures/facade6.jpg',
//     '/static/textures/facade8.jpg',
//     '/static/textures/facade9.jpg',
//   ];

//   const facades = facadeList.map(url => {
//     const tex = texLoader.load(url);
//     tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
//     tex.encoding = THREE.sRGBEncoding;
//     tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
//     return tex;
//   });

//   // ê³µìš© ì¬ì§ˆ (Lambert â†’ í›¨ì”¬ ê°€ë²¼ì›€)
//   const materials = facades.map(tex => new THREE.MeshLambertMaterial({ map: tex }));

//   for (let i = 0; i < buildingCount; i++) {
//     // ê±´ë¬¼ í¬ê¸° ëœë¤ (ì¡°ê¸ˆë§Œ ë‹¤ì–‘í™”)
//     const bw = 8 + Math.random() * 10;
//     const bd = 10 + Math.random() * 15;
//     const bh = 20 + Math.random() * 10; // ğŸ‘ˆ ë†’ì´ ë‚®ì¶¤ (GPU ë¶€í•˜â†“)

//     // í•œ ë²ˆ ìƒì„±í•œ ë°•ìŠ¤ ì¬ì‚¬ìš©
//     const box = new THREE.BoxGeometry(bw, bh, bd);

//     const mat = materials[Math.floor(Math.random() * materials.length)];
//     mat.map.repeat.set(bw / 15, bh / 20);

//     const mesh = new THREE.Mesh(box, mat);
//     mesh.castShadow = false; // ğŸ‘ˆ ê·¸ë¦¼ì ì œê±°ë¡œ í° ì„±ëŠ¥ í–¥ìƒ
//     mesh.receiveShadow = false;

//     // ê±°ë¦¬ ê°„ê²©ë„ ë„“í˜€ì„œ ë°€ë„â†“
//     const side = (i % 2 === 0) ? 1 : -1;
//     const x = side * (20 + Math.random() * 5);
//     const z = 400 - i * (10 + Math.random() * 10);
//     mesh.position.set(x, bh / 2, z);

//     scene.add(mesh);
//   }
// })();

  // === Red signs on platform every 50m up to 200m + 300 + 400 ===
const signDistances = [0, 500]; // m ë‹¨ìœ„ ê±°ë¦¬

// ê¸°ë‘¥(í´)ê³¼ ë³´ë“œ(íŒë„¬) ì¬ì§ˆ/í˜•ìƒ
const poleMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.6, metalness: 0.2 });

const poleGeo2 = new THREE.BoxGeometry(0.06, 1.2, 0.06); // w,h,d

// Helper: create a circular sign texture with large distance text (e.g., "150m")
function createDistanceSignTexture(distanceMeters){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const size = 512; // base size
  const width = size * dpr;
  const height = size * dpr;
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');

  // clear
  ctx.clearRect(0, 0, width, height);

  // circle background (red)
  ctx.fillStyle = '#aa0000';
  ctx.beginPath();
  ctx.arc(width/2, height/2, Math.min(width, height) * 0.45, 0, Math.PI * 2);
  ctx.closePath();
  ctx.fill();

  // stroke edge
  ctx.lineWidth = Math.max(2, Math.floor(4 * dpr));
  ctx.strokeStyle = '#550000';
  ctx.stroke();
  let text = 0;
  let trainLength = parseInt(document.getElementById("trainLength").value, 10);
  if (Number.isNaN(trainLength)) trainLength = 10;
  // text (white, large)
  if (distanceMeters == 0) {
    text = `${trainLength}`;
  } else {
    text = `${distanceMeters}m`;
  }
  // choose font size to occupy most of the circle
  const fontSize = Math.floor(Math.min(width, height) * 0.28);
  ctx.font = `bold ${fontSize}px A-OTF Shin Go Pro, sans-serif`;

  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  // slight black shadow for contrast
  ctx.shadowColor = 'rgba(0,0,0,0.45)';
  ctx.shadowBlur = Math.max(4, Math.floor(6 * dpr));
  ctx.fillText(text, width/2, height/2 + Math.floor(fontSize*0.03));

  const tex = new THREE.CanvasTexture(canvas);
  tex.encoding = THREE.sRGBEncoding;
  tex.needsUpdate = true;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  return tex;
}

// Collect sign meshes so we can make them face the camera (billboard)
const platformSignMeshes = [];
const platformSignRings = [];

signDistances.forEach(d => {
  const z = 200 - d; // ì •ì°¨ë²½(0m)ì´ z=200 â†’ -dë§Œí¼ ë’¤
  if (z < -300) return; // ì•ˆì „ ì°¨ë‹¨

  // í´(ê¸°ë‘¥)
  const pole = new THREE.Mesh(poleGeo2, poleMat);
  pole.position.set(-2.1, platH + 0.1, z); // í”Œë«í¼ ìœ„ì—ì„œ 0.1m ì˜¬ë¼ì˜¨ ê¸°ë‘¥ ì¤‘ì‹¬
  if (d == 0) {
    pole.position.set(+2.1, 0.4, z); // ê¸°ë‘¥ ë†’ì´ ì¡°ì •
  } else {
    pole.position.set(-2.1, platH + 0.1, z); // ê¸°ë‘¥ ë†’ì´ ì¡°ì •
  }
  scene.add(pole);

  // ì›í˜• í‘œì§€íŒ: ìº”ë²„ìŠ¤ë¡œ í…ìŠ¤íŠ¸ë¥¼ ê·¸ë ¤ í…ìŠ¤ì²˜ë¡œ ì‚¬ìš©
  const tex = createDistanceSignTexture(d);
  const signMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
  let signRadius = 0.55; // ë¯¸í„° ë‹¨ìœ„ ë°˜ì§€ë¦„ â€” í™”ë©´ì—ì„œ í¼ì§í•˜ê²Œ ë³´ì´ë„ë¡
  if (d == 0) {
    signRadius = 0.30; // ë¯¸í„° ë‹¨ìœ„ ë°˜ì§€ë¦„ â€” í™”ë©´ì—ì„œ í¼ì§í•˜ê²Œ ë³´ì´ë„ë¡
  } else {
    signRadius = 0.55; // ë¯¸í„° ë‹¨ìœ„ ë°˜ì§€ë¦„ â€” í™”ë©´ì—ì„œ í¼ì§í•˜ê²Œ ë³´ì´ë„ë¡
  }
  const signGeo = new THREE.CircleGeometry(signRadius, 64);
  const sign = new THREE.Mesh(signGeo, signMat);
  // do not fix rotation here â€” we'll billboard it to the camera in the render loop
  sign.position.set(-2.1, platH + 1.25, z);
  if (d == 0) {
    sign.position.set(+2.1, 1.25, z);
  } else {
    sign.position.set(-2.1, platH + 1.25, z);
  }
  scene.add(sign);

  // ì–‡ì€ í…Œë‘ë¦¬ ë§ì„ ì¶”ê°€í•´ ì‹œê°ì  ê°•ì¡°
  const ringGeo = new THREE.RingGeometry(signRadius * 0.88, signRadius * 0.99, 64);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x770000 });
  const ring = new THREE.Mesh(ringGeo, ringMat);
  ring.position.copy(sign.position);
  scene.add(ring);

  // keep references for billboard updates
  platformSignMeshes.push(sign);
  platformSignRings.push(ring);
});

  // expose sign meshes and helper to allow runtime texture refresh when train length changes
  window.__platformSignMeshes = platformSignMeshes;
  window.__platformSignRings = platformSignRings;
  window.__platformSignDistances = signDistances;
  window.__createDistanceSignTexture = createDistanceSignTexture;
  window.__refreshPlatformSignTextures = function(){
    try{
      const meshes = window.__platformSignMeshes || [];
      const dists = window.__platformSignDistances || [];
      const createFn = window.__createDistanceSignTexture;
      if (!createFn) return;
      for(let i=0;i<meshes.length;i++){
        const mesh = meshes[i];
        const d = dists[i] ?? 0;
        try{
          // dispose previous texture (if any) to avoid accumulating GPU memory and GC spikes
          try{
            const oldMap = mesh && mesh.material && mesh.material.map;
            if (oldMap && typeof oldMap.dispose === 'function') {
              oldMap.dispose();
            }
          }catch(e){}
          const newTex = createFn(d);
          if (mesh && mesh.material) {
            mesh.material.map = newTex;
            mesh.material.needsUpdate = true;
          }
        }catch(e){}
      }
    }catch(e){}
  };

  // --- ì •ì°¨ë²½(0m, ë°˜íˆ¬ëª… ì´ˆë¡) ---
  // const wallMat = new THREE.MeshBasicMaterial({ color: 0xaa0000, transparent:true, opacity:0.28 });
  // const wall = new THREE.Mesh(new THREE.PlaneGeometry(2.4, 3), wallMat);
  // wall.position.set(0, 2.0, 200); // z=200ì´ â€˜ì •ì°¨ 0mâ€™
  // scene.add(wall);
  // const wallEdge = new THREE.Mesh(new THREE.PlaneGeometry(2.4, 3), new THREE.MeshBasicMaterial({ color:0xff0000, wireframe:true, transparent:true, opacity:0.65 }));
  // wallEdge.position.copy(wall.position);
  // scene.add(wallEdge);

  // --- ë‚¨ì€ê±°ë¦¬â†’ì¹´ë©”ë¼/ì˜¤ë¸Œì íŠ¸ ë™ê¸° ---
  // ë””ìì¸: ì¹´ë©”ë¼ z_world = 200 - remaining_m
  // í”Œë«í¼/ë ˆì¼/ìê°ˆì€ ì„¸ê³„ ê³ ì •. ì¹´ë©”ë¼ë§Œ ì´ë™ -> 1ì¸ì¹­ ì£¼í–‰.
function syncCameraFromState() {
  const rem = Number(window.st?.remaining_m ?? 0);
  
const trainName = window.st?.train_name ?? '';
const lowerName = trainName.toLowerCase();

//ê¸°ê´€ì‚¬ ì‹œì  ë†’ì´
const y = (lowerName.includes('ktx') || lowerName.includes('999'))
  ? 3.0
  : lowerName.includes('e26')
    ? 3.5
    : 2.8
  
const z = 200 - rem;

const angle = (lowerName.includes('ktx') || lowerName.includes('999'))
  ? 0.5
  : (lowerName.includes('n700s') || lowerName.includes('e26'))
    ? 0.6
    : lowerName.includes('e233') || lowerName.includes('e235') 
    ? 0.4 : 0.8; //the rest, including n700s


// ì¹´ë©”ë¼ë¥¼ ì‚´ì§ ì™¼ìª½ìœ¼ë¡œ ì´ë™ì‹œí‚¤ê³ , ì‚´ì§ ì•„ë˜ìª½ì„ ë°”ë¼ë³´ê²Œ ì„¤ì •
const xOffset = (lowerName.includes('seoul'))? 0: 0.9;  // ì¹´ë©”ë¼ë¥¼ ì™¼ìª½ìœ¼ë¡œ 1.5 ë‹¨ìœ„ ì´ë™
const yOffset = y - angle; // ê¸°ì¡´ë³´ë‹¤ ì‚´ì§ ë” ì•„ë˜ìª½ì„ ë°”ë¼ë³´ë„ë¡ ì„¤ì •
const zOffset = z + 4.0;  // ê¸°ì¡´ zì— ì¡°ì •ê°’ ì¶”ê°€

// ì¹´ë©”ë¼ ìœ„ì¹˜ ì„¤ì • (ì™¼ìª½ìœ¼ë¡œ ì´ë™, zì™€ yê°’ ìœ ì§€ ë˜ëŠ” ì¡°ì •)
camera.position.set(xOffset, y, z);

// ì¹´ë©”ë¼ëŠ” ì‚´ì§ ì•„ë˜ìª½ì„ ë°”ë¼ë³´ë„ë¡ ì¡°ì •
camera.lookAt(xOffset, yOffset, zOffset);

}

//  ëª©í‘œ FPS (ì›í•˜ë©´ 24, 30, 45 ë“±ìœ¼ë¡œ ë°”ê¿”ë„ ë¨)
  const TARGET_FPS = 36; //dt 0.0025 + fps36 ->>opt val!!
  const FRAME_INTERVAL = 1000 / TARGET_FPS;
  let lastRenderTime = 0;

  function tick(t) {
    // í”„ë ˆì„ ìŠ¤í‚µ: ë„ˆë¬´ ìì£¼ ê·¸ë¦¬ë ¤ê³  í•˜ë©´ ê±´ë„ˆë›°ê¸°
    if (t - lastRenderTime < FRAME_INTERVAL) {
      requestAnimationFrame(tick);
      return;
    }
    lastRenderTime = t;
    if (st) drawHUD(st);
    if (modeSel?.value === 'on'){
  // ì§„í–‰ê°: ìê°ˆ/íŠ¸ë™ í…ìŠ¤ì²˜ ìŠ¤í¬ë¡¤(ë§¤ í”„ë ˆì„ ë°˜ë³µìˆ˜ ë³€ê²½)
  const rem = Number(window.st?.remaining_m ?? 0);
  // only update texture offsets if the textures exist (avoid per-frame exceptions)
  if (typeof ballastDiff !== 'undefined' && ballastDiff && ballastDiff.offset) {
    ballastDiff.offset.y = (rem * 100) % 1;
  }
  if (typeof ballastNorm !== 'undefined' && ballastNorm && ballastNorm.offset) {
    ballastNorm.offset.y = (rem * 100) % 1;
  }
  if (typeof trackTex !== 'undefined' && trackTex && trackTex.offset) {
    trackTex.offset.y = (rem * 0.02) % 1;
  }
      syncCameraFromState();
          // Make platform signs face the camera (billboard) so driver sees them
          // Throttle lookAt updates to avoid many small matrix updates per-frame which can
          // create jank on lower-end devices. Update when camera moves noticeably or every
          // 120ms as a fallback.
          try{
            if (!window.__lastSignCamPos) window.__lastSignCamPos = new THREE.Vector3();
            if (!window.__lastSignUpdate) window.__lastSignUpdate = 0;
            const nowSign = performance.now();
            const camPos = camera.position;
            const needUpdate = (nowSign - window.__lastSignUpdate) > 120 || camPos.distanceToSquared(window.__lastSignCamPos) > 0.0004;
            if (needUpdate) {
              window.__lastSignCamPos.copy(camPos);
              window.__lastSignUpdate = nowSign;
              if (Array.isArray(platformSignMeshes) && platformSignMeshes.length){
                for (let i=0;i<platformSignMeshes.length;i++){
                  const m = platformSignMeshes[i];
                  if (m && m.lookAt) m.lookAt(camPos);
                }
              }
              if (Array.isArray(platformSignRings) && platformSignRings.length){
                for (let i=0;i<platformSignRings.length;i++){
                  const r = platformSignRings[i];
                  if (r && r.lookAt) r.lookAt(camPos);
                }
              }
            }
          }catch(e){ /* non-fatal */ }
        
       //  ë¹„ìƒ ì¥ì• ë¬¼ ì¤‘ ë¶ˆ íƒ€ì…ì€ í•­ìƒ ì¹´ë©”ë¼ë¥¼ ë°”ë¼ë³´ê²Œ
    if (emergencyObstacle && emergencyObstacle.userData && emergencyObstacle.userData.billboard) {
      emergencyObstacle.lookAt(
        camera.position.x,
        emergencyObstacle.position.y,
        camera.position.z
      );
    }
    // ì‚¬ëŒ billboard ì²˜ë¦¬


      renderer.render(scene, camera);
      // lightweight DPR autoscaler: periodically adjust renderer pixel ratio based on observed FPS
      // try { autoScaleDPR(); } catch (e) { /* non-fatal */ }
    }

    requestAnimationFrame(tick);
  }
  
  requestAnimationFrame(tick);
})();

// Optional station melody audio (Tokyo / Seoul variation)
let stationMelody = null;

function getCurrentTrainName() {
  // ì„œë²„ ìƒíƒœ(st.train_name)ê°€ ìˆìœ¼ë©´ ê·¸ê±¸ ìš°ì„  ì‚¬ìš©
  if (window.st && window.st.train_name) return window.st.train_name;

  // ì—†ìœ¼ë©´ í™”ë©´ì— í‘œì‹œëœ ì°¨ëŸ‰ ì´ë¦„ ì‚¬ìš©
  const carNameEl = document.getElementById("carName");
  return carNameEl ? (carNameEl.textContent || "") : "";
}

try {
  stationMelody = new Audio();
  stationMelody.preload = 'auto';
  stationMelody.volume = 0.75;
  // í˜„ì¬ ì–´ë–¤ ìŒì›ì„ ì“°ëŠ”ì§€ í‘œì‹œìš© í‚¤
  stationMelody._variantKey = null;
} catch (e) {
  stationMelody = null;
}

// ===== BVE SOUND ENGINE (CSV-based motor sound synthesis) =====
let bveCtx = null;
let bveSoundEngine = null;

/**
 * BveSoundEngine: Loads CSV tables from BVE motor noise data and plays
 * layered WAV files based on speed, with smooth interpolation.
 */
class BveSoundEngine {
  constructor(ctx, trainType = '') {
    this.ctx = ctx;
    this.master = ctx.createGain();
    
    // Adjust master volume based on train type (KTX and N700S tend to be quieter)
    let masterVolume = 2.0;
    if (trainType && (trainType.toLowerCase().includes('ktx') || trainType.toLowerCase().includes('n700'))) {
      masterVolume = 0.3; // bullet trains get lower volume
    }
    this.master.gain.value = masterVolume;
    this.master.connect(ctx.destination);

    // CSV tables: { speed -> { wavName -> value } }
    this.powerVolTable = {};
    this.powerFreqTable = {};
    this.brakeVolTable = {};
    this.brakeFreqTable = {};

    // WAV buffer cache: { wavName -> AudioBuffer }
    this.wavBuffers = {};

    // Currently playing sources: { wavName -> { source, gain, isPlaying, targetVol, targetFreq } }
    this.activeSources = {};

    // Ghost sources (fading out from previous mode): array of { source, gain, fadeOutEnd }
    this.ghostSources = [];

    // State
    this.currentSpeed = 0;
    this.lastMode = "coast"; // "power", "brake", "coast"
    this.lastDebugLog = 0; // For rate-limiting debug output
    this.modeFadeOutTime = 0.2; // Fade time when switching modes
    this.modeFadeInTime = 0.3; // Fade time when switching modes
    this.overlapDuration = 1.2; // Duration to overlap old and new mode audio (in seconds)
    
    // Door sound state
    this.doorBuffer = null;
    this.doorCloseBuffer = null;
    this.doorPlaying = false;
    this.lastDoorTrigger = -10; // Last time door was played (in seconds)
  }

  /**
   * Parse CSV text into a speed -> { wavName -> value } lookup table.
   * Handles missing (empty) cells and interpolates smoothly.
   */
  parseCSV(csvText) {
    const lines = csvText.trim().split('\n').filter(l => l.length > 0);
    if (lines.length < 2) return {};

    // Skip the first line if it's metadata (contains "Bvets" or doesn't start with "#")
    let headerLineIdx = 0;
    if (!lines[0].startsWith('#')) {
      headerLineIdx = 1;
    }

    if (headerLineIdx >= lines.length) return {};

    // Parse the actual header line
    const headers = lines[headerLineIdx].split(',').map(h => h.trim());
    // First column is "#" (speed)
    const wavNames = headers.slice(1);

    // Build { speed -> { wavName -> value } }
    const table = {};
    for (let i = headerLineIdx + 1; i < lines.length; i++) {
      const cells = lines[i].split(',').map(c => c.trim());
      const speed = parseFloat(cells[0]);
      if (isNaN(speed)) continue;

      table[speed] = {};
      for (let j = 0; j < wavNames.length; j++) {
        const val = cells[j + 1];
        const numVal = val === '' ? null : parseFloat(val);
        table[speed][wavNames[j]] = numVal;
      }
    }

    // Interpolate missing values
    this.interpolateMissingValues(table, wavNames);
    return table;
  }

  /**
   * Linear interpolation for missing (null) cells in the table.
   * For each WAV, for each speed with null value:
   *   - Find nearest valid values above and below
   *   - Interpolate linearly
   *   - If isolated (no neighbors), use default (1.0 for freq, 0 for vol)
   */
  interpolateMissingValues(table, wavNames) {
    const speeds = Object.keys(table).map(Number).sort((a, b) => a - b);

    for (const wavName of wavNames) {
      // For this WAV, build a list of (speed, value) pairs with non-null values
      const validPairs = [];
      for (const speed of speeds) {
        if (table[speed][wavName] !== null && table[speed][wavName] !== undefined) {
          validPairs.push({ speed, val: table[speed][wavName] });
        }
      }

      // Now fill in missing values using binary search for efficiency
      for (const speed of speeds) {
        if (table[speed][wavName] !== null && table[speed][wavName] !== undefined) {
          continue; // Already has a value
        }

        // Binary search to find the nearest valid speeds
        let below = null, above = null;

        // Find the last valid pair with speed <= current speed
        for (let i = validPairs.length - 1; i >= 0; i--) {
          if (validPairs[i].speed <= speed) {
            below = validPairs[i];
            break;
          }
        }

        // Find the first valid pair with speed > current speed
        for (let i = 0; i < validPairs.length; i++) {
          if (validPairs[i].speed > speed) {
            above = validPairs[i];
            break;
          }
        }

        // Interpolate or use default
        if (below !== null && above !== null) {
          // Linear interpolation
          const t = (speed - below.speed) / (above.speed - below.speed);
          table[speed][wavName] = below.val * (1 - t) + above.val * t;
        } else if (below !== null) {
          // Use value below
          table[speed][wavName] = below.val;
        } else if (above !== null) {
          // Use value above
          table[speed][wavName] = above.val;
        } else {
          // Isolated: use default
          table[speed][wavName] = null;
        }
      }
    }
  }

  /**
   * Load CSV files asynchronously from given paths.
   */
  async loadCsvTables(powerVolPath, powerFreqPath, brakeVolPath, brakeFreqPath) {
    try {
      // Update loading screen
      this.updateLoadingUI("Loading motor tables...", 15);
      
      const [powerVolText, powerFreqText, brakeVolText, brakeFreqText] = await Promise.all([
        fetch(powerVolPath).then(r => r.text()),
        fetch(powerFreqPath).then(r => r.text()),
        fetch(brakeVolPath).then(r => r.text()),
        fetch(brakeFreqPath).then(r => r.text()),
      ]);

      // Parse each CSV sequentially with UI updates to prevent thread blocking
      this.powerVolTable = this.parseCSV(powerVolText);
      await new Promise(resolve => setTimeout(resolve, 20));
      this.updateLoadingUI("Loading motor tables... (1/4)", 20);

      this.powerFreqTable = this.parseCSV(powerFreqText);
      await new Promise(resolve => setTimeout(resolve, 20));
      this.updateLoadingUI("Loading motor tables... (2/4)", 25);

      this.brakeVolTable = this.parseCSV(brakeVolText);
      await new Promise(resolve => setTimeout(resolve, 20));
      this.updateLoadingUI("Loading motor tables... (3/4)", 30);

      this.brakeFreqTable = this.parseCSV(brakeFreqText);
      await new Promise(resolve => setTimeout(resolve, 20));
      this.updateLoadingUI("Motor tables loaded", 35);

      console.log("BVE CSV tables loaded successfully");
    } catch (err) {
      console.error("Failed to load BVE CSV tables:", err);
      throw err;
    }
  }

  /**
   * Update loading screen UI
   */
  updateLoadingUI(status, percent) {
    const statusEl = document.getElementById('bveLoadStatus');
    const barEl = document.getElementById('bveLoadBar');
    const percentEl = document.getElementById('bveLoadPercent');
    
    if (statusEl) statusEl.textContent = status;
    if (barEl) barEl.style.width = percent + '%';
    if (percentEl) percentEl.textContent = percent;
  }

  /**
   * Load all WAV files from the motor directory (with UI updates between batches).
   */
  async loadWavBuffers(motorDirPath, wavFileNames) {
    try {
      const batchSize = 3; // 3ê°œì”© ë™ì‹œì— ë¡œë“œ (ë©”ì¸ ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹ ë°©ì§€)
      
      for (let batchStart = 0; batchStart < wavFileNames.length; batchStart += batchSize) {
        const batchEnd = Math.min(batchStart + batchSize, wavFileNames.length);
        const batchPromises = [];

        for (let i = batchStart; i < batchEnd; i++) {
          const name = wavFileNames[i];
          const promise = fetch(`${motorDirPath}/${name}`)
            .then(r => r.arrayBuffer())
            .then(buf => this.ctx.decodeAudioData(buf))
            .then(decoded => {
              this.wavBuffers[name.replace('.wav', '')] = decoded;
            })
            .catch(err => console.warn(`Failed to load ${name}:`, err));
          
          batchPromises.push(promise);
        }

        // í˜„ì¬ ë°°ì¹˜ ëŒ€ê¸°
        await Promise.all(batchPromises);

        // ê° ë°°ì¹˜ í›„ UI ì—…ë°ì´íŠ¸ (ë©”ì¸ ìŠ¤ë ˆë“œ í•´ë°©)
        const progress = 35 + Math.floor(batchEnd / wavFileNames.length * 55);
        this.updateLoadingUI(`Loading audio (${batchEnd}/${wavFileNames.length})`, progress);

        // ë‹¤ìŒ ë°°ì¹˜ ì „ì— ì§§ì€ ì§€ì—° (UI ë Œë”ë§ ê¸°íšŒ ì œê³µ)
        if (batchEnd < wavFileNames.length) {
          await new Promise(resolve => setTimeout(resolve, 10));
        }
      }

      this.updateLoadingUI("Audio ready!", 90);
      console.log(`BVE loaded ${Object.keys(this.wavBuffers).length} WAV buffers`);
    } catch (err) {
      console.error("Failed to load BVE WAV files:", err);
      throw err;
    }
  }

  /**
   * Load door open sound
   */
  async loadDoorSound(doorPath) {
    try {
      const response = await fetch(doorPath);
      const arrayBuffer = await response.arrayBuffer();
      // decodeAudioData used with Promise-style wrapper for better compatibility
      this.doorBuffer = await new Promise((resolve, reject) => {
        try {
          this.ctx.decodeAudioData(arrayBuffer, (buf) => resolve(buf), (err) => reject(err));
        } catch (err) { reject(err); }
      });
      console.log("âœ“ BVE loaded door sound");
    } catch (err) {
      console.warn("Failed to load door sound:", err);
    }
  }

  /**
   * Play door sound (one-shot, not looped)
   */
  playDoorSound() {
    if (!this.doorBuffer || this.doorPlaying) return;

    const doPlay = () => {
      try {
        const source = this.ctx.createBufferSource();
        source.buffer = this.doorBuffer;
        source.loop = false;

        const gain = this.ctx.createGain();
        gain.gain.value = 0.7; // Door sound volume

        source.connect(gain);
        gain.connect(this.master);
        source.start(this.ctx.currentTime);

        // Mark as playing and set timeout to reset flag
        this.doorPlaying = true;
        const duration = this.doorBuffer.duration || 1.0;
        setTimeout(() => { this.doorPlaying = false; }, duration * 1000 + 100);

        console.debug("BVE: Door sound played");
      } catch (err) {
        console.error("BVE: Error playing door sound:", err);
      }
    };

    // Ensure AudioContext resumed (browser policies)
    if (this.ctx.state === 'suspended') {
      this.ctx.resume().then(doPlay).catch(err => console.error('BVE: resume failed', err));
    } else {
      doPlay();
    }
  }

  /**
   * Load door close sound (one-shot)
   */
  async loadDoorCloseSound(doorClosePath) {
    try {
      const response = await fetch(doorClosePath);
      const arrayBuffer = await response.arrayBuffer();
      this.doorCloseBuffer = await new Promise((resolve, reject) => {
        try {
          this.ctx.decodeAudioData(arrayBuffer, (buf) => resolve(buf), (err) => reject(err));
        } catch (err) { reject(err); }
      });
      console.log("âœ“ BVE loaded door close sound");
    } catch (err) {
      console.warn("Failed to load door close sound:", err);
    }
  }

  /**
   * Play door close sound (one-shot, not looped)
   */
  playDoorClose() {
    if (!this.doorCloseBuffer || this.doorPlaying) return;

    const doPlay = () => {
      try {
        const source = this.ctx.createBufferSource();
        source.buffer = this.doorCloseBuffer;
        source.loop = false;

        const gain = this.ctx.createGain();
        gain.gain.value = 0.7; // Door sound volume

        source.connect(gain);
        gain.connect(this.master);
        source.start(this.ctx.currentTime);

        // Mark as playing and set timeout to reset flag
        this.doorPlaying = true;
        const duration = this.doorCloseBuffer.duration || 1.0;
        setTimeout(() => { this.doorPlaying = false; }, duration * 1000 + 100);

        console.debug("BVE: Door close sound played");
      } catch (err) {
        console.error("BVE: Error playing door close sound:", err);
      }
    };

    // Ensure AudioContext resumed (browser policies)
    if (this.ctx.state === 'suspended') {
      this.ctx.resume().then(doPlay).catch(err => console.error('BVE: resume failed', err));
    } else {
      doPlay();
    }
  }

  /**
   * Load horn sound (one-shot)
   */
  async loadHornSound(hornPath) {
    try {
      const response = await fetch(hornPath);
      const arrayBuffer = await response.arrayBuffer();
      this.hornBuffer = await new Promise((resolve, reject) => {
        try {
          this.ctx.decodeAudioData(arrayBuffer, (buf) => resolve(buf), (err) => reject(err));
        } catch (err) { reject(err); }
      });
      console.log("âœ“ BVE loaded horn sound");
    } catch (err) {
      console.warn("Failed to load horn sound:", err);
    }
  }

  /**
   * Play horn (one-shot). Uses a short playing guard to avoid overlap spam.
   */
  playHorn() {
    if (!this.hornBuffer) return;
    if (this.hornPlaying) return;

    const doPlay = () => {
      try {
        const source = this.ctx.createBufferSource();
        source.buffer = this.hornBuffer;
        source.loop = false;

        const gain = this.ctx.createGain();
        gain.gain.value = 0.9; // Horn volume

        source.connect(gain);
        gain.connect(this.master);
        source.start(this.ctx.currentTime);

        // Prevent immediate retriggering while horn plays
        this.hornPlaying = true;
        const duration = this.hornBuffer.duration || 0.8;
        setTimeout(() => { this.hornPlaying = false; }, duration * 1000 + 50);

        console.debug("BVE: Horn played");
      } catch (err) {
        console.error("BVE: Error playing horn:", err);
      }
    };

    if (this.ctx.state === 'suspended') {
      this.ctx.resume().then(doPlay).catch(err => console.error('BVE: resume failed', err));
    } else {
      doPlay();
    }
  }

  /**
   * Get interpolated volume for a WAV at a given speed using the appropriate table.
   */
  getInterpolatedVol(speed, wavName, mode) {
    const table = mode === "brake" ? this.brakeVolTable : this.powerVolTable;
    return this.getInterpolated(speed, wavName, table, 0); // Default 0 for vol
  }

  /**
   * Get interpolated frequency multiplier for a WAV at a given speed.
   */
  getInterpolatedFreq(speed, wavName, mode) {
    const table = mode === "brake" ? this.brakeFreqTable : this.powerFreqTable;
    return this.getInterpolated(speed, wavName, table, 1.0); // Default 1.0 for freq
  }

  /**
   * Generic interpolation helper.
   */
  getInterpolated(speed, wavName, table, defaultVal) {
    const speeds = Object.keys(table).map(Number).sort((a, b) => a - b);
    if (speeds.length === 0) return defaultVal;

    // Clamp to min/max speed
    if (speed <= speeds[0]) {
      const val = table[speeds[0]][wavName];
      return val !== null && val !== undefined ? val : defaultVal;
    }
    if (speed >= speeds[speeds.length - 1]) {
      const val = table[speeds[speeds.length - 1]][wavName];
      return val !== null && val !== undefined ? val : defaultVal;
    }

    // Find bracketing speeds
    for (let i = 0; i < speeds.length - 1; i++) {
      if (speed >= speeds[i] && speed <= speeds[i + 1]) {
        const s0 = speeds[i], s1 = speeds[i + 1];
        const v0 = table[s0][wavName], v1 = table[s1][wavName];

        // Handle nulls
        const val0 = v0 !== null && v0 !== undefined ? v0 : defaultVal;
        const val1 = v1 !== null && v1 !== undefined ? v1 : defaultVal;

        // Linear interpolation
        const t = (speed - s0) / (s1 - s0);
        return val0 * (1 - t) + val1 * t;
      }
    }

    return defaultVal;
  }

  /**
   * Ensure a WAV is playing and update its properties.
   */
  ensurePlaying(wavName, speed, mode, fadeInTime = null) {
    const buffer = this.wavBuffers[wavName];
    if (!buffer) {
      console.debug(`BVE: WAV buffer not found: ${wavName}`);
      return;
    }

    const vol = this.getInterpolatedVol(speed, wavName, mode);
    const freq = this.getInterpolatedFreq(speed, wavName, mode);

    // Use mode-specific fade time if available
    if (fadeInTime === null) {
      fadeInTime = this.modeFadeInTime || 0.3;
    }

    // Debug: Log volume and frequency for diagnostics (sample rate limit to avoid spam)
    const now = Date.now();
    if (!this.lastDebugLog || now - this.lastDebugLog > 500) {
      console.debug(`BVE: ${wavName} @ speed ${speed.toFixed(1)} = vol: ${vol.toFixed(2)}, freq: ${freq.toFixed(2)}, mode: ${mode}`);
      this.lastDebugLog = now;
    }

    if (vol <= 0) {
      // Stop if vol is 0
      this.stopWav(wavName, this.modeFadeOutTime || 0.2);
      return;
    }

    const t = this.ctx.currentTime;
    if (!this.activeSources[wavName]) {
      // Create new source
      try {
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        source.playbackRate.value = Math.max(0.5, Math.min(2.0, freq)); // Clamp freq

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(Math.min(1, vol), t + fadeInTime);

        source.connect(gain);
        gain.connect(this.master);
        source.start();

        console.debug(`BVE: Started ${wavName}`);
        this.activeSources[wavName] = { source, gain, isPlaying: true, targetVol: vol, targetFreq: freq };
      } catch (err) {
        console.error(`BVE: Error starting ${wavName}:`, err);
      }
    } else {
      // Update existing source - use linear ramps for smoother transitions
      const { source, gain } = this.activeSources[wavName];
      try {
        const g = gain.gain;
        g.cancelScheduledValues(t);
        const current = g.value || 0;
        g.setValueAtTime(current, t);
        const rampTo = Math.min(1, vol);
        const rampDur = Math.max(0.05, (this.modeFadeInTime || 0.3));
        g.linearRampToValueAtTime(rampTo, t + rampDur);
      } catch (e) {
        try { gain.gain.setTargetAtTime(Math.min(1, vol), t, 0.05); } catch(e){}
      }

      try {
        const pr = source.playbackRate;
        pr.cancelScheduledValues(t);
        const curp = pr.value || 1.0;
        pr.setValueAtTime(curp, t);
        pr.linearRampToValueAtTime(Math.max(0.5, Math.min(2.0, freq)), t + Math.max(0.05, (this.modeFadeInTime || 0.3)));
      } catch (e) {
        try { source.playbackRate.setTargetAtTime(Math.max(0.5, Math.min(2.0, freq)), t, 0.05); } catch(e){}
      }

      this.activeSources[wavName].targetVol = vol;
      this.activeSources[wavName].targetFreq = freq;
    }
  }

  /**
   * Stop a WAV with fade-out.
   */
  stopWav(wavName, fadeOutTime = 0.2) {
    if (!this.activeSources[wavName]) return;
    const { source, gain } = this.activeSources[wavName];
    const t = this.ctx.currentTime;

    try {
      const g = gain.gain;
      g.cancelScheduledValues(t);
      const current = g.value || 0;
      g.setValueAtTime(current, t);
      g.linearRampToValueAtTime(0, t + fadeOutTime);
    } catch (e) {
      try { gain.gain.setTargetAtTime(0, t, fadeOutTime / 5); } catch(e){}
    }

    setTimeout(() => {
      try {
        source.stop();
      } catch (e) {
        // Already stopped
      }
      delete this.activeSources[wavName];
    }, Math.max(50, fadeOutTime * 1000 + 50));
  }

  /**
   * Manage ghost sources (previous mode sources fading out).
   * Clean up finished ghosts and update remaining ones.
   */
  cleanupGhostSources() {
    const now = this.ctx.currentTime;
    this.ghostSources = this.ghostSources.filter(ghost => {
      if (now >= ghost.fadeOutEnd) {
        try { ghost.source.stop(); } catch (e) {}
        return false; // Remove from ghost list
      }
      return true; // Keep in ghost list
    });
  }

  /**
   * Update sound based on current speed and mode.
   * Call this every frame.
   */
  update(currentSpeed, powerNotch, maxPowerNotch, brakeNotch, maxBrakeNotch, isEB) {
    this.currentSpeed = currentSpeed;

    // Clean up old ghost sources
    this.cleanupGhostSources();

    // Skip update if speed is too low
    if (currentSpeed < 0.5) {
      // Stop all sounds when stopped
      for (const wavName in this.activeSources) {
        this.stopWav(wavName);
      }
      return;
    }

    // Determine mode
    let mode = "coast";
    if (isEB) mode = "brake";
    else if (powerNotch > 0) mode = "power";
    else if (brakeNotch > 0) mode = "brake";

    // Detect mode change for crossfading
    const modeChanged = mode !== this.lastMode;
    if (modeChanged) {
      // Crossfade: move current active sources to ghost list (fade out over overlapDuration)
      const now = this.ctx.currentTime;
      const fadeOutEnd = now + this.overlapDuration;
      
      for (const wavName in this.activeSources) {
        const { source, gain } = this.activeSources[wavName];
        try {
          const g = gain.gain;
          g.cancelScheduledValues(now);
          const current = g.value || 0;
          g.setValueAtTime(current, now);
          g.linearRampToValueAtTime(0, fadeOutEnd);
        } catch (e) {
          try { gain.gain.setTargetAtTime(0, now, this.overlapDuration / 5); } catch(e){}
        }
        
        this.ghostSources.push({ source, gain, fadeOutEnd });
      }
      
      // Clear active sources (new ones will be created for new mode)
      this.activeSources = {};
    }

    // Get appropriate CSV tables
    const volTable = mode === "brake" ? this.brakeVolTable : this.powerVolTable;
    const freqTable = mode === "brake" ? this.brakeFreqTable : this.powerFreqTable;

    // Get all WAV names from the active table - extract from headers
    const allWavNames = new Set();
    
    // Try to get WAV names from any row in the table
    const firstSpeed = Object.keys(volTable)[0];
    if (firstSpeed !== undefined && volTable[firstSpeed]) {
      Object.keys(volTable[firstSpeed]).forEach(name => {
        if (name && name.length > 0) {
          allWavNames.add(name);
        }
      });
    }

    // Debug: Log what we found (once per mode change)
    if (modeChanged && allWavNames.size === 0) {
      console.warn("BVE: No WAV names found in vol table for mode", mode, "Available speeds:", Object.keys(volTable).slice(0, 5));
    }

    // Update each WAV
    for (const wavName of allWavNames) {
      const vol = this.getInterpolatedVol(currentSpeed, wavName, mode);
      if (vol > 0.01) {  // Use small threshold instead of 0
        this.ensurePlaying(wavName, currentSpeed, mode);
      } else {
        // Use mode-specific fade time
        this.stopWav(wavName, this.modeFadeOutTime);
      }
    }

    // Stop any WAVs that shouldn't be playing in this mode
    try {
      for (const wavName in this.activeSources) {
        if (!allWavNames.has(wavName)) {
          this.stopWav(wavName, this.modeFadeOutTime);
        }
      }
    } catch (e) {
      // ignore timing errors
    }

    this.lastMode = mode;
  }
}

// ===== BVE Engine Helper Functions =====
/**
 * Initialize and load the BVE sound engine.
 * Call this once at startup.
 * @param {string} trainType - Optional train type name to adjust master volume
 */
async function initializeBveEngine(trainType = '') {
  const AC = window.AudioContext || window.webkitAudioContext;
  if (!AC) {
    console.warn("AudioContext not supported");
    return null;
  }

  if (!bveCtx) {
    bveCtx = new AC();
  }
  if (bveCtx.state === "suspended") {
    await bveCtx.resume();
  }

  if (!bveSoundEngine) {
    bveSoundEngine = new BveSoundEngine(bveCtx, trainType);

    try {
      // Load CSV tables
      await bveSoundEngine.loadCsvTables(
        "/static/E233/OriginalData/MotorNoise/PowerVol.csv",
        "/static/E233/OriginalData/MotorNoise/PowerFreq.csv",
        "/static/E233/OriginalData/MotorNoise/BrakeVol.csv",
        "/static/E233/OriginalData/MotorNoise/BrakeFreq.csv"
      );

      // Load all WAV files
      const wavFileNames = [
        "MotorP1_Oflat.wav", "MotorP1_Sub.wav", "MotorP1-P2_L.wav",
        "MotorP2.wav", "MotorP3.wav", "MotorP5.wav", "MotorP6.wav",
        "MotorP7-1.wav", "MotorP8-1.wav", "MotorP8-2.wav", "MotorP8-3.wav",
        "MotorB1.wav", "MotorB2.wav", "MotorB3.wav", "MotorB4.wav",
        "MotorB5.wav", "MotorB6.wav", "MotorB7.wav", "MotorB8.wav",
        "MotorB9_H.wav", "MotorB9_L.wav", "MotorB9_Oflat.wav",
        "MotorB10_H.wav", "MotorB10_L.wav", "MotorB10_Oflat.wav",
        "MotorB11_H.wav", "MotorB11_M.wav", "MotorB11_L.wav",
        "MotorB11_LL.wav", "MotorB11_Oflat.wav",
        "MotorB12_H.wav", "MotorB12_L.wav", "MotorB14.wav"
      ];

      await bveSoundEngine.loadWavBuffers(
        "/static/E233/OriginalData/Sound/Motor",
        wavFileNames
      );

      // Also load door sound separately (correct path)
      await bveSoundEngine.loadDoorSound("/static/E233/OriginalData/Sound/Door/DoorOpen1.wav");
      
      // Load door close sound - select based on current train layout
      const doorClosePath = (window.__currentCabLayoutKey === 's3000')
        ? "/static/E233/OriginalData/Sound/Door/korail_doorclose.wav"
        : "/static/E233/OriginalData/Sound/Door/DoorClose1.wav";
      await bveSoundEngine.loadDoorCloseSound(doorClosePath);

      // Load horn sound - select based on current train layout
      const hornPath = (window.__currentCabLayoutKey === 'n700s' || window.__currentCabLayoutKey === 'ktx')
        ? "/static/E233/ExternalData/Sound/Horn/HornD.wav"
        : "/static/E233/ExternalData/Sound/Horn/HornB.wav";
      await bveSoundEngine.loadHornSound(hornPath);

      // Load air-down sounds used for brake transitions
      await loadAirSounds();

      // Load notch sound effect
      await loadNotchSound();

      console.log("âœ“ BVE Sound Engine fully initialized and ready");
      
      // Hide loading screen with fade-out
      const loadingScreen = document.getElementById('bveLoadingScreen');
      if (loadingScreen) {
        bveSoundEngine.updateLoadingUI("Ready!", 100);
        setTimeout(() => {
          loadingScreen.style.transition = 'opacity 0.6s ease-out';
          loadingScreen.style.opacity = '0';
          setTimeout(() => {
            loadingScreen.style.display = 'none';
          }, 600);
        }, 500);
      }
    } catch (err) {
      console.error("BVE initialization error:", err);
      const loadingScreen = document.getElementById('bveLoadingScreen');
      if (loadingScreen) {
        bveSoundEngine.updateLoadingUI("Error loading sound engine", 0);
      }
    }
  }

  return bveSoundEngine;
}

// ===== Station announcement trigger (by distance) =====
let announcementPlayed = false; // ì´ë¯¸ ì¬ìƒí–ˆëŠ”ì§€
let announcementTriggerDist = 500; // í˜„ì¬ ì—´ì°¨ ê¸°ì¤€ ëª©í‘œ ê±°ë¦¬
let announcementArmed = false; // íŠ¸ë¦¬ê±°ê°€ "ë¬´ì¥"ëëŠ”ì§€
let lastRemaining = null; // ì§ì „ remaining_m

function computeAnnouncementTriggerDistForCurrentTrain() {
  const name = (vehicle?.name || getCurrentTrainName() || "").toLowerCase();

  // KTX, N700S ê³„ì—´ì´ë©´ 3000mì—ì„œ
  if (name.includes("ktx") || name.includes("n700s")) {
    return 3000;
  }
  // ë‚˜ë¨¸ì§€ëŠ” 500m
  return 500;
}

// Global keyboard handler: play horn on 'H' press (case-insensitive)
document.addEventListener('keydown', (ev) => {
  try {
    if (!ev || !ev.key) return;
    if (ev.key.toLowerCase() === 'h') {
      if (bveSoundEngine && typeof bveSoundEngine.playHorn === 'function') {
        bveSoundEngine.playHorn();
      } else {
        // Fallback: attempt to play directly via HTMLAudio (best-effort)
        try {
          const layoutKey = window.__currentCabLayoutKey || '';
          const hornPath = (layoutKey == 'n700s' || layoutKey == 'ktx') 
            ? '/static/E233/ExternalData/Sound/Horn/HornD.wav'
            : '/static/E233/ExternalData/Sound/Horn/HornB.wav';
          let a = new Audio(hornPath);
          a.play().catch(() => {});
        } catch (e) {}
      }
      // Prevent other handlers if any
      ev.preventDefault();
    }
  } catch (e) { /* ignore */ }
});

async function playStationMelody() {
  if (!stationMelody) return;

try {
  const name = getCurrentTrainName();
  const lower = (name || "").toLowerCase();

  // ì„œìš¸
  const isSeoulTrain =
    name.includes("ì„œìš¸") || lower.includes("seoul");

  // KTX
  const isKtxTrain =
    name.includes("KTX") ||
    lower.includes("ktx") ||
    name.includes("ì¼€ì´í‹°ì—‘ìŠ¤");

  // N700S (ë…ë¦½)
  const isN700sTrain =
    name.includes("N700S") || lower.includes("n700s");

  // ë„ì¿„(ê¸°ë³¸ê°’)
  const isTokyoTrain =
    !isSeoulTrain && !isKtxTrain && !isN700sTrain;

  // variantKey ê²°ì •
  let variantKey;
  if (isSeoulTrain) variantKey = "seoul";
  else if (isKtxTrain) variantKey = "ktx";
  else if (isN700sTrain) variantKey = "n700s";
  else variantKey = "tokyo";

  // ì˜¤ë””ì˜¤ íŒŒì¼ ê²°ì •
  let desiredSrc;
  if (isSeoulTrain) {
    desiredSrc = "/static/audio/nambu.mp3";
  } else if (isKtxTrain) {
    // 0 ë˜ëŠ” 1ì„ ëœë¤ ìƒì„±
    const random = Math.random() < 0.5;   // 50% í™•ë¥ 

    desiredSrc = random 
      ? "/static/audio/seoul.mp3"
      : "/static/audio/busan.mp3";

  } else if (isN700sTrain) {
    desiredSrc = "/static/audio/shinosaka.mp3"; // â† N700S ì „ìš© ìŒì›
  } else {
    desiredSrc = "/static/audio/Tokyo.mp3";
  }
 
    // If Random mode is enabled and a route CSV provided station names,
    // attempt to play the next-station announcement audio from
    // `/static/audio/<StationName>.mp3` if that file exists. Fall back
    // to the variant chosen above if not present or on error.
    try {
      const rndEl = document.getElementById('rndToggle');
      const useRouteAudio = rndEl && rndEl.checked && window.__routeStationNames && Array.isArray(window.__routeStationNames) && window.__routeStationNames.length > 0;
      if (useRouteAudio) {
        const idx = window.__routeStationNamesIndex || 0;
        const nextIdx = (idx) % window.__routeStationNames.length;
        const nextName = window.__routeStationNames[nextIdx];
        if (nextName) {
          const candidatePath = '/static/audio/' + encodeURIComponent(nextName) + '.mp3';
          try {
            const r = await fetch(candidatePath, { method: 'GET', cache: 'no-store' });
            if (r && r.ok) {
              desiredSrc = candidatePath;
              variantKey = `station-${nextName}`;
            }
          } catch (e) {
            // ignore fetch errors and keep default desiredSrc
          }
        }
      }
    } catch (e) {
      // non-fatal
    }

    // í•„ìš”í•  ë•Œë§Œ src ë³€ê²½ (ë¶ˆí•„ìš”í•œ ì¬ë¡œë”© ë°©ì§€)
    if (stationMelody._variantKey !== variantKey) {
      stationMelody.pause();
      stationMelody.currentTime = 0;
      stationMelody.src = desiredSrc;
      stationMelody._variantKey = variantKey;
    }

    // í•­ìƒ ì™„ì „ ì´ˆê¸°í™”
    stationMelody.pause();
    stationMelody.currentTime = 0;
    stationMelody.loop = false;

    // ê¸°ì¡´ í•¸ë“¤ëŸ¬ ì œê±°
    if (stationMelody._endedHandler) {
      try {
        stationMelody.removeEventListener("ended", stationMelody._endedHandler);
      } catch (e) {}
      stationMelody._endedHandler = null;
    }

    // ì•ˆì „í•˜ê²Œ í•œ ë²ˆë§Œ ì¬ìƒ
    stationMelody.play().catch(err => {
      console.debug("stationMelody play failed:", err);
    });
  } catch (e) {
    console.debug("playStationMelody error", e);
  }
}

const weatherSelect=document.getElementById("weatherSelect"),
      snowflakes=document.querySelector(".snowflakes"),
      raindrops=document.querySelector(".raindrops");
      timeOfDaySelect=document.getElementById("timeOfDaySelect");

function resize(){ canvas.width=canvas.clientWidth*devicePixelRatio; canvas.height=canvas.clientHeight*devicePixelRatio; } 
addEventListener("resize",resize); resize();

function getEbIdx(){
  const acc = (vehicle && Array.isArray(vehicle.notch_accels)) ? vehicle.notch_accels : null;
  const n   = acc ? acc.length : (vehicle && Number.isInteger(vehicle.notches) ? vehicle.notches : 10);
  return Math.max(1, n - 1); // 0:N, 1..EB-1:B..., EB:ë§ˆì§€ë§‰
}
function sendCmd(name, delta){
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({type:"cmd", payload:{name, delta}}));
  }
}


function getEbIndex() {
  // vehicle.notchesê°€ ì„œë²„ì—ì„œ ì‚¬ìš©í•˜ëŠ” "ìµœëŒ€ ë¸Œë ˆì´í¬ notch + 1"ì´ë¼ê³  ê°€ì •
  // (0=N, 1..EB-1=B1.., EB=notches-1)
  if (vehicle && Number.isInteger(vehicle.notches)) {
    return Math.max(1, vehicle.notches - 1);
  }
  // fallback: notch_accels ê¸¸ì´
  if (vehicle && Array.isArray(vehicle.notch_accels)) {
    return Math.max(1, vehicle.notch_accels.length - 1);
  }
  return 9; // ê¸°ë³¸ê°’
}

/* ===== í¸ì„± & íƒ‘ìŠ¹ë¥  ===== */
function updateTrainLength(){
  const L = document.getElementById("trainLength").value;
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "cmd", payload: { name: "setTrainLength", length: L } }));
  }
  sendLoadRate();
  // refresh platform sign textures so the 0m sign shows the selected formation immediately
  try { if (window.__refreshPlatformSignTextures) window.__refreshPlatformSignTextures(); } catch(e){}
}
function sendLoadRate(){
  const loadRate = parseFloat(document.getElementById("inputLoadRate").value) || 0;
  let trainLength = parseInt(document.getElementById("trainLength").value, 10);
  if (Number.isNaN(trainLength)) trainLength = 8;
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "cmd", payload: { name: "setLoadRate", loadRate, length: trainLength }}));
  }
}

/* ===== ì…ë ¥ ë³´ì • & ì œí•œ ===== */
const inputSpeed=document.getElementById("inputSpeed"),
      inputDist=document.getElementById("inputDist"),
      inputGrade=document.getElementById("inputGrade"),
      inputLoadRate=document.getElementById("inputLoadRate");

const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));
function enforceInt(el,min,max){ el.addEventListener('input',()=>{ el.value=el.value.replace(/[^\d-]/g,'');}); el.addEventListener('change',()=>{let v=parseInt(el.value,10); if(isNaN(v)){el.value='';return;} el.value=String(clamp(v,min,max));});}
function enforceFloat(el,min,max,d=1){ el.addEventListener('input',()=>{ el.value=el.value.replace(/[^0-9.\-]/g,'');}); el.addEventListener('change',()=>{let v=parseFloat(el.value); if(isNaN(v)){el.value='';return;} v=clamp(v,min,max); el.value=v.toFixed(d);});}

/*  ë²”ìœ„ ê°±ì‹ : ì†ë„ 40~130 / ê±°ë¦¬ 150~900 */
enforceInt(inputSpeed,0,300);
enforceInt(inputDist,150,60000);
enforceInt(inputLoadRate,0,120);
enforceFloat(inputGrade,-10,10,1);

/*  ì†ë„ë³„ ìµœì†Œ ê±°ë¦¬ ê·œì¹™ */
function minDistForSpeed(v) {
  if (v >= 240) return 6000;
  if (v >= 200) return 5000;
  if (v >= 180) return 3000;
  if (v >= 160) return 2500;
  if (v >= 140) return 2000;
  if (v >= 130) return 1500;
  if (v >= 120) return 1200;
  if (v >= 110) return 1000;
  if (v >= 100) return 800;
  if (v >= 90)  return 500;
  if (v >= 80)  return 400;
  if (v >= 70)  return 300;
  if (v >= 60)  return 250;
  if (v >= 50)  return 200;
  return 150; // v >= 40
}
function showHint(msg) {
  fb.innerHTML = `<div class="warn">${msg}</div>`;
  setTimeout(() => {
    if (!st || !st.finished) fb.textContent = "Spaceë¡œ ì‹œì‘. W/Së¡œ ë¸Œë ˆì´í¬ ì¡°ì ˆí•˜ì„¸ìš”.";
  }, 1200);
}
function applySpeedDistanceRule() {
  let v = Number(inputSpeed.value || 0);
  v = Math.max(0, v);
  const requiredMin = minDistForSpeed(v);
  let d = Number(inputDist.value || 0);
  const absoluteMin = 150, absoluteMax = 60000;
  const newMin = Math.max(absoluteMin, requiredMin);

  inputDist.min = String(newMin);

  if (isNaN(d) || d < newMin) {
    inputDist.value = String(newMin);
    showHint(`ì†ë„ ${v} km/hì—ì„œëŠ” ìµœì†Œ ê±°ë¦¬ ${newMin} m ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.`);
  } else if (d > absoluteMax) {
    inputDist.value = String(absoluteMax);
  }
}
inputSpeed.addEventListener('change', applySpeedDistanceRule);
inputSpeed.addEventListener('input',  () => {
  const v = Number(inputSpeed.value || 0);
  const minD = minDistForSpeed(Math.min(130, Math.max(0, v)));
  inputDist.min = Math.max(150, minD);
});
inputLoadRate.addEventListener('change', sendLoadRate);
inputLoadRate.addEventListener('input', () => {
  // ì…ë ¥ ì¤‘ ì¦‰ì‹œ ë°˜ì˜ì„ ì›í•˜ë©´ ìœ ì§€, ë„ˆë¬´ ì‹œë„ëŸ¬ìš°ë©´ ì´ ì¤„ì€ ë¹¼ì„¸ìš”.
  sendLoadRate();
});
/* ===== ë‚ ì”¨ UI ===== */
function muFromWeather(w){return w==="ë¹„ì˜´"?0.6:(w==="ëˆˆì˜´"?0.3:1.0)}
function updateWeatherUI(){
  const w = weatherSelect.value, ov = document.getElementById("overlay");
  // Keep page-level background styling controlled by CSS by default.
  if (w === "ëˆˆì˜´") {
    // show snowflakes but keep overlay/canvas dark for readable text
    snowflakes.style.display = "block";
    raindrops.style.display = "none";
    // clear any inline global background overrides
    document.documentElement.style.background = '';
    document.body.style.background = '';
    // add snow theme class so CSS can switch card/text colors to dark-on-light
    try { document.body.classList.add('weather-snow'); } catch(e){}
    // switch overlay to a light panel (page background is white in snow mode)
    ov.style.background = "rgba(255,255,255,0.92)";
    try { ov.style.backdropFilter = 'blur(6px)'; } catch(e){}
    canvas.style.background = "linear-gradient(#0b0f14,#0a1019)";
  } else if (w === "ë¹„ì˜´") {
    snowflakes.style.display = "none";
    raindrops.style.display = "block";
    // remove snow theme if previously applied
    try { document.body.classList.remove('weather-snow'); } catch(e){}
    document.documentElement.style.background = "#4b5d67";
    document.body.style.background = "#4b5d67";
    ov.style.background = "rgba(40,60,80,.35)";
    canvas.style.background = "#4b5d67";
  } else {
    snowflakes.style.display = "none";
    raindrops.style.display = "none";
    try { document.body.classList.remove('weather-snow'); } catch(e){}
    const g = "radial-gradient(circle at 50% 20%, #0b0f14, #05070a)";
    document.documentElement.style.background = g;
    document.body.style.background = g;
    ov.style.background = "rgba(0,0,0,.6)";
    canvas.style.background = "linear-gradient(#0b0f14,#0a1019)";
  }
}
weatherSelect.addEventListener("change",()=>{updateWeatherUI();const mu=muFromWeather(weatherSelect.value); if(ws.readyState===WebSocket.OPEN){ws.send(JSON.stringify({type:"cmd",payload:{name:"setMu",value:mu}}));}});
updateWeatherUI();

// ğŸ‘‡ ìƒˆë¡œ ì¶”ê°€: day/night ë³€ê²½ ì‹œ three.jsì— ì „ë‹¬
if (timeOfDaySelect) {
  timeOfDaySelect.addEventListener("change", () => {
    if (window.setTimeOfDay) {
      window.setTimeOfDay(timeOfDaySelect.value);
    }
  });
}

// ===== Random start helpers =====
function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }
function randFloat(min, max, step=0.1){
  const n = Math.round((Math.random()*(max-min)+min)/step)*step;
  return Number(n.toFixed(String(step).split('.')[1]?.length || 0));
}
function pickWeather(){
  const r = Math.random();
  if (r < 0.60) return "ë§‘ìŒ";
  if (r < 0.85) return "ë¹„ì˜´";
  return "ëˆˆì˜´";
}

/** ì…ë ¥ì¹¸ì„ ë¬´ì‘ìœ„ë¡œ ì±„ìš°ê³  change ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œì¼œ UI/ê²€ì¦ì„ ë™ê¸°í™” */
function randomizeInputs(){
  // 1) ì†ë„
  // Drive Mode ì‹œì‘ ì‹œì—ëŠ” ì„ì˜ì˜ ì£¼í–‰ì†ë„ê°€ ì•„ë‹Œ ì •ì§€(0 km/h)ë¡œ ì‹œì‘í•˜ë„ë¡ ë³€ê²½
  // ì‹¤ì œ EB ì ìš©ì€ ëŸ° ì‹œì‘ ì§í›„ì— ì²˜ë¦¬ë˜ë„ë¡ í”Œë˜ê·¸ë¥¼ ì„¸íŒ…
  inputSpeed.value = "0";
  window.__rndStartForceEB = true;

  // 2) ê±°ë¦¬: 1000~2000m ë²”ìœ„ë¡œ ëœë¤
  // If a route CSV was loaded for this vehicle, use the next distance sequentially.
  if (window.__routeDistances && Array.isArray(window.__routeDistances) && window.__routeDistances.length > 0) {
    const idx = window.__routeDistancesIndex || 0;
    const d = window.__routeDistances[idx % window.__routeDistances.length];
    inputDist.value = String(Math.max(150, Math.min(60000, Math.round(d))));
    window.__routeDistancesIndex = (idx + 1) % window.__routeDistances.length;
  } else {
    const d = randInt(1000, 2000);
    inputDist.value = String(d);
  }

  // Prepare pending travel/depart for later setup after clock init
  if (window.__routeTravelTimes && Array.isArray(window.__routeTravelTimes) && window.__routeTravelTimes.length > 0) {
    const ti = window.__routeTravelTimesIndex || 0;
    window.__routePendingTravelTimesIndex = ti;
    window.__routeTravelTimesIndex = (ti + 1) % window.__routeTravelTimes.length;
    // Also increment station names index
    if (window.__routeStationNames && Array.isArray(window.__routeStationNames)) {
      window.__routeStationNamesIndex = ((window.__routeStationNamesIndex || 0) + 1) % window.__routeStationNames.length;
    }
    // Also increment ATS index
    if (window.__routeAtsValues && Array.isArray(window.__routeAtsValues)) {
      window.__routeAtsIndex = ((window.__routeAtsIndex || 0) + 1) % window.__routeAtsValues.length;
    }
    window.__miniTimerIsRoute = true;
  } else {
    window.__routePendingTravelTimesIndex = null;
    window.__miniTimerIsRoute = false;
  }

  // 3) êµ¬ë°°(â€°)
  const g = randFloat(-5, 5, 0.1);
  inputGrade.value = String(g.toFixed(1));

  // 4) ë‚ ì”¨
  const w = pickWeather();
  weatherSelect.value = w;
  updateWeatherUI(); // ë°°ê²½/ì´í™íŠ¸ ë™ê¸°í™”

  // 5) íƒ‘ìŠ¹ë¥ (%)
  const load = randInt(20, 120);
  inputLoadRate.value = String(load);

  // ë””ìŠ¤íŒ¨ì¹˜: ê¸°ì¡´ ê²€ì¦/í•˜ìœ„ ë¡œì§ì„ ê·¸ëŒ€ë¡œ íƒ€ê²Œ í•¨
  inputSpeed.dispatchEvent(new Event('change'));
  inputDist.dispatchEvent(new Event('change'));
  inputGrade.dispatchEvent(new Event('change'));
  inputLoadRate.dispatchEvent(new Event('change'));

// íŒíŠ¸(ì„ íƒ)
if (fb) {
  fb.innerHTML = `<div class="ok">ëœë¤ ì‹œì‘ê°’: ë‚ ì”¨=${w}, íƒ‘ìŠ¹ë¥ =${load}%</div>`;
  
  // í‘œì‹œí•œ ì‹œê°„ ì €ì¥
  fb.dataset.lastUpdate = Date.now();
  
  setTimeout(() => {
    const now = Date.now();
    const last = Number(fb.dataset.lastUpdate);

    // 3ì´ˆê°€ ì§€ë‚¬ëŠ”ì§€ í™•ì¸ (3000ms)
    if (now - last >= 5000) {
      fb.textContent = "Spaceë¡œ ì‹œì‘. W/Së¡œ ë¸Œë ˆì´í¬ ì¡°ì ˆí•˜ì„¸ìš”.";
      fb.dataset.lastUpdate = Date.now(); // ì—…ë°ì´íŠ¸ ì‹œê°„ ê°±ì‹ 
    }
  }, 5000);
}

// Advance to next station without resetting the whole scene (client side)
window.continueToNextStation = function() {
  try {
    // Close the overlay and any popups
    hideScoreOverlay();
    hideObstaclePopups();

    // Play door close once (best-effort). Prefer bveSoundEngine if available.
    try {
      if (bveSoundEngine && typeof bveSoundEngine.playDoorClose === 'function') {
        bveSoundEngine.playDoorClose();
      } else if (bveSoundEngine && typeof bveSoundEngine.playDoorSound === 'function') {
        bveSoundEngine.playDoorSound();
      } else {
        const layoutKey = window.__currentCabLayoutKey || '';
        const doorPath = (layoutKey == 's3000')
          ? '/static/E233/OriginalData/Sound/Door/korail_doorclose.wav'
          : '/static/E233/OriginalData/Sound/Door/DoorClose1.wav';
        const doorAudio = new Audio(doorPath);
        doorAudio.play().catch(()=>{});
      }
    } catch (e) {
      try { const doorAudio = new Audio('/static/E233/OriginalData/Sound/Door/DoorClose1.wav'); doorAudio.play().catch(()=>{}); } catch(e){}
    }

    // If Random Scenario is enabled, randomize inputs (reuse existing logic)
    const rndEl = document.getElementById('rndToggle');
    if (rndEl && rndEl.checked) {
      randomizeInputs();
      // Also set up pending travel/depart for next station (will be finalized when clock init runs)
      // The pending values will be loaded when the server sends the next state
    }

    // Reset announcement state so it can be triggered again on next run
    try {
      announcementPlayed = false;
      announcementArmed = false;
      lastRemaining = null;
      announcementTriggerDist = computeAnnouncementTriggerDistForCurrentTrain();
      if (stationMelody) {
        try { stationMelody.pause(); } catch (e) {}
        try { stationMelody.currentTime = 0; } catch (e) {}
        try { stationMelody.src = ''; } catch (e) {}
        try { stationMelody._variantKey = null; } catch (e) {}
        try { if (stationMelody._endedHandler) { stationMelody.removeEventListener('ended', stationMelody._endedHandler); stationMelody._endedHandler = null; } } catch (e) {}
      }
    } catch (e) { /* non-fatal */ }

    // Prepare parameters and send advanceStation command to server
    const dist = Number(inputDist.value) || 600;
    const grade = Number(inputGrade.value) || 0.0;
    const mu = muFromWeather(weatherSelect.value);

    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: 'cmd', payload: { name: 'advanceStation', dist: dist, grade: grade, mu: mu } }));
    }

    // If previous run overran and requested EB on next start, apply EB now
    try {
      if (window.__forceNextStartEB) {
        try { sendCmd("emergencyBrake", 0); } catch (e) { console.debug('continueToNextStation: force EB sendCmd failed', e); }
        window.__forceNextStartEB = false;
        console.debug('continueToNextStation: applied forced EB for next run');
      }
    } catch (e) { console.debug('continueToNextStation: force EB apply error', e); }

    // Hide overlay and mark that we're no longer showing results
    try { overlay.classList.add('hide'); } catch (e) {}
    overlayShowingResult = false;

    // Clear any emergency obstacle state for new run
    try { clearEmergencyObstacle(); } catch (e) {}
    
    // Load pending travel time values for new run (similar to startRun's clock init)
    try {
      if (window.__routePendingTravelTimesIndex != null && window.__routeTravelTimes && Array.isArray(window.__routeTravelTimes)) {
        const ti = window.__routePendingTravelTimesIndex;
        const tsec = window.__routeTravelTimes[ti % window.__routeTravelTimes.length];
        window.__routePendingTravelSec = Math.max(0, Math.round(Number(tsec) || 0));
        if (window.__routeDepartures && Array.isArray(window.__routeDepartures) && window.__routeDepartures.length > 0) {
          const dep = window.__routeDepartures[ti % window.__routeDepartures.length];
          window.__routePendingDepart = dep || null;
        } else {
          window.__routePendingDepart = null;
        }
        console.debug('next station loaded: ti=', ti, 'travelSec=', window.__routePendingTravelSec, 'depart=', window.__routePendingDepart);
        
        // Check if this is the terminal station (end=1)
        try {
          if (window.__routeEndFlags && Array.isArray(window.__routeEndFlags)) {
            const endFlagIdx = ti % window.__routeEndFlags.length;
            const isTerminal = window.__routeEndFlags[endFlagIdx] === 1;
            if (isTerminal) {
              console.debug('Final destination reached -> reloading page');
              // Wait a moment for door close sound to play, then reload
              setTimeout(() => {
                window.location.reload();
              }, 1500);
              return; // Exit early since we're about to reload
            }
          }
        } catch (e) { console.debug('end flag check error', e); }
        
        // Show static travel time in miniTimer
        const miniTimer = document.getElementById('miniTimer');
        try {
          // Ensure any previous countdown is stopped so it doesn't overwrite the new static value
          try {
            if (window.__miniTimerCountdownInterval) { clearInterval(window.__miniTimerCountdownInterval); window.__miniTimerCountdownInterval = null; }
          } catch (e) { /* non-fatal */ }

          // Reset remaining tracker
          window.__miniTimerRemaining = null;

          if (typeof formatTimeSec === 'function') {
            const s = window.__routePendingTravelSec;
            if (miniTimer) {
              miniTimer.innerHTML = formatTimeSec(s);
              miniTimer.classList.remove('late'); // Reset red color for new run
            }
          }
        } catch (e) { if (miniTimer) miniTimer.textContent = `${window.__routePendingTravelSec}s`; }
      }
    } catch(e) { console.debug('pending setup in continueToNextStation error', e); }

    // Give a small feedback message
    if (fb) {
      // Check if terminal was reached
      const isTerminalReach = window.__routeEndFlags && Array.isArray(window.__routeEndFlags) && 
                              window.__routePendingTravelTimesIndex != null &&
                              window.__routeEndFlags[window.__routePendingTravelTimesIndex % window.__routeEndFlags.length] === 1;
      if (isTerminalReach) {
        fb.innerHTML = `<div class="ok">ì¢…ì°©ì—­ ë„ì°© â€” í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨í•©ë‹ˆë‹¤</div>`;
      } else {
        fb.innerHTML = `<div class="ok">ë‹¤ìŒ ì—­ìœ¼ë¡œ ì§„í–‰í•©ë‹ˆë‹¤ â€” ë¬¸ ë‹«í˜</div>`;
        setTimeout(()=>{ if (fb) fb.textContent = "Spaceë¡œ ì‹œì‘. W/Së¡œ ë¸Œë ˆì´í¬ ì¡°ì ˆí•˜ì„¸ìš”."; }, 2000);
      }
    }
  } catch (e) {
    console.debug('continueToNextStation error', e);
  }
}

}

/* ===== ì‹œì‘/ì¬ì‹œì‘ ===== */
async function startRun(){
  // Determine whether audio is already loaded. If so, skip loading screen.
  const alreadyLoaded = (typeof bveSoundEngine === 'object' && bveSoundEngine && Object.keys(bveSoundEngine.wavBuffers || {}).length > 0);

  // Hide the main overlay immediately so game UI is visible while loading or starting
  try { const overlay = document.getElementById('overlay'); if (overlay && !overlay.classList.contains('hide')) overlay.classList.add('hide'); } catch(e) {}

  if (!alreadyLoaded) {
    // Show loading screen when user starts (only if audio not yet loaded)
    try {
      const loading = document.getElementById('bveLoadingScreen');
      const statusEl = document.getElementById('bveLoadStatus');
      const percentEl = document.getElementById('bveLoadPercent');
      if (loading) {
        loading.style.display = 'flex';
        loading.style.opacity = '1';
      }
      if (statusEl) statusEl.textContent = 'Preparing...';
      if (percentEl) percentEl.textContent = '0';
    } catch (e) {}

    // ì˜¤ë””ì˜¤ ì •ì±… í•´ì œ & BVE ì¤€ë¹„
    const trainType = (vehicle && vehicle.name) ? vehicle.name : '';
    await initializeBveEngine(trainType).catch(err => console.debug("BVE init error:", err));
  } else {
    // If audio already loaded, ensure AudioContext resumed and skip showing loading screen
    try { if (bveCtx && bveCtx.state === 'suspended') await bveCtx.resume(); } catch (e) { console.debug('BVE: resume error', e); }
  }

  //  ìƒˆ ëŸ° ì‹œì‘í•  ë•Œ ì¥ì• ë¬¼ í”Œë˜ê·¸ ë¦¬ì…‹
  hazardInfo.active = false;
  hazardInfo.dist = null;
  hazardInfo.handled = false;
  hazardInfo.timeoutId = null;
  hazardInfo.success = false;

  //  ìƒˆ ëŸ° ì‹œì‘í•  ë•Œ ì¥ì• ë¬¼ ìƒíƒœ / íŒì—… ì™„ì „ ë¦¬ì…‹
  hideObstaclePopups(); // í˜¹ì‹œ ë‚¨ì•„ìˆëŠ” íŒì—… ë‹«ê¸°
  if (window.clearEmergencyObstacle) {
    try { clearEmergencyObstacle(); } catch (e) {}
  } else {
    resetHazardState();
  }

  // ì•ˆë‚´ë°©ì†¡ ìƒíƒœ ë¦¬ì…‹
  announcementPlayed = false;
  announcementArmed = false;
  lastRemaining = null;
  announcementTriggerDist = computeAnnouncementTriggerDistForCurrentTrain();

  // Reset stationMelody element so announcements can be retriggered in subsequent runs
  try {
    if (stationMelody) {
      try { stationMelody.pause(); } catch (e) {}
      try { stationMelody.currentTime = 0; } catch (e) {}
      try { stationMelody.src = ''; } catch (e) {}
      try { stationMelody._variantKey = null; } catch (e) {}
      try { if (stationMelody._endedHandler) { stationMelody.removeEventListener('ended', stationMelody._endedHandler); stationMelody._endedHandler = null; } } catch (e) {}
    }
  } catch (e) { /* non-fatal */ }

  
  //  ìƒˆ ëŸ° ì‹œì‘í•  ë•Œ ì ìˆ˜ ì˜¤ë²„ë ˆì´ ìˆ¨ê¸°ê¸°
  hideScoreOverlay();

    //  ëœë¤ í† ê¸€ì´ ì¼œì ¸ ìˆë‹¤ë©´ ê°’ ë¨¼ì € ì„ê¸°
  const rndEl = document.getElementById('rndToggle');
  if (rndEl && rndEl.checked) {
    randomizeInputs();
  }
  inputSpeed.dispatchEvent(new Event('change'));
  inputDist.dispatchEvent(new Event('change'));
  inputGrade.dispatchEvent(new Event('change'));

  applySpeedDistanceRule();

  const speed=Number(inputSpeed.value),
        dist=Number(inputDist.value),
        grade=Number(inputGrade.value),
        mu=muFromWeather(weatherSelect.value);

        //  ëœë¤ ëª¨ë“œì—ì„œë§Œ 10% í™•ë¥ ë¡œ ë¹„ìƒ ì¥ì• ë¬¼ ìƒì„±
  if (rndEl && rndEl.checked && window.maybeSpawnEmergencyObstacle) {
    window.maybeSpawnEmergencyObstacle(dist);
  } else if (window.clearEmergencyObstacle) {
    // ëœë¤ í† ê¸€ êº¼ì ¸ ìˆì„ ë• ì´ì „ ì¥ì• ë¬¼ ì œê±°
    window.clearEmergencyObstacle();
  }

  if(ws.readyState===WebSocket.OPEN){
const enabled = document.getElementById("tascToggle").checked;
const rndEl = document.getElementById('rndToggle');
const random_mode = !!(rndEl && rndEl.checked);
  if (!random_mode) window.__miniTimerIsRoute = false;
    // ìƒˆ ëŸ° ì‹œì‘í•  ë•Œ miniTimer ê´€ë ¨ ë³€ìˆ˜ ì´ˆê¸°í™”
    window.__miniTimerRemaining = null;
    if (!random_mode) {
      window.__routePendingTravelSec = null;
      window.__routePendingDepart = null;
      window.__routePendingTravelTimesIndex = null;
      if (window.__miniTimerCountdownInterval) { clearInterval(window.__miniTimerCountdownInterval); window.__miniTimerCountdownInterval = null; }
    }
    ws.send(JSON.stringify({ type:"cmd", payload:{ name:"toggleTimer", enabled:true }}));
    ws.send(JSON.stringify({type:"cmd",payload:{name:"setInitial",speed,dist,grade,mu,random_mode}}));
    ws.send(JSON.stringify({type:"cmd",payload:{name:"start"}}));
    // ëœë¤(Drive) ëª¨ë“œì—ì„œ ì‹œì‘ ì‹œ EB(ë¹„ìƒì œë™)ë¥¼ ê°•ì œ ì ìš©
    try{
      if (random_mode && window.__rndStartForceEB) {
        // sendCmdì„ ì‚¬ìš©í•˜ë©´ ws ì—°ê²° ì—¬ë¶€ë¥¼ ìì²´ ì²´í¬í•¨
        sendCmd("emergencyBrake", 0);
        window.__rndStartForceEB = false;
      }
      // If a general force-EB flag was set (e.g., previous run overran), apply EB regardless of random mode
      if (window.__forceNextStartEB) {
        try { sendCmd("emergencyBrake", 0); } catch (e) { console.debug('forceNextStartEB sendCmd failed', e); }
        window.__forceNextStartEB = false;
      }
    }catch(e){console.debug('force EB failed', e);}    
    // mini HUD ì‹œê³„ ì´ˆê¸°í™”/ì‹œì‘ (CSVì˜ arrival time ì²« ê°’ì„ ì‚¬ìš©)
    try{
      if (window.__miniHudClockInterval) { clearInterval(window.__miniHudClockInterval); window.__miniHudClockInterval = null; }
      // Reset departure bell flag for this new run
      window.__firstDepartureBellPlayed = false;
      // Reset ATS overspeed protection for this new run
      resetOverspeedProtection();
      if (random_mode && window.__routeClockStart) {
        const hhmmss = window.__routeClockStart;
        function parseToSec(s){
          const m = String(s).trim().match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
          if(!m) return null;
          const hh = parseInt(m[1],10); const mm = parseInt(m[2],10); const ss = parseInt(m[3]||'0',10);
          return ((hh%24)*3600 + mm*60 + ss);
        }
        function fmt(sec){
          sec = ((sec%86400)+86400)%86400;
          const hh = Math.floor(sec/3600); const mm = Math.floor((sec%3600)/60); const ss = sec%60;
          return `${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
        }
        const startSec = parseToSec(hhmmss);
        if (startSec !== null) {
          window.__miniHudClockCurrent = startSec;
          if (miniClock) miniClock.textContent = fmt(window.__miniHudClockCurrent);
          // Now set up pending travel/depart after clock is initialized
          try {
            if (window.__routePendingTravelTimesIndex != null && window.__routeTravelTimes && Array.isArray(window.__routeTravelTimes)) {
              const ti = window.__routePendingTravelTimesIndex;
              const tsec = window.__routeTravelTimes[ti % window.__routeTravelTimes.length];
              window.__routePendingTravelSec = Math.max(0, Math.round(Number(tsec) || 0));
              if (window.__routeDepartures && Array.isArray(window.__routeDepartures) && window.__routeDepartures.length > 0) {
                const dep = window.__routeDepartures[ti % window.__routeDepartures.length];
                window.__routePendingDepart = dep || null;
              } else {
                window.__routePendingDepart = null;
              }
              console.debug('mini clock setup: ti=', ti, 'travelSec=', window.__routePendingTravelSec, 'depart=', window.__routePendingDepart);
              // Show static travel time in miniTimer
              try {
                if (typeof formatTimeSec === 'function') {
                  const s = window.__routePendingTravelSec;
                  if (miniTimer) {
                    miniTimer.innerHTML = formatTimeSec(s);
                    miniTimer.classList.remove('late'); // Reset red color for new run
                  }
                } else {
                  if (miniTimer) {
                    miniTimer.textContent = `${window.__routePendingTravelSec}s`;
                    miniTimer.classList.remove('late');
                  }
                }
              } catch (e) { if (miniTimer) miniTimer.textContent = `${window.__routePendingTravelSec}s`; }
            } else {
              window.__routePendingTravelSec = null;
              window.__routePendingDepart = null;
              console.debug('mini clock setup: no pending index or travel times');
            }
          } catch(e) { console.debug('pending setup error', e); }
          // Immediate check: if current clock >= pending departure, start countdown immediately
          try {
            const curFmt0 = fmt(window.__miniHudClockCurrent);
            const parseToSecLocal = (s) => {
              const m = String(s).trim().match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
              if(!m) return null;
              const hh = parseInt(m[1],10); const mm = parseInt(m[2],10); const ss = parseInt(m[3]||'0',10);
              return ((hh%24)*3600 + mm*60 + ss);
            };
            console.debug('immediate trigger check: curFmt=', curFmt0, 'pending depart=', window.__routePendingDepart, 'travel=', window.__routePendingTravelSec);
            if (window.__routePendingDepart && window.__routePendingTravelSec != null && !window.__miniTimerCountdownInterval) {
              const curSec = window.__miniHudClockCurrent;
              const departSec = parseToSecLocal(window.__routePendingDepart);
              if (departSec != null && curSec >= departSec) {
                // Clock has reached or passed departure time
                const timePassed = curSec - departSec;
                let remaining = Number(window.__routePendingTravelSec) || 0;
                remaining = remaining - timePassed; // Subtract already-passed time
                console.debug('IMMEDIATE TRIGGER: clock has passed departure. timePassed=', timePassed, 'remaining=', remaining);
                try { 
                  if (miniTimer) {
                    miniTimer.innerHTML = formatTimeSec(remaining);
                    miniTimer.classList.toggle('late', remaining < 0);
                  }
                } catch(e){ if (miniTimer) miniTimer.textContent = String(remaining) + 's'; }
                window.__miniTimerCountdownInterval = setInterval(()=>{
                  if (gamePaused) return;
                  remaining = remaining - 1;
                  window.__miniTimerRemaining = remaining; // Track remaining time for scoring
                  try { 
                    if (miniTimer) {
                      miniTimer.innerHTML = formatTimeSec(remaining);
                      miniTimer.classList.toggle('late', remaining < 0);
                    }
                  } catch(e){ if (miniTimer) miniTimer.textContent = String(remaining) + 's'; }
                }, 1000);
              }
            }
          } catch(e) { console.debug('countdown trigger error', e); }
          window.__miniHudClockInterval = setInterval(()=>{
            if (gamePaused) return;
            const curFmt = fmt(window.__miniHudClockCurrent);
            try { if (miniClock) miniClock.textContent = curFmt; } catch(e){}

            // ğŸ”” Check for departure bell: play only once at the first station's departure time
            try {
              const rndEl = document.getElementById('rndToggle');
              const isRandomMode = rndEl && rndEl.checked;
              if (isRandomMode && window.__routeDepartures && Array.isArray(window.__routeDepartures) && !window.__firstDepartureBellPlayed) {
                const curSec = window.__miniHudClockCurrent;
                const curTime = fmt(curSec);
                const firstDepTime = window.__routeDepartures[0];
                if (firstDepTime && firstDepTime === curTime) {
                  window.__firstDepartureBellPlayed = true;
                  console.debug('Playing departure bell at first station:', curTime);
                  playDepartureBell();
                }
              }
            } catch(e) { console.debug('departure bell check error', e); }

            // If there's a pending route departure/time, start the miniTimer countdown when clock >= departure
            try {
              if (window.__routePendingDepart && window.__routePendingTravelSec != null && !window.__miniTimerCountdownInterval) {
                const parseToSecLocal = (s) => {
                  const m = String(s).trim().match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
                  if(!m) return null;
                  const hh = parseInt(m[1],10); const mm = parseInt(m[2],10); const ss = parseInt(m[3]||'0',10);
                  return ((hh%24)*3600 + mm*60 + ss);
                };
                const curSec = window.__miniHudClockCurrent;
                const departSec = parseToSecLocal(window.__routePendingDepart);
                if (departSec != null && curSec >= departSec) {
                  // Clock has reached or passed departure time
                  const timePassed = curSec - departSec;
                  let remaining = Number(window.__routePendingTravelSec) || 0;
                  remaining = remaining - timePassed; // Subtract already-passed time
                  console.debug('INTERVAL TRIGGER: clock has reached departure. timePassed=', timePassed, 'remaining=', remaining);
                  try { 
                    if (miniTimer) {
                      miniTimer.innerHTML = formatTimeSec(remaining);
                      miniTimer.classList.toggle('late', remaining < 0);
                    }
                  } catch(e){ if (miniTimer) miniTimer.textContent = String(remaining) + 's'; }
                  window.__miniTimerCountdownInterval = setInterval(()=>{
                    if (gamePaused) return;
                    remaining = remaining - 1;
                    window.__miniTimerRemaining = remaining; // Track remaining time for scoring
                    try { 
                      if (miniTimer) {
                        miniTimer.innerHTML = formatTimeSec(remaining);
                        miniTimer.classList.toggle('late', remaining < 0);
                      }
                    } catch(e){ if (miniTimer) miniTimer.textContent = String(remaining) + 's'; }
                  }, 1000);
                }
              }
            } catch(e) { console.debug('mini timer trigger error', e); }

            window.__miniHudClockCurrent++;
          }, 1000);
        } else {
          if (miniClock) miniClock.textContent = '--:--:--';
        }
      } else {
        if (miniClock) miniClock.textContent = '--:--:--';
      }
    }catch(e){console.debug('mini clock start failed', e);}    
  }
  overlay.classList.add("hide"); isFinished=false; overlayShowingResult=false;
  btnMobileRestart.classList.add("hide");
  // play station melody on start (if available)
  // try{ playStationMelody(2); }catch(e){}
}
btnStart.addEventListener("click", startRun);

// ìë™ í—ˆìš©: ì‚¬ìš©ìê°€ Startë¥¼ ëˆ„ë¥´ê±°ë‚˜ í™”ë©´ì„ ì²˜ìŒ ëˆ„ë¥´ë©´ ì˜¤ë””ì˜¤ ì¬ìƒ ê¶Œí•œì„ í™œì„±í™”
try {
  // Start ë²„íŠ¼ í´ë¦­ ì‹œ(ì‹¬ì§€ì–´ í‚¤ë³´ë“œ Spaceë¡œ ì‹œì‘í•  ë•Œë„) í—ˆìš©
  btnStart.addEventListener('click', _enableZeroNoiseOnUserGesture, { once: true });
} catch (e) {}

// ì²« ë²ˆì§¸ í¬ì¸í„° ìƒí˜¸ì‘ìš©(í´ë¦­/í„°ì¹˜ ë“±)ì—ì„œë„ ì˜¤ë””ì˜¤ë¥¼ í™œì„±í™” (ë³„ë„ ë²„íŠ¼ ì—†ì´ ë™ì‘)
try {
  document.addEventListener('pointerdown', _enableZeroNoiseOnUserGesture, { once: true });
} catch (e) {}

// ì²« ë²ˆì§¸ í‚¤ë³´ë“œ ì…ë ¥ìœ¼ë¡œë„ ì˜¤ë””ì˜¤ í™œì„±í™” (ì…ë ¥ í¼ ë“±ì—ì„œì˜ í‚¤ ì…ë ¥ì€ ì œì™¸)
try {
  document.addEventListener('keydown', function _kbdEnableForAudio(e){
    try {
      const tag = (e.target && e.target.tagName) ? e.target.tagName.toUpperCase() : null;
      if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || tag === 'OPTION') return;
      _enableZeroNoiseOnUserGesture();
    } catch (err) {}
  }, { once: true });
} catch (e) {}

/* ì¬ì‹œì‘ FAB */
const btnMobileRestart=document.getElementById("btnMobileRestart");
btnMobileRestart.addEventListener("click", ()=>{
  if(!overlay.classList.contains("hide")) overlay.classList.add("hide");
  overlay.classList.remove("hide");
  overlayShowingResult=true;
  btnMobileRestart.classList.add("hide");
});

/* ===== ATS DEPARTURE BELL TRACKING ===== */
// Flag to track if the first departure bell has already played
window.__firstDepartureBellPlayed = false;

function playDepartureBell() {
  try {
    const bellAudio = new Audio('/static/E233/ExternalData/Sound/ATS/ats_p_bell2.wav');
    bellAudio.volume = 0.7;
    bellAudio.play().catch((err) => {
      console.debug('Failed to play departure bell:', err);
    });
  } catch (e) {
    console.debug('Error creating/playing departure bell:', e);
  }
}

/* ===== ATS OVERSPEED PROTECTION ===== */
// Track overspeed detection state
window.__atsOverspeedTriggered = false;      // EB has been triggered
window.__overspeedStartTime = null;          // When overspeed began (ms)
window.__atsAlarmBuffer = null;              // Decoded audio buffer for seamless looping
window.__atsAlarmSource = null;              // Current audio source node
window.__atsAlarmGain = null;                // Gain node for volume control
window.__atsAlarmContext = null;             // Audio context for Web Audio API
window.__isEBApplied = false;                // EB has been applied

// Load and cache the ATS alarm audio buffer
async function loadAtsAlarmBuffer() {
  try {
    if (window.__atsAlarmBuffer) return; // Already loaded
    
    const response = await fetch('/static/E233/ExternalData/Sound/ATS/ATS.wav', { cache: 'no-store' });
    if (!response.ok) throw new Error('Failed to fetch ATS.wav');
    
    const arrayBuffer = await response.arrayBuffer();
    
    // Get or create audio context
    if (!window.__atsAlarmContext) {
      window.__atsAlarmContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    window.__atsAlarmBuffer = await window.__atsAlarmContext.decodeAudioData(arrayBuffer);
    console.debug('ATS alarm buffer loaded and decoded');
  } catch (e) {
    console.debug('Error loading ATS alarm buffer:', e);
  }
}

function playAtsAlarm() {
  try {
    // If already playing, don't restart
    if (window.__atsAlarmSource && !window.__atsAlarmSource.stopped) {
      console.debug('ATS alarm already playing');
      return;
    }
    
    // Ensure context exists and is resumed
    if (!window.__atsAlarmContext) {
      window.__atsAlarmContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    if (window.__atsAlarmContext.state === 'suspended') {
      window.__atsAlarmContext.resume().catch(() => {});
    }
    
    // Ensure buffer is loaded
    if (!window.__atsAlarmBuffer) {
      loadAtsAlarmBuffer().then(() => playAtsAlarmSeamless());
      return;
    }
    
    playAtsAlarmSeamless();
  } catch (e) {
    console.debug('Error in playAtsAlarm:', e);
  }
}

function playAtsAlarmSeamless() {
  try {
    // Create new source for seamless looping
    const source = window.__atsAlarmContext.createBufferSource();
    source.buffer = window.__atsAlarmBuffer;
    source.loop = true;
    
    // Create or reuse gain node
    if (!window.__atsAlarmGain) {
      window.__atsAlarmGain = window.__atsAlarmContext.createGain();
      window.__atsAlarmGain.connect(window.__atsAlarmContext.destination);
    }
    
    window.__atsAlarmGain.gain.value = 0.8;
    source.connect(window.__atsAlarmGain);
    source.start(0);
    
    window.__atsAlarmSource = source;
    console.debug('ATS alarm started seamlessly');
  } catch (e) {
    console.debug('Error in playAtsAlarmSeamless:', e);
  }
}

function stopAtsAlarm() {
  try {
    if (window.__atsAlarmSource && !window.__atsAlarmSource.stopped) {
      window.__atsAlarmSource.stop(0);
      window.__atsAlarmSource.disconnect();
      window.__atsAlarmSource = null;
      console.debug('ATS alarm stopped');
    }
  } catch (e) {
    console.debug('Error stopping ATS alarm:', e);
  }
}

function resetOverspeedProtection() {
  window.__atsOverspeedTriggered = false;
  window.__overspeedStartTime = null;
  window.__isEBApplied = false;
  stopAtsAlarm();
  console.debug('Overspeed protection reset');
}

// ğŸ”” Play a single bell sound (ats_p_bell2.wav) when max speed changes
async function playMaxSpeedBell() {
  try {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    if (audioContext.state === 'suspended') {
      await audioContext.resume();
    }

    const response = await fetch('/static/E233/ExternalData/Sound/ATS/ats_p_bell2.wav');
    const arrayBuffer = await response.arrayBuffer();
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

    const source = audioContext.createBufferSource();
    source.buffer = audioBuffer;
    
    const gain = audioContext.createGain();
    gain.gain.value = 0.7;
    
    source.connect(gain);
    gain.connect(audioContext.destination);
    source.start(0);
  } catch (e) {
    console.debug('Error playing max speed bell:', e);
  }
}

// ğŸ”” Play ATC activation sound (ATC_activate.mp3) once
async function playAtcActivateSound() {
  try {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    if (audioContext.state === 'suspended') {
      await audioContext.resume();
    }

    const response = await fetch('/static/E233/ExternalData/Sound/ATC/ATC_activate.mp3');
    const arrayBuffer = await response.arrayBuffer();
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

    const source = audioContext.createBufferSource();
    source.buffer = audioBuffer;
    
    const gain = audioContext.createGain();
    gain.gain.value = 0.8;
    
    source.connect(gain);
    gain.connect(audioContext.destination);
    source.start(0);
  } catch (e) {
    console.debug('Error playing ATC activate sound:', e);
  }
}


// ğŸ”” Play ATC bell notification
async function playAtcBell() {
  try {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    if (audioContext.state === 'suspended') {
      await audioContext.resume();
    }

    const response = await fetch('/static/E233/ExternalData/Sound/ATC/ATC-NS.mp3');
    const arrayBuffer = await response.arrayBuffer();
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

    const source = audioContext.createBufferSource();
    source.buffer = audioBuffer;
    
    const gain = audioContext.createGain();
    gain.gain.value = 0.7;
    
    source.connect(gain);
    gain.connect(audioContext.destination);
    source.start(0);
  } catch (e) {
    console.debug('Error playing ATC bell:', e);
  }
}

/* ===== ëª¨ë°”ì¼ í„°ì¹˜ ì¡°ì‘ ===== */
if(/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)){
  const game=document.getElementById("hud");
  game.addEventListener("touchstart",(e)=>{
  e.preventDefault();
    // ğŸ”´ Block touch input if ATS overspeed protection is active
    if (window.__atsOverspeedTriggered) {
      console.debug('Touch input blocked - ATS overspeed protection active');
      return;
    }
    if(!overlay.classList.contains("hide")) return;
    if(e.touches.length!==1) return;
    // forceManualOverride();
    const r=game.getBoundingClientRect(), y=e.touches[0].clientY-r.top, half=r.height/2;
    if(y<half){ hapticForNotch(+1); sendCmd("applyNotch",+1); }
    else      { hapticForNotch(-1); sendCmd("applyNotch",-1); }
  }, { passive: false });
}

/* ===== í‚¤ë³´ë“œ ===== */
addEventListener("keydown", (e) => {
  if([" ","w","W","s","S","n","N","e","E","d","D", "a", "A", 'q', 'Q', 'p', 'P'].includes(e.key)) e.preventDefault();
  // if(e.repeat) return

  // ğŸ® Pause/Resume game with P key
  if (e.key === "p" || e.key === "P") {
    if(e.repeat) return;
    // Only allow pause/resume during active gameplay (not finished, not in overlay)
    if (st && !st.finished && overlay.classList.contains("hide")) {
      toggleGamePause();
    }
    return;
  }

  // If game is paused, ignore all other game controls
  if (gamePaused) {
    return;
  }

  if (e.key === " ") {
    // Check state before taking action
    if (ws.readyState !== WebSocket.OPEN) return;
    if(e.repeat) return;

    const rndEl = document.getElementById('rndToggle');
    const atFinished = !!(st && st.finished);
    const isRandomMode = !!(rndEl && rndEl.checked);
    const currentSpeed = (st && typeof st.v === 'number') ? st.v : 0;

    // In Random mode during gameplay: block Space unless stopped
    if (isRandomMode && !atFinished && currentSpeed > 0) {
      // Train is moving during random mode gameplay - ignore Space key
      return;
    }

    // If in Random mode and game finished: advance to next station
    if (isRandomMode && atFinished) {
      // Advance seamlessly to next station
      if (window && typeof window.continueToNextStation === 'function') {
        window.continueToNextStation();
      }
    } else {
      // Default behavior: start new run (hides score overlay if shown)
      hideScoreOverlay();
      
      // If any obstacle popup is visible, just close it
      if (anyObstaclePopupVisible()) {
        hideObstaclePopups();
        return;
      }
      
      startRun();
    }
  }
  else if(e.key === "w" || e.key === "W"){ 
    // Stop before EB (max notch = vehicle.notches - 2)
    if(vehicle && vehicle.notches && st && st.lever_notch !== undefined) {
      const maxNotch = vehicle.notches - 2; // One before EB
      if(st.lever_notch < maxNotch) {
        sendCmd("applyNotch", +1);
      }
    } else {
      sendCmd("applyNotch", +1);
    }
  }
  else if(e.key === "s" || e.key === "S"){ 
    sendCmd("applyNotch", -1); 
  }
  else if(e.key === "n" || e.key === "N"){ 
    sendCmd("release", 0); 
  }
  else if(e.key === "e" || e.key === "E"){ 
    sendCmd("emergencyBrake", 0);  
  }
  else if(e.key === "d" || e.key === "D"){ 
    // ì œë™ 1ë‹¨
    sendCmd("setNotch", 1);  
  }
  else if(e.key === "a" || e.key === "A"){
    if(vehicle && vehicle.notches){
      sendCmd("setNotch", vehicle.notches - 4); // EB ì§ì „ notch
    }
  }
  else if(e.key === "q" || e.key === "Q"){
    if(vehicle && vehicle.forward_notches){
      sendCmd("setNotch", -vehicle.forward_notches); // EB ì§ì „ notch
    }
  }
  else if (e.key === "b" || e.key === "B") {
    // 1) ê·¸ë˜í”„ ê·¸ë¦´ì§€ ì—¬ë¶€ (ê¸°ì¡´ ê¸°ëŠ¥ ìœ ì§€)
    window.__brakeGuideOn = !window.__brakeGuideOn;

    // 2) HUD ìº”ë²„ìŠ¤ ìì²´ë¥¼ ìˆ¨ê¸°ê¸°/ë³´ì´ê¸°
    const hudCanvas = document.getElementById("hud");
    if (hudCanvas) {
      const hidden = hudCanvas.classList.toggle("hud-hidden");
      // ë‹¤ì‹œ ì¼œì§ˆ ë•Œ í•œ ë²ˆ ì‚¬ì´ì¦ˆ/ê·¸ë¦¼ ë¦¬í”„ë ˆì‹œ
      if (!hidden) {
        try {
          if (typeof resize === "function") resize();
          if (st) drawHUD(st);
        } catch (e) {}
      }
    }

    // 3) ê°„ë‹¨ í”¼ë“œë°± í…ìŠ¤íŠ¸
    if (fb) {
      const msg = (!hudCanvas || !hudCanvas.classList.contains("hud-hidden"))
        ? "ì œë™ê³¡ì„  HUD: ON (Bë¡œ í† ê¸€)"
        : "ì œë™ê³¡ì„  HUD: OFF (Bë¡œ í† ê¸€)";
      fb.innerHTML = `<div class="warn">${msg}</div>`;
      setTimeout(() => {
        if (!st || !st.finished) fb.textContent = "Spaceë¡œ ì‹œì‘. W/Së¡œ ë¸Œë ˆì´í¬ ì¡°ì ˆí•˜ì„¸ìš”.";
      }, 1200);
    }
  }


});

/* ===== HUD & ìƒíƒœ ===== */
const grade_percentEl=document.getElementById("grade_percent");
let isFinished=false, overlayShowingResult=false, st=null, lastTimestamp=0, prevMaxDistance=0;

// ğŸ® Pause state management
let gamePaused = false;
let pauseOverlay = null;

// Create pause overlay on page load
function initPauseOverlay() {
  if (pauseOverlay) return;
  
  pauseOverlay = document.createElement('div');
  pauseOverlay.id = 'pauseOverlay';
  pauseOverlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    font-family: "A-OTF Shin Go Pro", system-ui, sans-serif;
    backdrop-filter: blur(4px);
  `;
  
  pauseOverlay.innerHTML = `
    <div style="
      background: rgba(30, 40, 60, 0.95);
      padding: 60px;
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(96, 165, 250, 0.3);
    ">
      <div style="
        font-size: 56px;
        font-weight: 700;
        color: #60a5fa;
        margin-bottom: 24px;
        letter-spacing: 1px;
      ">â¸ PAUSED</div>
      <div style="
        font-size: 18px;
        color: #cbd5e1;
        margin-bottom: 32px;
        letter-spacing: 0.5px;
      ">Press <span style="color: #fbbf24; font-weight: 600;">P</span> to resume</div>
      <div style="
        font-size: 14px;
        color: #94a3b8;
        letter-spacing: 0.5px;
      ">Game paused â€¢ All systems on hold</div>
    </div>
  `;
  
  document.body.appendChild(pauseOverlay);
}

function toggleGamePause() {
  initPauseOverlay();
  
  gamePaused = !gamePaused;
  
  if (gamePaused) {
    pauseOverlay.style.display = 'flex';
    
    // Send pause command to server
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: 'cmd', payload: { name: 'pause' } }));
    }
    
    // Show feedback
    if (fb) {
      fb.innerHTML = '<div class="ok">ê²Œì„ ì¼ì‹œì •ì§€ë¨ (Pë¡œ ê³„ì†)</div>';
      setTimeout(() => {
        if (!st || !st.finished) fb.textContent = "Spaceë¡œ ì‹œì‘. W/Së¡œ ë¸Œë ˆì´í¬ ì¡°ì ˆí•˜ì„¸ìš”.";
      }, 2000);
    }
  } else {
    pauseOverlay.style.display = 'none';
    
    // Send resume command to server
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: 'cmd', payload: { name: 'resume' } }));
    }
    
    // Show feedback
    if (fb) {
      fb.innerHTML = '<div class="ok">ê²Œì„ ì¬ê°œë¨</div>';
      setTimeout(() => {
        if (!st || !st.finished) fb.textContent = "Spaceë¡œ ì‹œì‘. W/Së¡œ ë¸Œë ˆì´í¬ ì¡°ì ˆí•˜ì„¸ìš”.";
      }, 1000);
    }
  }
}

// function loop(ts){ if(!lastTimestamp) lastTimestamp=ts; lastTimestamp=ts; if(st) drawHUD(st); requestAnimationFrame(loop); }
// requestAnimationFrame(loop);

function formatTimeSec(secInt) {
  const sign = secInt < 0 ? "+" : "";
  const s = Math.abs(secInt);
  const m = Math.floor(s / 60);
  const s2 = s % 60;
  return `${sign}<span class="min">${m < 10 ? "0" : ""}${m}</span><span class="sep">:</span><span class="sec">${s2 < 10 ? "0" : ""}${s2}</span>`;
}


// ===== Notch Sound Effect =====
let notchSoundFile = null;
let lastNotchValue = null; // ë§ˆì§€ë§‰ ë…¸ì¹˜ ê°’ ê¸°ë¡
let airDownZeroFile = null;
let airDownEBFile = null;
let airUpFile = null;
async function loadNotchSound() {
  try {
    const response = await fetch('/static/audio/notch.mp3', { cache: 'no-store' });
    if (response.ok) {
      const buffer = await response.arrayBuffer();
      notchSoundFile = buffer;
      console.log("notch.mp3 loaded successfully");
    }
  } catch (err) {
    console.debug("notch.mp3 load error:", err);
  }
}

// Load air-down sounds (AirDownZero1.wav and AirDownEB.wav)
async function loadAirSounds() {
  try {
    const respZero = await fetch('/static/E233/OriginalData/Sound/Air/AirDownZero1.wav', { cache: 'no-store' });
    if (respZero.ok) airDownZeroFile = await respZero.arrayBuffer();
  } catch (e) { console.debug('AirDownZero1 load error', e); }
  try {
    const respEB = await fetch('/static/E233/OriginalData/Sound/Air/AirDownEB.wav', { cache: 'no-store' });
    if (respEB.ok) airDownEBFile = await respEB.arrayBuffer();
  } catch (e) { console.debug('AirDownEB load error', e); }
  try {
    const airUp = await fetch('/static/E233/OriginalData/Sound/Air/AirUp.wav', { cache: 'no-store' });
    if (airUp.ok) { airUpFile = await airUp.arrayBuffer(); }
  } catch (e) { console.debug('AirUp load error', e); }
}

function playAirBuffer(arrayBuffer, volume = 0.9, gainFactor = 2.0) {
  if (!arrayBuffer) return;

  try {
    if (!bveCtx) {
      // Fallback to HTMLAudioElement
      try {
        const a = new Audio('/static/E233/OriginalData/Sound/Air/AirDownZero1.wav');
        a.volume = volume;
        a.play().catch(() => {});
      } catch (e) {}
      return;
    }

    if (bveCtx.state === 'suspended') {
      bveCtx.resume().then(() => {
        bveCtx.decodeAudioData(arrayBuffer.slice(0), (buffer) => {
          const src = bveCtx.createBufferSource();
          src.buffer = buffer;

          const gain = bveCtx.createGain();
          gain.gain.value = volume * gainFactor; // Increase volume by the gainFactor

          src.connect(gain);
          gain.connect(bveCtx.destination);
          src.start();
        }, (err) => { 
          console.debug('decode air buffer error', err); 
        });
      }).catch(() => {});
    } else {
      bveCtx.decodeAudioData(arrayBuffer.slice(0), (buffer) => {
        const src = bveCtx.createBufferSource();
        src.buffer = buffer;

        const gain = bveCtx.createGain();
        gain.gain.value = volume * gainFactor; // Increase volume by the gainFactor

        src.connect(gain);
        gain.connect(bveCtx.destination);
        src.start();
      }, (err) => { 
        console.debug('decode air buffer error', err); 
      });
    }
  } catch (e) { 
    console.debug('playAirBuffer error', e); 
  }
}

function playNotchSound() {
  if (!notchSoundFile || !bveCtx) return;
  try {
    // AudioContext ìƒíƒœ í™•ì¸ í›„ resume í•„ìš”ì‹œ ìˆ˜í–‰
    if (bveCtx.state === 'suspended') {
      bveCtx.resume().then(() => {
        playNotchSoundHelper();
      });
    } else {
      playNotchSoundHelper();
    }
  } catch (err) {
    console.debug("playNotchSound error:", err);
  }
}
function playNotchSoundHelper() {
  try {
    bveCtx.decodeAudioData(notchSoundFile.slice(0), (buffer) => {
      const source = bveCtx.createBufferSource();
      source.buffer = buffer;
      const gain = bveCtx.createGain();
      gain.gain.value = 0.5; // 0~1 ë²”ìœ„ì˜ ë³¼ë¥¨(ì¡°ì • ê°€ëŠ¥)
      source.connect(gain);
      gain.connect(bveCtx.destination);
      source.start();
    }, (err) => {
      console.debug("notch.mp3 decode error:", err);
    });
  } catch (err) {
    console.debug("playNotchSoundHelper error:", err);
  }
}

// ===== WebSocket (ë‹¨ì¼ í•¸ë“¤ëŸ¬ë¡œ êµì²´) =====
ws.onmessage = (ev) => {
  const msg = JSON.parse(ev.data);
  if (msg.type !== "state") return;

  // ìƒíƒœ ì €ì¥
  st = msg.payload;
  window.st = st;

  // (clock should run continuously) â€” do not stop the mini HUD clock when run finishes

  // ğŸ”” ë…¸ì¹˜ ë³€ê²½ ê°ì§€ ë° ì¬ìƒ
  if (typeof st.lever_notch === 'number' && lastNotchValue !== st.lever_notch) {
    if (lastNotchValue !== null) { // ì²« í”„ë ˆì„ì€ ì¬ìƒ ì•ˆ í•¨
      playNotchSound();

      // Play air-down sounds on specific brake transitions when stopped
      try {
        const prev = Number(lastNotchValue || 0);
        const cur = Number(st.lever_notch || 0);
        const speed = Number(st.v || 0);
        const ebIndex = (typeof getEbIndex === 'function') ? getEbIndex() : 8;

        // Condition: speed == 0 and brake notch decreased from 4 -> 3 => AirDownZero1.wav
        const prevList = [ebIndex, ebIndex - 2, 8, 7, 6, 5, 4, 3, 2];
        const curList = [3, 2, 0, -4, -5, -13,-18];

        if (speed <= 4 && prevList.includes(prev) && curList.includes(cur)) {
          playAirBuffer(airDownZeroFile, 0.9);
        }

        // Condition: speed == 0 and brake notch equals EB - 1 index => AirDownEB.wav
        const prevList3 = [ebIndex,]; // example list
        const curList3 = [ebIndex - 1 , 1, 0, -4, -5, -13,-18 ]; // only EB index
        if (speed == 0 && ((prevList3.includes(prev) && curList3.includes(cur)) || (prev == 0 && cur == ebIndex) || (prev == ebIndex -2 && cur == ebIndex - 1))) {
          playAirBuffer(airDownEBFile, 0.95);
        }


        const prevList2 = [7, 6, 5, 4, 3, 2, 1];
        const curList2 = [6, 5, 4, 3, 2, 1, 0, -4, -5, -13,-18];

        if (speed == 0 && prevList2.includes(prev) && curList2.includes(cur)) {
          playAirBuffer(airUpFile, 0.9);
        }
      } catch (e) { console.debug('air-down play error', e); }
    }
    lastNotchValue = st.lever_notch;
  }
// --- ì•ˆë‚´ë°©ì†¡: ë‚¨ì€ê±°ë¦¬ crossing ê¸°ë°˜ íŠ¸ë¦¬ê±° ---
  try {
    if (typeof st.remaining_m === "number" && !announcementPlayed) {
      const rem = st.remaining_m;

      // ì²« í”„ë ˆì„ì´ë©´ just ê¸°ë¡ë§Œ
      if (lastRemaining === null) {
        lastRemaining = rem;
      }

      // 1) í•œë²ˆì´ë¼ë„ íŠ¸ë¦¬ê±° ê±°ë¦¬ë³´ë‹¤ "ë°”ê¹¥ìª½(ë” ë©€ë¦¬)"ì— ê°€ ë³¸ ì ì´ ìˆì–´ì•¼ armed
      // rem > triggerDist ì¸ êµ¬ê°„ì„ ì§€ë‚˜ê°„ í›„ì—ë§Œ true
      if (!announcementArmed && rem > announcementTriggerDist) {
        announcementArmed = true;
      }

      // 2) armed ëœ ìƒíƒœì—ì„œ, rem ì´ triggerDist ë¥¼ ë„˜ì–´ ë‚´ë ¤ì˜¬ ë•Œ (crossing) ì¬ìƒ
      if ((announcementArmed &&
          lastRemaining > announcementTriggerDist &&
          rem <= announcementTriggerDist &&
          rem > 0)) {
        playStationMelody();
        announcementPlayed = true;
      }

      lastRemaining = rem;
    }
  } catch (e) {
    console.debug("announcement trigger error", e);
  }
// --- BVE ì‚¬ìš´ë“œ ì—…ë°ì´íŠ¸ (ì†ë„ + ë ˆë²„ ë…¸ì¹˜ ê¸°ë°˜) ---
  try {
    if (bveSoundEngine && typeof st.v === "number") {
      const speedKmh = st.v * 3.6;
      const rawNotch = st.lever_notch | 0;

      const maxBrakeIdx = getEbIndex(); // EB ì¸ë±ìŠ¤
      const maxPowerNotch =
        (vehicle && Number.isInteger(vehicle.forward_notches))
          ? vehicle.forward_notches
          : 5;

      const powerNotch = rawNotch < 0 ? -rawNotch : 0;
      const brakeNotch = rawNotch > 0 ? rawNotch : 0;
      const isEB = (rawNotch === maxBrakeIdx);

      bveSoundEngine.update(speedKmh, powerNotch, maxPowerNotch, brakeNotch, maxBrakeIdx, isEB);

      // Play door sound when train arrives (prefer st.finished or speed==0 and remaining distance â‰¤ 1m)
      try {
        const rem = (typeof st.remaining_m === 'number') ? st.remaining_m : null;
        const isStopped = speedKmh <= 0 || st.v === 0;
        const runFinished = st.finished && isStopped && rem !== null && Math.abs(rem) <= 1;
        
        // Stop the mini timer when run finishes (clock continues)
        if (runFinished && window.__miniTimerCountdownInterval) {
          clearInterval(window.__miniTimerCountdownInterval);
          window.__miniTimerCountdownInterval = null;
          console.debug('run finished - timer stopped, clock continues');
        }
        
        if (runFinished && bveSoundEngine) {
          const currentTime = (typeof st.time === 'number') ? st.time : Date.now() / 1000;
          const lastTrigger = bveSoundEngine.lastDoorTrigger || -10;
          const timeSinceLastDoor = currentTime - lastTrigger;
          
          if (timeSinceLastDoor > 2) { // play door sound only once per game
            bveSoundEngine.playDoorSound();
            bveSoundEngine.lastDoorTrigger = currentTime + 10000; // set to far future to prevent replay
          }
        }
      } catch (e) {}
    }
  } catch (e) {
    console.debug("BVE sound update error", e);
  }

    //  ê²Œì„ ì¢…ë£Œ ì‹œì  ê°ì§€ â†’ ì ìˆ˜ ì˜¤ë²„ë ˆì´ + ë„ì–´ ì—´ê¸° ì†Œë¦¬
  const nowFinished = !!st.finished;
  if (nowFinished && !lastFinishedFlag) {
    // Always show score overlay when game finishes (in both random and normal mode)
    let score = Number(st.score ?? 0);
    if (vehicle && vehicle.name) {
      const veh_name = vehicle.name.toLowerCase()
      if (veh_name.includes("ktx") || veh_name.includes("n700s") || veh_name.includes("e26")) {
        if (score > 0) {
          score +=40; //ê³ ì†ì—´ì°¨ ë° ì „ê¸°ê¸°ê´€ì°¨ëŠ” ì™„ë²½í•œ ê¸°ë³¸ì œë™ì´ ì‚¬ì‹¤ìƒ ë¶ˆê°€í•˜ë¯€ë¡œ ê¸°ë³¸ì œë™ ì ìˆ˜ ì–´ë“œë°´í‹°ì§€ ë¶€ì—¬
          if (score >100) {
            score = 100;
          }
        }
      }
    }
    
    // miniTimer ì ìˆ˜ ê³„ì‚° (rndToggleì´ ì¼œì ¸ìˆì„ ë•Œë§Œ)
    try {
      const rndEl = document.getElementById('rndToggle');
      if (nowFinished && !lastFinishedFlag && rndEl && rndEl.checked && window.__miniTimerRemaining != null) {
        const remaining = window.__miniTimerRemaining;
        let timerScore = 0;
        if (remaining >= 0) {
          // ì œì‹œê°„ì— ë„ì°©í•˜ê±°ë‚˜ ì¼ì° ì™”ìœ¼ë©´ +20 (cap 100)
          timerScore = 10;
        } else {
          // 15ì´ˆì”© ëŠ¦ì„ë•Œë§ˆë‹¤ -10 (ìµœì†Œ 0ì )
          const lateSeconds = Math.abs(remaining);
          const penaltyCount = Math.ceil(lateSeconds / 15);
          timerScore = Math.max(0, -10 * penaltyCount);
        }
        score += timerScore;
        if (score > 100) score = 100;
        console.debug('miniTimer score calculation: remaining=', remaining, 'timerScore=', timerScore, 'totalScore=', score);
      }
    } catch (e) {
      console.debug('miniTimer score calculation error:', e);
    }
    
    const stopErr = Number(st.stop_error_m ?? 0);
    showScoreOverlay(score, stopErr);
    
    // Update feedback area with arrival time status
    try {
      const fbEl = document.getElementById('fb');
      if (fbEl) {
        let fbHtml = ``;
        
        // Add arrival time status if in Random mode with timer
        const rndEl = document.getElementById('rndToggle');
        if (rndEl && rndEl.checked && window.__miniTimerRemaining != null) {
          const remaining = window.__miniTimerRemaining;
          if (remaining >= 0) {
            fbHtml += `<div style="color: #4CAF50; font-weight: bold;">Arrived on time</div>`;
          } else {
            const lateSeconds = Math.abs(remaining);
            fbHtml += `<div style="color: #f44336; font-weight: bold;">Arrived ${lateSeconds} seconds late</div>`;
          }
        }
        fbEl.innerHTML = fbHtml;
      }
    } catch (e) {
      console.debug('feedback update error:', e);
    }
    
    // Play doors open sound when game finishes
    try {
      if (bveSoundEngine && typeof bveSoundEngine.playDoorSound === 'function') {
        bveSoundEngine.playDoorSound(); // This is "doors opening" sound
      }
    } catch (e) {
      console.debug("Door sound play error on finish:", e);
    }
    // If the run finished because the train overran beyond -5m, mark next run to start with EB
    try {
      const remCheck = (typeof st.remaining_m === 'number') ? st.remaining_m : parseFloat(st.remaining_m);
      // Use <= to catch equality cases where remaining_m is exactly -5
      if (typeof remCheck === 'number' && !Number.isNaN(remCheck) && remCheck <= -5) {
        // Force next run to start with EB notch
        window.__forceNextStartEB = true;
        console.debug('Run ended by overrun (rem=', remCheck, ') -> forcing EB on next start');
      }
    } catch (e) { console.debug('force EB flag set error', e); }
  }
  // ê²Œì„ì´ ì¬ì‹œì‘ë  ë•Œ ë„ì–´ìŒ íŠ¸ë¦¬ê±° ë¦¬ì…‹ (finished: true â†’ false)
  if (!nowFinished && lastFinishedFlag && bveSoundEngine) {
    bveSoundEngine.lastDoorTrigger = -10;
  }
  lastFinishedFlag = nowFinished;
    //  ì¥ì• ë¬¼ ê´€ë ¨ ì´ë²¤íŠ¸ íŒì •
  handleObstacleState(st);
  // ğŸ”¹ ì„œë²„ ìƒíƒœì— train_nameì´ ìˆìœ¼ë©´ mini HUD íƒ€ì´í‹€ì„ ê·¸ê±¸ë¡œ ì‚¬ìš©
  if (st.train_name && miniTitle) {
    miniTitle.textContent = st.train_name;
  }

  // st, window.st ì„¸íŒ… ì§í›„ì— ì¶”ê°€
if (!document.getElementById('svgSpeed')) {
  try { mountInstrumentSVG(); } catch (e) { console.debug(e); }
}
  // ìˆ«ì HUD ê°±ì‹ 
  const remRaw = st.remaining_m;
  const rem = (typeof remRaw === "number") ? remRaw : parseFloat(remRaw);
  // ê±°ë¦¬ í‘œì‹œ
if (rem >= 0) {
  if (rem <= 2)  remEl.textContent = Math.round(rem * 100) + " cm";
  else           remEl.textContent = rem.toFixed(0) + " m";
} else {
  if (rem >= -2) remEl.textContent = "-" + Math.round(Math.abs(rem) * 100) + " cm";
  else           remEl.textContent = "-" + Math.abs(rem).toFixed(0) + " m";
}

//  ìƒ‰ìƒ ì¡°ê±´ ì ìš© (Â±0.35m ì´ë‚´ë©´ ì´ˆë¡ìƒ‰, ì•„ë‹ˆë©´ ê¸°ë³¸)
if (Math.abs(rem) <= 1.00) {
  remEl.style.color = "#9effb5";   // ì´ˆë¡
} else {
  remEl.style.color = "";          // ê¸°ë³¸ (.statì˜ í•˜ì–€ìƒ‰ìœ¼ë¡œ ë³µê·€)
}

// ğŸ”¹ mini HUD â€“ ê±°ë¦¬ ë™ê¸°í™”
if (miniRemain) {
  miniRemain.textContent = remEl.textContent;
  miniRemain.style.color = remEl.style.color;
}

spdEl.textContent = (st.v * 3.6).toFixed(1);

// ğŸ”¹ mini HUD â€“ ì†ë„
miniSpeed.innerHTML = `
  ${spdEl.textContent} 
  <span class="unit">km/h</span>
`;

// ğŸ”¹ mini HUD â€“ ìµœëŒ€ ì†ë„ (ATC > ATS)
let maxSpeedDisplay = null;
let atcBellTriggered = false;
try {
  // Try ATC first (higher priority)
  if (window.__routeAtcData && Array.isArray(window.__routeAtcData)) {
    const remaining = st.remaining_m;
    if (typeof remaining === 'number') {
      const atcResult = getAtcMaxSpeed(remaining);
      if (atcResult && typeof atcResult === 'object') {
        maxSpeedDisplay = atcResult.speed;
        atcBellTriggered = atcResult.bell === 1;
      }
    }
  }
  
  // Fallback to ATS if ATC not available
  if (maxSpeedDisplay === null && window.__routeAtsValues && Array.isArray(window.__routeAtsValues) && window.__routeAtsIndex != null) {
    const atsIdx = window.__routeAtsIndex % window.__routeAtsValues.length;
    const atsHal = window.__routeAtsValues[atsIdx];
    if (atsHal !== null && typeof atsHal === 'number') {
      maxSpeedDisplay = atsHal;
    }
  }
  
  if (maxSpeedDisplay !== null && typeof maxSpeedDisplay === 'number') {
    // Only show max speed in miniHUD if Random mode is enabled
    const rndEl = document.getElementById('rndToggle');
    if (rndEl && rndEl.checked) {
      miniMaxSpeed.innerHTML = `${maxSpeedDisplay} <span class="unit">km/h</span>`;
      
      // Check if max speed changed and play bell if it did
      if (window.__lastMaxSpeed !== maxSpeedDisplay) {
        window.__lastMaxSpeed = maxSpeedDisplay;
        // Don't play alarm for N700S trains
        const layoutKey = window.__currentCabLayoutKey || '';
        if (layoutKey !== 'n700s' && layoutKey !== 'ktx') {
          playMaxSpeedBell();
        }
      }
      
      // Play ATC bell if atc_bell flag is 1 and not yet triggered
      if (atcBellTriggered && !window.__lastAtcBellPlayed) {
        window.__lastAtcBellPlayed = true;
        playAtcBell();
      } else if (!atcBellTriggered) {
        window.__lastAtcBellPlayed = false;
      }
    } else {
      miniMaxSpeed.textContent = 'â€”';
      window.__lastMaxSpeed = null;
      window.__lastAtcBellPlayed = false;
    }
  } else {
    miniMaxSpeed.textContent = 'â€”';
    window.__lastMaxSpeed = null;
    window.__lastAtcBellPlayed = false;
  }
} catch (e) {
  miniMaxSpeed.textContent = 'â€”';
}

// ğŸ”” ATS OVERSPEED PROTECTION: Check if speed exceeds max speed (ATC > ATS)
try {
  const currentSpeedKmh = st.v * 3.6;
  let maxSpeedKmh = null;
  
  // Get max speed from ATC first (higher priority)
  if (window.__routeAtcData && Array.isArray(window.__routeAtcData)) {
    const remaining = st.remaining_m;
    if (typeof remaining === 'number') {
      const atcResult = getAtcMaxSpeed(remaining);
      if (atcResult && typeof atcResult === 'object') {
        maxSpeedKmh = atcResult.speed;
      }
    }
  }
  
  // Fallback to ATS if ATC not available
  if (maxSpeedKmh === null && window.__routeAtsValues && Array.isArray(window.__routeAtsValues) && window.__routeAtsIndex != null) {
    const atsIdx = window.__routeAtsIndex % window.__routeAtsValues.length;
    const atsVal = window.__routeAtsValues[atsIdx];
    if (atsVal !== null && typeof atsVal === 'number') {
      maxSpeedKmh = atsVal;
    }
  }
  
  // If no speed limit data, skip overspeed check
  if (maxSpeedKmh !== null) {
    const isOverspeeding = currentSpeedKmh > maxSpeedKmh;
    
    if (isOverspeeding) {
      // Train is overspeeding
      if (!window.__overspeedStartTime) {
        window.__overspeedStartTime = Date.now();
        console.debug('Overspeed detected at', currentSpeedKmh, 'km/h (limit:', maxSpeedKmh, ')');
      }
      
      const overspeedDuration = (Date.now() - window.__overspeedStartTime) / 1000; // seconds
      
      // If overspeed for > 1 seconds and EB not yet applied, trigger EB
      // Also check that current notch is not brakes (notch <= 0)
      // Only trigger when Random mode is on
      const rndEl = document.getElementById('rndToggle');
      const isRandomMode = rndEl && rndEl.checked;
      if (overspeedDuration > 0 && !window.__atsOverspeedTriggered && isRandomMode) {
        window.__atsOverspeedTriggered = true;
        // window.__isEBApplied = true;
        
        console.debug('ATS OVERSPEED TRIGGERED: EB engaged, alarm playing');
        
      
        const layoutKey = window.__currentCabLayoutKey || '';
        if (layoutKey !== 'n700s' && layoutKey !== 'ktx') {
            playAtsAlarm();
        } else{
            playAtcActivateSound();
        }        
        if (ws && ws.readyState === WebSocket.OPEN) {
          sendCmd('setInternalNotch', 4); // apply max service brake (EB - 1)
          sendCmd('atcOverspeed', 1); // apply max service brake (EB - 1)
        }
      }
    } else {
      // Train is not overspeeding - reset the timer
      if (window.__overspeedStartTime) {
        window.__overspeedStartTime = null;
        console.debug('Overspeed condition cleared');
      }
    }
    
    // If EB was applied and train has stopped (speed near 0), allow user input again
    if (window.__atsOverspeedTriggered && currentSpeedKmh <= maxSpeedKmh) {
      console.debug('Train stopped after overspeed - resetting ATS protection');
      resetOverspeedProtection();
              const layoutKey = window.__currentCabLayoutKey || '';
        if (layoutKey !== 'n700s' && layoutKey !== 'ktx') {
        } else{
            playAtcActivateSound();
        }       
        if (ws && ws.readyState === WebSocket.OPEN) {
          sendCmd('setInternalNotch', 0); // release brakes
          sendCmd('atcOverspeed', 0); // clear overspeed flag
        }
    }
  }
} catch (e) {
  console.debug('ATS overspeed check error:', e);
}

const maxIdx = (vehicle?.notches ?? 10) - 1; // EB ì¸ë±ìŠ¤
const forwardAccels = vehicle?.forward_notch_accels ?? [0.139, 0.278, 0.417, 0.556, 0.694];

let notchText = "N";
let notchColor = "#9effb5"; // ê¸°ë³¸ ì´ˆë¡

if (st.lever_notch === 0) {
  notchText = "N";
  notchColor = "#9effb5";     // ì´ˆë¡
} else if (st.lever_notch < 0) {
  const idx = -st.lever_notch - 1; // -1 â†’ 0, -2 â†’ 1
  notchText = `P${idx + 1}`;
  notchColor = "#ADD8E6";        // ì£¼í™©
  const accel = forwardAccels[idx] ?? forwardAccels[forwardAccels.length - 1];
  // í•„ìš”í•˜ë©´ accel ë³€ìˆ˜ë¡œ ê°€ì†ë„ ì œì–´ ê°€ëŠ¥
} else if (st.lever_notch === maxIdx) {
  notchText = "EB";
  notchColor = "#ff5757";     // ë¹¨ê°•
} else {
  notchText = `B${st.lever_notch}`;
  notchColor = "#ed9a09";     // ê¸°ì¡´ ì£¼í™©/í™©í† ìƒ‰
}


notchEl.textContent = notchText;
notchEl.style.color = notchColor;

// ğŸ”¹ mini HUD â€“ ë…¸ì¹˜
if (miniNotch) {
  miniNotch.textContent = notchEl.textContent;
  miniNotch.style.color = notchEl.style.color;
}

grade_percentEl.textContent = (10 * st.grade_percent).toFixed(1);

if (miniGrade) {
  miniGrade.innerHTML = `
    ${grade_percentEl.textContent}
    <span class="unit-grade">â€°</span>
  `;
}

const running  = !!st.running;
const finished = !!st.finished;
const budget   = Number(st.time_budget_s ?? 0);
const remainI  = Number(st.time_remaining_int ?? 0);
let toShowInt = (running || finished) ? remainI : Math.round(budget);
if (!Number.isFinite(toShowInt)) {
  const remainF = Number(st.time_remaining_s);
  toShowInt = Number.isFinite(remainF) ? Math.floor(remainF) : Math.floor(Number(st.t) || 0);
}

timerEl.innerHTML = formatTimeSec(toShowInt);

//  ìƒ‰ìƒ ì¡°ê±´ ì¶”ê°€
if (Math.abs(toShowInt) <= 2) {
  timerEl.style.color = "#9effb5";   // ì´ˆë¡ìƒ‰
  timerEl.classList.remove('bad');
} else if (toShowInt < 0) {
  timerEl.style.color = "";          // ê¸°ë³¸ ìƒ‰ìƒ (CSS .stat)
  timerEl.classList.add('bad');      // ìŒìˆ˜ë©´ ë¹¨ê°•
} else {
  timerEl.style.color = "";          // ê¸°ë³¸ ìƒ‰ìƒ (CSS .stat)
  timerEl.classList.remove('bad');
} 

// ğŸ”¹ mini HUD â€“ íƒ€ì´ë¨¸
if (miniTimer) {
  // If a CSV-driven mini timer is active, do not overwrite it with server timer
  if (!window.__miniTimerIsRoute) {
    miniTimer.innerHTML = timerEl.innerHTML;
    // ìƒ‰ìƒ/ìƒíƒœë„ ê°™ì´ ë³µì‚¬
    miniTimer.style.color = timerEl.style.color;
    if (timerEl.classList.contains('bad')) miniTimer.classList.add('bad');
    else miniTimer.classList.remove('bad');
  }
}

// ğŸ”¹ mini HUD â€“ Next Station (skip first row, show next station name)
if (miniNext && window.__routeStationNames && Array.isArray(window.__routeStationNames)) {
  const idx = window.__routeStationNamesIndex || 0;
  // Skip the first row (idx=0), start from idx=1 for the "next" station
  const nextIdx = (idx) % window.__routeStationNames.length;
  const nextStationName = window.__routeStationNames[nextIdx] || "â€”";
  miniNext.textContent = nextStationName;
}

  // ê·¸ë˜í”„/ë¯¸ë‹ˆ ì¸ë””ì¼€ì´í„°
  // drawHUD(st);
  // drawBrakeLadderMini(st);
  // small cab mini ladder (above cab dash)
  if (typeof drawCabBrakeLadder === 'function') drawCabBrakeLadder(st);

  
// ws.onmessage ë‚´ë¶€, st ê°±ì‹  ì´í›„ ì ë‹¹í•œ ê³³ì— ì¶”ê°€
{
 const vKmh = Number(st.v * 3.6) || 0;
  const maxIdx = (vehicle?.notches ?? 10) - 1;
  let notchLabel = 'N';
  if (st.lever_notch === 0) notchLabel = 'N';
  else if (st.lever_notch < 0) notchLabel = `P${-st.lever_notch}`;
  else if (st.lever_notch === maxIdx) notchLabel = 'EB';
  else notchLabel = `B${st.lever_notch}`;

  updateInstrumentHUD({ speed: vKmh, notch: notchLabel, maxSpeed: maxSpeedDisplay });
if (window.drawMiniBrakeLadder) window.drawMiniBrakeLadder(st);
  if (window.updateInstrumentLadder) {
    try { window.updateInstrumentLadder(st); } catch(e) {}
  }
}


  

  // âš  í”¼ë“œë°±(fb) UIëŠ” ì—¬ê¸°ì„œ ê±´ë“œë¦¬ì§€ ë§ˆì„¸ìš” (ì–¸ì–´ í† ê¸€ì€ setLangì—ì„œ ì²˜ë¦¬)
const isOverlayOpen = !overlay.classList.contains('hide');

if (st.finished && !isOverlayOpen) {
  // ê²Œì„ì´ ëë‚¬ê³ , ì˜¤ë²„ë ˆì´ê°€ ë‹«í˜€ ìˆì„ ë•Œë§Œ FAB í‘œì‹œ
  if (/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)) {
    btnMobileRestart.classList.remove('hide');
  } else {
    btnMobileRestart.classList.add('hide');
  }
} else {
  // ê·¸ ì™¸ì—ëŠ” í•­ìƒ ìˆ¨ê¹€ (ì˜¤ë²„ë ˆì´ê°€ ë–  ìˆìœ¼ë©´ ë‹¹ì—°íˆ ìˆ¨ê¹€)
  btnMobileRestart.classList.add('hide');
}
// onmessage ë‚´ë¶€
const serverEnabled = !!st.tasc_enabled;
if (tascToggle.checked !== serverEnabled) {
  tascToggle.checked = serverEnabled; // ì„œë²„ ê¸°ì¤€ìœ¼ë¡œ ê°•ì œ ë™ê¸°í™”
}
};

/* ===== HUD ê·¸ë¦¬ê¸° (ê¸°ì¡´ ìœ ì§€) ===== */
function drawHUD(st){
  const dpr=devicePixelRatio||1, w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);
  const v0=st.v, lever=st.lever_notch, currentPos=st.pos??0, stopPos=st.stopPos??500;
  const remaining=(typeof st.remaining_m==="number")?Math.max(0,st.remaining_m):Math.max(0,stopPos-currentPos);
  const maxDecel=Math.max(...Object.values(brakeDecels)); const maxStop=maxDecel>0?(v0*v0)/(2*maxDecel):0;
  const speedFactor=Math.max(.3,Math.min(1,v0/10)); const adjusted=remaining*(1+(1-speedFactor)*.5);
  const s_b1=(brakeDecels[1]??0)>0?(v0*v0)/(2*brakeDecels[1]):0, s_b2=(brakeDecels[2]??0)>0?(v0*v0)/(2*brakeDecels[2]):0;
  const target=Math.max(1,maxStop*1.5,Math.max(1,Math.sqrt(adjusted)*10)*1.2,s_b1*1.1,s_b2*1.1);
  prevMaxDistance = prevMaxDistance===0 ? target : prevMaxDistance*.9 + target*.1;

  const left=48*dpr, right=12*dpr, usableW=w-left-right, X=d=>left+usableW*(d/prevMaxDistance);
  const vmax=Math.max(1,v0*3.6*1.2);
  const bottom=28*dpr, top=12*dpr, usableH=h-bottom-top, Y=v=>h-bottom-usableH*(v/vmax);

  ctx.strokeStyle="#20334d"; ctx.lineWidth=1*dpr; ctx.beginPath(); ctx.moveTo(left,top); ctx.lineTo(left,h-bottom); ctx.lineTo(w-right,h-bottom); ctx.stroke();

  ctx.fillStyle="#888"; ctx.font=`${10*dpr}px sans-serif`; ctx.textAlign="center"; ctx.textBaseline="top";
  for(let d=0; d<=prevMaxDistance; d+=100){ const x=X(d); ctx.beginPath(); ctx.moveTo(x,h-bottom); ctx.lineTo(x,h-bottom+4*dpr); ctx.stroke(); ctx.fillText(`${Math.round(d)}`,x,h-bottom+6*dpr); }
  ctx.textAlign="right"; ctx.textBaseline="middle";
  for(let k=0;k<=vmax;k+=10){ const y=Y(k); ctx.beginPath(); ctx.moveTo(left-4*dpr,y); ctx.lineTo(left,y); ctx.stroke(); ctx.fillText(`${k}`,left-6*dpr,y); }

  ctx.lineWidth=2*dpr; 
  const maxNotch = vehicle?.notches ?? 10;   // ì´ ê°œìˆ˜(0~maxIdx)
  const maxIdx   = maxNotch - 1;  // EB ì¸ë±ìŠ¤
  if (window.__brakeGuideOn) {
  for(let n=0;n<maxNotch;n++){
    const a=brakeDecels[n]??0; if(a<=0) continue;
    const s=(v0*v0)/(2*a);
    ctx.beginPath(); ctx.strokeStyle = n===lever ? "#ffae00" : "#3fa9ff";
    for(let i=0;i<=100;i++){
      const f=i/100, ds=s*f, v=Math.sqrt(Math.max(0,v0*v0-2*a*ds));
      const x=X(ds), y=Y(v*3.6); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.fillStyle=n===lever?"#ffae00":"#3fa9ff"; ctx.font=`${12*dpr}px 'Orbitron', sans-serif`;
    const tX=X(s); const label = (n===0) ? "N" : (n===maxIdx ? "EB" : `B${n}`);
    ctx.fillText(label, tX+5*dpr, Y(0)+12*dpr);
  }
  const xRed=X(remaining); ctx.strokeStyle="#f00"; ctx.lineWidth=1.5*dpr; ctx.beginPath(); ctx.moveTo(xRed,Y(0)); ctx.lineTo(xRed,Y(vmax)); ctx.stroke();
  ctx.fillStyle="#f00"; ctx.font=`${14*dpr}px 'Orbitron', sans-serif`; ctx.textAlign="center"; ctx.fillText("ë‚¨ì€ ê±°ë¦¬", xRed, Y(vmax)-18*dpr);
}

  // const ribbonW=16*dpr, ribbonH=h*.9, ribbonX=w-right-ribbonW-10*dpr+20, ribbonY=((h-ribbonH)/2)-32;
  // ctx.fillStyle="rgba(100,100,100,.1)"; ctx.strokeStyle="rgba(100,100,100,.3)"; ctx.lineWidth=1.5*dpr;
  // ctx.beginPath(); ctx.rect(ribbonX,ribbonY,ribbonW,ribbonH); ctx.fill(); ctx.stroke();

  // const centerY=(ribbonY+ribbonH/2)-14, barH=12*dpr;
  // ctx.fillStyle="rgba(60,60,60,.9)"; ctx.fillRect(ribbonX+2*dpr, centerY-barH/2, ribbonW-4*dpr, barH);

  
// ë‚ ì”¨ê°€ ë§‘ìŒì´ë©´ ë°˜íˆ¬ëª… í°ìƒ‰ í†¤ ì‚¬ìš©
const isClear = (weatherSelect?.value === "ë§‘ìŒ");

  // ë¦¬ë³¸(íšŒìƒ‰ ì‚¬ê°í˜•) í…Œë‘ë¦¬/ì±„ì›€
  const ribbonFill = isClear ? "rgba(255,255,255,0.12)" : "rgba(100,100,100,0.10)";
  const ribbonStroke = isClear ? "rgba(255,255,255,0.35)" : "rgba(100,100,100,0.30)";

  // ê°€ìš´ë° ê°€ë¡œ ë°”(ê¸°ì¤€ ë°”)
  const centerBarFill = isClear ? "rgba(255,255,255,0.50)" : "rgba(60,60,60,0.90)";

  // ë‹¤ì´ì•„ëª¬ë“œ(ì •ì°¨ ìœ„ì¹˜ ë§ˆì»¤)
  const diamondFill = isClear ? "rgba(255,255,255,0.70)" : "#444";
  const diamondStroke = isClear ? "#FFD500" : "#222";


  // PC/ëª¨ë°”ì¼ íŒë³„
  const isMobile = window.innerWidth < 768; 
  // also draw the large right-side ribbon (fixed canvas)
  try{ if(typeof drawRightRibbon === 'function') drawRightRibbon(st); }catch(e){}

/* === TASC ê²½ê³ ë“± (HUD ìœ„) === */
/* === TASC ê²½ê³ ë“± (HUD ìœ„) === */
/* === TASC ê²½ê³ ë“± (HUD ìœ„) === */
{
  const pad = 8 * dpr;       // í…ìŠ¤íŠ¸ì™€ í…Œë‘ë¦¬ ì‚¬ì´ ì—¬ë°±
  const textW = 18 * dpr;    
  const textH = 9 * dpr;     
  const radius = 2 * dpr;    // ëª¨ì„œë¦¬ ë°˜ê²½

  const lightW = textW + pad*2 + 8*dpr; // ê¸°ì¡´ë³´ë‹¤ 6px ë” ëŠ˜ë¦¼
  const lightH = textH + pad*2 - 2*dpr; // ê¸°ì¡´ë³´ë‹¤ 2px ì¤„ì„

  const isMobile = window.innerWidth < 768;
  const lightX = isMobile 
    ? w - lightW - 35 * dpr
    : w - lightW - 30 * dpr;
  const lightY = 15 * dpr;

  const blinkOn = Math.floor(Date.now() / 250) % 2 === 0;

  // Set the fill color based on the state
  let fillColor = "#444"; 
  if (!st.tasc_armed && !st.tasc_enabled) fillColor = "#444";
  else if (st.tasc_active) fillColor = "#fec670";
  else if (st.tasc_armed && !st.tasc_active && blinkOn) fillColor = "#fec670";

  // Draw rounded rectangle for TASC light
  ctx.beginPath();
  ctx.moveTo(lightX + radius, lightY);
  ctx.lineTo(lightX + lightW - radius, lightY);
  ctx.quadraticCurveTo(lightX + lightW, lightY, lightX + lightW, lightY + radius);
  ctx.lineTo(lightX + lightW, lightY + lightH - radius);
  ctx.quadraticCurveTo(lightX + lightW, lightY + lightH, lightX + lightW - radius, lightY + lightH);
  ctx.lineTo(lightX + radius, lightY + lightH);
  ctx.quadraticCurveTo(lightX, lightY + lightH, lightX, lightY + lightH - radius);
  ctx.lineTo(lightX, lightY + radius);
  ctx.quadraticCurveTo(lightX, lightY, lightX + radius, lightY);
  ctx.closePath();

  // Fill the rectangle with the color
  ctx.fillStyle = fillColor;
  ctx.fill();

  // Apply gradient stroke for a 3D effect
  const gradient = ctx.createLinearGradient(lightX, lightY, lightX, lightY + lightH);
  gradient.addColorStop(0, "#999");  // Lighter gray at the top
  gradient.addColorStop(1, "#444");  // Darker gray at the bottom

  // Set stroke style to the gradient
  ctx.lineWidth = 2 * dpr;
  ctx.strokeStyle = gradient;
  ctx.stroke();

  // Set text style and alignment for TASC text
  let tascTextColor = "#fff"; // ê¸°ë³¸ í…ìŠ¤íŠ¸ ìƒ‰ìƒ (í°ìƒ‰)

  // ë¶ˆì´ ë“¤ì–´ì™”ì„ ë•Œ ìë™ ë²„íŠ¼ì²˜ëŸ¼ ê²€ì€ìƒ‰ìœ¼ë¡œ ë°”ê¾¸ê¸°
  if (st.tasc_enabled && st.tasc_active) {
    tascTextColor = "#000";  // ë¶ˆì´ ë“¤ì–´ì˜¤ë©´ í…ìŠ¤íŠ¸ ìƒ‰ìƒ ê²€ì€ìƒ‰
  }

  ctx.fillStyle = tascTextColor; // í…ìŠ¤íŠ¸ ìƒ‰ìƒ ë³€ê²½
  ctx.font = `${7 * dpr}px 'A-OTF Shin Go Pro', sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";

  // Split text by newline and position each line
  const text = "TASC\nìë™";
  const lines = text.split("\n");
  const lineHeight = 10 * dpr; // Adjust this value for spacing between lines

  // Draw each line at the center position
  lines.forEach((line, index) => {
    ctx.fillText(line, lightX + lightW / 2, lightY + lightH / 2 + index * lineHeight);
  });

  /* === ì •ìœ„ì¹˜ ì •ì°¨ ë²„íŠ¼ (ì´ˆë¡ìƒ‰) === */
  const stopBtnX = lightX - lightW - 3 * dpr;  // ì •ìœ„ì¹˜ ì •ì°¨ ë²„íŠ¼ì˜ X ìœ„ì¹˜
  const stopBtnY = lightY;  // Y ìœ„ì¹˜ëŠ” TASC ê²½ê³ ë“±ê³¼ ë™ì¼í•˜ê²Œ

  const stopBtnW = textW + pad * 2 + 8 * dpr; // ì •ìœ„ì¹˜ ì •ì°¨ ë²„íŠ¼ì˜ ë„ˆë¹„
  const stopBtnH = textH + pad * 2 - 2 * dpr; // ì •ìœ„ì¹˜ ì •ì°¨ ë²„íŠ¼ì˜ ë†’ì´

  let stopBtnColor = "#444"; // ê¸°ë³¸ íšŒìƒ‰
  let stopTextColor = "#fff"; // ê¸°ë³¸ í…ìŠ¤íŠ¸ ìƒ‰ìƒ (í°ìƒ‰)

  // Check if the button should be green (ì •ìœ„ì¹˜ ì •ì°¨ ì™„ë£Œ ìƒíƒœ)
  if (st.tasc_enabled && st.v == 0) {
    stopBtnColor = "#9be071";  // ì´ˆë¡ìƒ‰ (ì •ìœ„ì¹˜ ì •ì°¨ ì™„ë£Œ ìƒíƒœ)
    stopTextColor = "#000";  // ì´ˆë¡ìƒ‰ì¼ ë•Œ í…ìŠ¤íŠ¸ ìƒ‰ìƒ ê²€ì€ìƒ‰
  }

  // Draw rounded rectangle for Stop Button
  ctx.beginPath();
  ctx.moveTo(stopBtnX + radius, stopBtnY);
  ctx.lineTo(stopBtnX + stopBtnW - radius, stopBtnY);
  ctx.quadraticCurveTo(stopBtnX + stopBtnW, stopBtnY, stopBtnX + stopBtnW, stopBtnY + radius);
  ctx.lineTo(stopBtnX + stopBtnW, stopBtnY + stopBtnH - radius);
  ctx.quadraticCurveTo(stopBtnX + stopBtnW, stopBtnY + stopBtnH, stopBtnX + stopBtnW - radius, stopBtnY + stopBtnH);
  ctx.lineTo(stopBtnX + radius, stopBtnY + stopBtnH);
  ctx.quadraticCurveTo(stopBtnX, stopBtnY + stopBtnH, stopBtnX, stopBtnY + stopBtnH - radius);
  ctx.lineTo(stopBtnX, stopBtnY + radius);
  ctx.quadraticCurveTo(stopBtnX, stopBtnY, stopBtnX + radius, stopBtnY);
  ctx.closePath();

  // Fill the button with the color
  ctx.fillStyle = stopBtnColor;
  ctx.fill();

  // Apply gradient stroke for a 3D effect
  const stopBtnGradient = ctx.createLinearGradient(stopBtnX, stopBtnY, stopBtnX, stopBtnY + stopBtnH);
  stopBtnGradient.addColorStop(0, "#999");  // Lighter gray at the top
  stopBtnGradient.addColorStop(1, "#444");  // Darker gray at the bottom

  // Set stroke style to the gradient
  ctx.lineWidth = 2 * dpr;
  ctx.strokeStyle = stopBtnGradient;
  ctx.stroke();

  // Set text style and alignment for Stop Button text
  ctx.fillStyle = stopTextColor;  // í…ìŠ¤íŠ¸ ìƒ‰ìƒì€ ì •ìœ„ì¹˜ ìƒíƒœì— ë”°ë¼ ê²°ì •
  ctx.font = `${7 * dpr}px 'A-OTF Shin Go Pro', sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";

  // Draw text for the Stop Button
  const stopText = "TASC\nì •ìœ„ì¹˜";
  const stopLines = stopText.split("\n");
  const stopLineHeight = 10 * dpr;  // Adjust this value for spacing between lines

  // Draw each line of text at the center position
  stopLines.forEach((line, index) => {
    ctx.fillText(line, stopBtnX + stopBtnW / 2, stopBtnY + stopBtnH / 2 + index * stopLineHeight);
  });


/* === í¸ì„±ìˆ˜ í‘œì‹œ (ì •ìœ„ì¹˜ ë²„íŠ¼ ì™¼ìª½) === */
{
  let trainLength = parseInt(document.getElementById("trainLength").value, 10);
  if (Number.isNaN(trainLength)) trainLength = 10;
  const pad = 6 * dpr;
  const boxW = 32 * dpr;
  const boxH = 24.5 * dpr;
  const radius = 4 * dpr;

  // ì •ìœ„ì¹˜ ë²„íŠ¼ ìœ„ì¹˜ ì°¸ê³ 
  const boxX = stopBtnX - boxW - 4*dpr; // ì •ìœ„ì¹˜ ë²„íŠ¼ ì™¼ìª½ì— 4px ê°„ê²©
  const boxY = stopBtnY - 0.5*dpr;                // Y ìœ„ì¹˜ ë§ì¶¤

  // ë°•ìŠ¤ ê·¸ë¦¬ê¸°
  ctx.fillStyle = "#ff5757";
  ctx.beginPath();
  ctx.moveTo(boxX + radius, boxY);
  ctx.lineTo(boxX + boxW - radius, boxY);
  ctx.quadraticCurveTo(boxX + boxW, boxY, boxX + boxW, boxY + radius);
  ctx.lineTo(boxX + boxW, boxY + boxH - radius);
  ctx.quadraticCurveTo(boxX + boxW, boxY + boxH, boxX + boxW - radius, boxY + boxH);
  ctx.lineTo(boxX + radius, boxY + boxH);
  ctx.quadraticCurveTo(boxX, boxY + boxH, boxX, boxY + boxH - radius);
  ctx.lineTo(boxX, boxY + radius);
  ctx.quadraticCurveTo(boxX, boxY, boxX + radius, boxY);
  ctx.closePath();
  ctx.fill();

  // ìˆ«ì í‘œì‹œ
  ctx.fillStyle = "#000"; // ìˆ«ì ìƒ‰ìƒ
  ctx.font = `${12*dpr}px 'A-OTF Shin Go Pro', sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(trainLength, boxX + boxW/2, boxY + boxH/2);
}
}

}


/* ===== ë¸Œë ˆì´í¬ ë¯¸ë‹ˆ ì¸ë””ì¼€ì´í„° ===== */
const ladderCanvas = document.getElementById('brakeLadder');
function sizeLadderCanvas() {
  if (!ladderCanvas) return;
  const dpr = window.devicePixelRatio || 1;
  const cssW = ladderCanvas.clientWidth;
  const cssH = ladderCanvas.clientHeight;
  ladderCanvas.width  = Math.max(1, Math.round(cssW * dpr));
  ladderCanvas.height = Math.max(1, Math.round(cssH * dpr));
}
addEventListener('resize', sizeLadderCanvas);
sizeLadderCanvas();

// Cab mini ladder (small canvas above cab dash)
const cabLadderCanvas = document.getElementById('cabBrakeLadder');
function sizeCabLadderCanvas() {
  if (!cabLadderCanvas) return;
  const dpr = window.devicePixelRatio || 1;
  const cssW = cabLadderCanvas.clientWidth || 44;
  const cssH = cabLadderCanvas.clientHeight || 72;
  cabLadderCanvas.width  = Math.max(1, Math.round(cssW * dpr));
  cabLadderCanvas.height = Math.max(1, Math.round(cssH * dpr));
}
addEventListener('resize', sizeCabLadderCanvas);
sizeCabLadderCanvas();

function drawBrakeLadderMini(st) {
  const ctx2 = ladderCanvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const w = ladderCanvas.width, h = ladderCanvas.height;
  if (!w || !h) return;
  ctx2.clearRect(0, 0, w, h);

const accArr = (vehicle && Array.isArray(vehicle.notch_accels)) ? vehicle.notch_accels : null;
const ebIdx = getEbIndex();

  const blocks  = ebIdx;
  const cur     = Math.max(0, Math.min(ebIdx, st.lever_notch|0));

  ctx2.fillStyle = "rgba(100,100,100,0.10)";
  ctx2.fillRect(0, 0, w, h);

  const pad  = 2 * dpr;
  const gap  = Math.max(2 * dpr, Math.round(h * 0.02));
  const bH   = (h - pad*2 - gap*(blocks-1)) / blocks;
  const bW   = w - pad*2;
  const x    = pad;

  for (let k = 1; k <= ebIdx - 1; k++) {
    const i = k - 1;
    const y = h - pad - (i + 1) * bH - i * gap;
    ctx2.fillStyle = "rgba(60,80,100,0.35)";
    ctx2.fillRect(x, y, bW, bH);
    if (cur !== ebIdx && k <= cur) { ctx2.fillStyle = "#ffd34d"; ctx2.fillRect(x, y, bW, bH); }
    ctx2.strokeStyle = "rgba(20,30,45,0.6)";
    ctx2.lineWidth   = 1 * dpr;
    ctx2.strokeRect(x, y, bW, bH);
  }

  const yEB = h - pad - (ebIdx) * bH - (ebIdx - 1) * gap;
  ctx2.fillStyle = "rgba(60,80,100,0.35)";
  ctx2.fillRect(x, yEB, bW, bH);
  if (cur === ebIdx) { ctx2.fillStyle = "#ff5757"; ctx2.fillRect(x, yEB, bW, bH); }
  ctx2.strokeStyle = "rgba(20,30,45,0.6)";
  ctx2.lineWidth   = 1 * dpr;
  ctx2.strokeRect(x, yEB, bW, bH);

  
}

function drawCabBrakeLadder(st) {
  if (!cabLadderCanvas) return;
  const ctx2 = cabLadderCanvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const w = cabLadderCanvas.width, h = cabLadderCanvas.height;
  if (!w || !h) return;
  ctx2.clearRect(0, 0, w, h);

  const accArr  = (vehicle && Array.isArray(vehicle.notch_accels)) ? vehicle.notch_accels : null;
  const notches = accArr ? accArr.length : (vehicle && Number.isInteger(vehicle.notches) ? vehicle.notches : 10);
  const ebIdx   = accArr ? Math.max(1, accArr.length - 1) : Math.max(1, notches - 1);
  const blocks  = ebIdx;
  const cur     = Math.max(0, Math.min(ebIdx, st.lever_notch|0));

  // light background
  ctx2.fillStyle = "rgba(0,0,0,0.0)";
  ctx2.fillRect(0, 0, w, h);

  const pad  = Math.max(1 * dpr, Math.round(w * 0.04));
  const gap  = Math.max(1 * dpr, Math.round(h * 0.02));
  const bH   = (h - pad*2 - gap*(blocks-1)) / blocks;
  const bW   = w - pad*2;
  const x    = pad;

  for (let k = 1; k <= ebIdx - 1; k++) {
    const i = k - 1;
    const y = h - pad - (i + 1) * bH - i * gap;
    ctx2.fillStyle = "rgba(60,80,100,0.35)";
    ctx2.fillRect(x, y, bW, bH);
    if (cur !== ebIdx && k <= cur) { ctx2.fillStyle = "#ffd34d"; ctx2.fillRect(x, y, bW, bH); }
    ctx2.strokeStyle = "rgba(20,30,45,0.6)";
    ctx2.lineWidth   = 1 * dpr;
    ctx2.strokeRect(x, y, bW, bH);
  }

  const yEB = h - pad - (ebIdx) * bH - (ebIdx - 1) * gap;
  ctx2.fillStyle = "rgba(60,80,100,0.35)";
  ctx2.fillRect(x, yEB, bW, bH);
  if (cur === ebIdx) { ctx2.fillStyle = "#ff5757"; ctx2.fillRect(x, yEB, bW, bH); }
  ctx2.strokeStyle = "rgba(20,30,45,0.6)";
  ctx2.lineWidth   = 1 * dpr;
  ctx2.strokeRect(x, yEB, bW, bH);

}

/* ===== í° ìš°ì¸¡ ë¦¬ë³¸ ìº”ë²„ìŠ¤ (ê³ ì •) ===== */
const ribbonBigCanvas = document.getElementById('ribbonBig');
function sizeRibbonBigCanvas() {
  if (!ribbonBigCanvas) return;
  const dpr = window.devicePixelRatio || 1;
  const cssW = ribbonBigCanvas.clientWidth || 72;
  const cssH = ribbonBigCanvas.clientHeight || (window.innerHeight * 0.8);
  ribbonBigCanvas.width = Math.max(1, Math.round(cssW * dpr));
  ribbonBigCanvas.height = Math.max(1, Math.round(cssH * dpr));
}
addEventListener('resize', sizeRibbonBigCanvas);
sizeRibbonBigCanvas();

function drawRightRibbon(st){
  if (!ribbonBigCanvas) return;
  if (!st) return;
  const ctxR = ribbonBigCanvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const w = ribbonBigCanvas.width, h = ribbonBigCanvas.height;
  ctxR.clearRect(0,0,w,h);

  // ìƒ‰ìƒ/ëª¨ë“œ ì¬ì‚¬ìš© (ì¼ê´€ëœ ìŠ¤íƒ€ì¼)
  const isClear = (weatherSelect?.value === "ë§‘ìŒ");
  const ribbonFill = isClear ? "rgba(255,255,255,0.01)" : "rgba(100,100,100,0.10)";
  const ribbonStroke = isClear ? "rgba(255,255,255,0.35)" : "rgba(100,100,100,0.30)";
  const centerBarFill = "rgba(16, 250, 13, 0.90)"; // ì—°í•œ ì´ˆë¡ìƒ‰
  const diamondFill= "rgba(255,241,0,0.90)";
  const diamondStroke= "#FD0800";

  // ëª¨ë°”ì¼/ë°ìŠ¤í¬í†± ë³´ì • (ì›ë˜ì™€ ë¹„ìŠ·í•œ ë¹„ìœ¨ ìœ ì§€)
  const isMobileLocal = window.innerWidth < 768;
  // Do not draw on mobile (CSS also hides the canvas) to save CPU
  if (isMobileLocal) { ctxR.clearRect(0,0,w,h); return; }
  const offsetRibbonY = isMobileLocal ? -32 : -12;
  const offsetCenterY = isMobileLocal ? -14 : -7.5;

  // ë” í¬ê²Œ ë³´ì´ê²Œ ìŠ¤ì¼€ì¼ì„ í‚¤ì›€
  const scale = 3; // ì›í•˜ëŠ” ë§Œí¼ í‚¤ìš°ì„¸ìš” (2~4 ê¶Œì¥)
  const ribbonW = Math.min(72 * dpr, 24 * dpr * scale);
  const ribbonH = h * 0.95;
  const ribbonX = (w - ribbonW) / 2;
  const ribbonY = ((h - ribbonH) / 2) + offsetRibbonY * dpr;

  // ë°°ê²½ ë°•ìŠ¤
  ctxR.fillStyle = ribbonFill;
  ctxR.strokeStyle = ribbonStroke;
  ctxR.lineWidth = 1.5 * dpr;
  ctxR.beginPath();
  ctxR.rect(ribbonX, ribbonY, ribbonW, ribbonH);
  ctxR.fill();
  ctxR.stroke();

  // ì¤‘ì•™ ë°”
  const centerY = (ribbonY + ribbonH / 2) + offsetCenterY * dpr;
  // Make the center bar larger: increase height and reduce horizontal padding so it appears wider
  const barHeightBase = 60; // px base at DPR=1 (tweak this to change size)
  const barH = barHeightBase * dpr * scale; // taller than default
  const horizontalPadding = 1 * dpr; // smaller padding -> wider bar
  ctxR.fillStyle = centerBarFill;
  ctxR.fillRect(ribbonX + horizontalPadding, centerY - barH / 2, ribbonW - horizontalPadding * 2, barH);

  // ë‚´ë¶€ì— ì‘ì€ ë°˜íˆ¬ëª… í°ìƒ‰ ë°•ìŠ¤ ì¶”ê°€ (ë„ˆë¹„ ë™ì¼, ë†’ì´ë§Œ ì‘ìŒ)
  (function(){
    const innerWidth = Math.max(4 * dpr, ribbonW - horizontalPadding * 2); // same width as bar
    const innerHeight = barH * 0.15; // smaller height
    const innerX = ribbonX + horizontalPadding;
    const innerY = centerY - innerHeight / 2;
    ctxR.fillStyle = 'rgba(204, 253, 208, 0.8)';
    ctxR.fillRect(innerX, innerY, innerWidth, innerHeight);
  })();

  // ë‹¤ì´ì•„ëª¬ë“œ ìœ„ì¹˜
  const rem = Math.min(Math.max(st.remaining_m ?? st.L, -st.L), st.L);
  const diamondW = 8 * dpr * scale, diamondH = 5 * dpr * scale, dX = ribbonX + ribbonW / 2;
  const normalized = (rem - (-5)) / (5 - (-5));
  const dY = ribbonY + (ribbonH * (1 - normalized)) - diamondH / 2;
  const adjY = Math.min(Math.max(dY, ribbonY - 10 * dpr), ribbonY + ribbonH - diamondH + 10 * dpr);

  ctxR.fillStyle = diamondFill; ctxR.strokeStyle = diamondStroke;
  ctxR.lineWidth = 2 * dpr;
  ctxR.beginPath();
  ctxR.moveTo(dX, adjY - diamondH / 2);
  ctxR.lineTo(dX + diamondW / 2, adjY);
  ctxR.lineTo(dX, adjY + diamondH / 2);
  ctxR.lineTo(dX - diamondW / 2, adjY);
  ctxR.closePath();
  ctxR.fill();
  ctxR.stroke();
}

/* ===== ì „ë™ì°¨/ì‹œë¦¬ì¦ˆ/í¸ì„± ===== */
const TRAIN_DB={
  E233:[
    {code:"JR EAST E233-1000", lines:"ê²Œì´íŒí† í˜¸ì¿ ì„ Â·ë„¤ê¸°ì‹œì„  | ë‹¤ì´ì•„ê·¸ë¨: ì˜¤ë¯¸ì•¼ â†’ ì¹´ì™€êµ¬ì¹˜", file:"/static/emu_db/e233_1000.json", lengths:[10]},
    {code:"JR EAST E233-2000", lines:"ì¡°ë°˜ ì™„í–‰ì„ , ì¹˜ìš”ë‹¤ì„ , ì˜¤ë‹¤ì™€ë¼ì„ , íƒ€ë§ˆì„ ", file:"/static/emu_db/e233_2000.json", lengths:[10]},
    {code:"JR EAST E233-3000", lines:"ìš°ì—ë…¸ë„ì¿„ë¼ì¸, ì‡¼ë‚œì‹ ì£¼ì¿ ë¼ì¸", file:"/static/emu_db/e233_3000.json", lengths:[5,10,15]}
  ],
  E235:[
    {code:"JR EAST E235-0", lines:"ì•¼ë§ˆë…¸í…Œì„  | ë‹¤ì´ì•„ê·¸ë¨: ë„ì¿„ â†’ ë„ì¿„", file:"/static/emu_db/e235_0.json", lengths:[11]},
    {code:"JR EAST E235-1000", lines:"ìš”ì½”ìŠ¤ì¹´ì„ , ì†Œë¶€ ì¾Œì†ì„ , ë‚˜ë¦¬íƒ€ì„ , ìš°ì¹˜ë³´ì„ , ì†Œí† ë³´ì„ , ì¹´ì‹œë§ˆì„ , ì†Œë¶€ ë³¸ì„ , íŒì¹´ì¿ ì„ ", file:"/static/emu_db/e235_1000.json", lengths:[4,11,15]}
  ],
  JRW223: [
    { code: "JR WEST 223-0",
      lines: "ì˜¤ì‚¬ì¹´ ìˆœí™˜ì„  Â· í•œì™€ì„  Â· ê°„ì‚¬ì´ê³µí•­ì„  ì§ê²° Â· ê¸°ë…¸ì¿ ë‹ˆì„ ",
      file: "/static/emu_db/223_0000.json", lengths: [4] },
    { code: "JR WEST 223-1000",
      lines: "ë¹„ì™€ì½”Â·JR êµí† Â·JR ê³ ë²  ë¼ì¸ ë“±",
      file: "/static/emu_db/223_1000.json", lengths: [4,8] }
  ],
  JRW225: [
    { code: "JR WEST 225-0",
      lines: "ë¹„ì™€ì½”Â·JR êµí† Â·JR ê³ ë²  ë¼ì¸ ë“±",
      file: "/static/emu_db/225_0000.json", lengths: [4,8] },
    { code: "JR WEST 225-5000",
      lines: "ì˜¤ì‚¬ì¹´ ìˆœí™˜ì„  Â· í•œì™€ì„  Â· ê°„ì‚¬ì´ê³µí•­ì„ ",
      file: "/static/emu_db/225_5000.json", lengths: [4] },
    { code: "JR WEST 225-6000",
      lines: "JR ê³ ë² ì„  Â· í›„ì¿ ì¹˜ì•¼ë§ˆì„ ",
      file: "/static/emu_db/225_6000.json", lengths: [4,6] }
  ],
  JRW323: [{ code: "JR WEST 323-0", lines: "ì˜¤ì‚¬ì¹´ ìˆœí™˜ì„  ì „ìš©", file: "/static/emu_db/323_0000.json", lengths: [8] }],
  JRW285: [{ code: "JR WEST 285-0/3000", lines: "ì¼ë°˜ ì¹¨ëŒ€íŠ¹ê¸‰ ì„ ë¼ì´ì¦ˆ ì´ì¦ˆëª¨Â·ì„¸í† ", file: "/static/emu_db/285.json", lengths: [7, 14] }],
  JRH261: [{ code: "JR HOKKAIDO KiHa 261-5000", lines: "ë¶í•´ë„ì˜ í˜¹í•œì— ìµœì í™”ëœ íŠ¹ê¸‰ ë””ì ¤ë™ì°¨", file: "/static/emu_db/261_5000.json", lengths: [4, 5, 6, 10] }],
JR103: [{
  code: "JR/JNR 103-0",
  lines: "1960~80ë…„ëŒ€ ì¼ë³¸ í†µê·¼í˜• ì „ë™ì°¨ì˜ ìƒì§•",
  file: "/static/emu_db/103.json",
  lengths: [4, 6, 8, 10, 15]
}],
EF510: [{
  code: "JR EAST Cassiopeia â€¢ ì´ˆí˜¸í™” ì¹¨ëŒ€íŠ¹ê¸‰",
  lines: "ìš°ì—ë…¸â†”ì•„ì˜¤ëª¨ë¦¬",
  file: "/static/emu_db/e26.json",
  lengths: [13]
}],
K3000: [{
  code: "Keisei 3000",
  lines: "ì¼€ì´ì„¸ì´ ë³¸ì„ , ë‚˜ë¦¬íƒ€ ê³µí•­ì„ ",
  file: "/static/emu_db/keisei3000.json",
  lengths: [6, 8]
}],
T5300: [{
  code: "Toei 5300",
  lines: "ë„ì—ì´ ì•„ì‚¬ì¿ ì‚¬ì„ , ì¼€ì´ì„¸ì´ ë³¸ì„ , ê²Œì´í ë³¸ì„ ",
  file: "/static/emu_db/toei5300.json",
  lengths: [8]
}],
N700S: [{
  code: "N700S-3000 H, Jí¸ì„±",
  lines: "ë„ì¹´ì´ë„ ì‹ ì¹¸ì„¼: ë„ì¿„â†”ì‹ ì˜¤ì‚¬ì¹´ | ë‹¤ì´ì•„ê·¸ë¨: [ë…¸ì¡°ë¯¸] ì‹ ì½”ë²  â†’ ì‹ ì˜¤ì‚¬ì¹´",
  file: "/static/emu_db/n700s_3000.json",
  lengths: [16]
}],
3000: [{
  code: "ì„œìš¸êµí†µê³µì‚¬ 3000í˜¸ëŒ€ VVVF ì „ë™ì°¨",
  lines: "ìˆ˜ë„ê¶Œ ì „ì²  3í˜¸ì„  | ë‹¤ì´ì•„ê·¸ë¨: ë„ê³¡ â†’ ê²½ë³µê¶",
  file: "/static/emu_db/s3000.json",
  lengths: [10]
}],
100000: [{
  code: "KTX-I",
  lines: "ê²½ë¶€ê³ ì†ì² ë„Â·í˜¸ë‚¨ê³ ì†ì² ë„ | ë‹¤ì´ì•„ê·¸ë¨: ìš¸ì‚° â†’ ë¶€ì‚°",
  file: "/static/emu_db/ktx1.json",
  lengths: [20]
}],
GE999: [{
  code: "ëŒ€ì€í•˜ë³¸ì„ (å¤§éŠ€æ²³æœ¬ç·š) ì€í•˜\"ì´ˆ\"íŠ¹ê¸‰(éŠ€æ²³è¶…ç‰¹æ€¥) 999",
  lines: "ì§€êµ¬(åœ°çƒ) â†’ ì•ˆë“œë¡œë©”ë‹¤(ã‚¢ãƒ³ãƒ‰ãƒ­ãƒ¡ãƒ€)",
  file: "/static/emu_db/galaxy999.json",
  lengths: [11]
}],
E721: [
  {
    code: "JR EAST E721-1000",
    lines: "ì„¼ë‹¤ì´ ê³µí•­ ì•¡ì„¸ìŠ¤ì„ ",
    file: "/static/emu_db/e721_1000.json",
    lengths: [4],
  }
]


};


// ===== Overlay train preview =====
const previewImg = document.getElementById('trainPreviewImg');
const previewName = document.getElementById('trainPreviewName');
const previewLine = document.getElementById('trainPreviewLine');
const previewFamily = document.getElementById('trainPreviewFamily');
const previewFormation = document.getElementById('trainPreviewFormation');
const previewCaption = document.getElementById('trainPreviewCaption');

//  ë‚œì´ë„ ê²Œì´ì§€ ì—˜ë¦¬ë¨¼íŠ¸
const brakeGaugeEl = document.getElementById('brakeDiffGauge');
const ctrlGaugeEl = document.getElementById('ctrlDiffGauge');

// 1~5 ë‚œì´ë„ë¥¼ ì´ˆë¡â†’ë…¸ë‘â†’ì£¼í™©â†’ë¹¨ê°• ê·¸ë¼ë°ì´ì…˜ìœ¼ë¡œ ë§¤í•‘
function colorForLevel(level){
  const clampLevel = Math.max(1, Math.min(5, Number(level) || 1));
  const t = (clampLevel - 1) / 4; // 0 ~ 1

  // #4cd964(ì´ˆë¡) â†’ #ffcc00(ë…¸ë‘) â†’ #ff3b30(ë¹¨ê°•)
  const g = { r: 0x4c, g: 0xd9, b: 0x64 }; // 76,217,100
  const y = { r: 0xff, g: 0xcc, b: 0x00 }; // 255,204,0
  const r = { r: 0xff, g: 0x3b, b: 0x30 }; // 255,59,48

  const lerp = (a,b,u)=> a + (b-a)*u;

  let c;
  if (t <= 0.5){
    const u = t / 0.5; // 0~1, green â†’ yellow
    c = {
      r: lerp(g.r, y.r, u),
      g: lerp(g.g, y.g, u),
      b: lerp(g.b, y.b, u)
    };
  } else {
    const u = (t - 0.5) / 0.5; // 0~1, yellow â†’ red
    c = {
      r: lerp(y.r, r.r, u),
      g: lerp(y.g, r.g, u),
      b: lerp(y.b, r.b, u)
    };
  }

  const rInt = Math.round(c.r);
  const gInt = Math.round(c.g);
  const bInt = Math.round(c.b);

  return {
    color: `rgb(${rInt}, ${gInt}, ${bInt})`,
    shadow: `rgba(${rInt}, ${gInt}, ${bInt}, 0.85)`
  };
}

function setDifficultyGauge(gaugeEl, level){
  if (!gaugeEl) return;

  const cells = gaugeEl.querySelectorAll('.cell');
  const n = Math.max(1, Math.min(5, Number(level) || 1)); // 1~5 ë¡œ í´ë¨í”„
  const { color, shadow } = colorForLevel(n);

  cells.forEach((cell, idx) => {
    const active = idx < n;
    cell.classList.toggle('active', active);

    if (active){
      // CSS ë³€ìˆ˜ë¡œ ìƒ‰ìƒ ì „ë‹¬
      cell.style.setProperty('--diff-color', color);
      cell.style.setProperty('--diff-shadow', shadow);
    } else {
      cell.style.removeProperty('--diff-color');
      cell.style.removeProperty('--diff-shadow');
    }
  });
}
 
function updateTrainDifficultyBadges(vehicle){
  if (!vehicle) return;

  const brake = Number(vehicle.brake_difficulty ?? 0) || 0;
  const ctrl = Number(vehicle.ctrl_difficulty ?? 0) || 0;

  setDifficultyGauge(brakeGaugeEl, brake || 3); // ê°’ ì—†ìœ¼ë©´ ê¸°ë³¸ 3
  setDifficultyGauge(ctrlGaugeEl, ctrl || 3);

  // ë‹¤ì´ì–´ê·¸ë¨ ì‹œê°„ ì—…ë°ì´íŠ¸
  const diagramTimeBadge = document.getElementById('diagramTimeBadge');
  const diagramTimeText = document.getElementById('diagramTimeText');
  
  if (vehicle.diagram_time) {
    diagramTimeText.textContent = vehicle.diagram_time;
    diagramTimeBadge.style.display = 'inline-flex';
  } else {
    diagramTimeBadge.style.display = 'none';
  }
}

function updateTrainPreview(info){
  if (!info || !previewImg) return;

  const file = info.file || "";
  const imgPath = file.endsWith(".json")
    ? file.replace(".json", ".png")
    : file; // í˜¹ì‹œ ì§ì ‘ png ê²½ë¡œë¥¼ ë„£ê³  ì‹¶ì„ ë•Œë„ ëŒ€ì‘

  previewImg.src = imgPath;
  previewImg.alt = info.code || "Train preview";

  if (previewName) previewName.textContent = info.code || "Train series";
  if (previewLine) previewLine.textContent = info.lines || "";
  if (previewFamily) previewFamily.textContent = (info.family || "").toString() + "ê³„";

  if (previewFormation) {
    const lens = Array.isArray(info.lengths) ? info.lengths : [];
    previewFormation.textContent = lens.length
      ? lens.map(l => `${l}ëŸ‰ í¸ì„±`).join(" Â· ")
      : "";
  }

   if (previewCaption) {
    if (info.description && info.description.trim() !== "") {
      previewCaption.textContent = info.description;
    } else {
      // description ì—†ìœ¼ë©´ ê¸°ì¡´ ê¸°ë³¸ ë¬¸êµ¬ ìœ ì§€í•˜ê³  ì‹¶ìœ¼ë©´ ì´ ì¤„ë§Œ ì£¼ì„ ì²˜ë¦¬
      previewCaption.textContent = "ì „ë™ì°¨ ê³„ì—´ê³¼ ì‹œë¦¬ì¦ˆ, í¸ì„±ì„ ë³€ê²½í•˜ë©´ ì´ ì˜ì—­ì— í•´ë‹¹ ì—´ì°¨ì˜ ì™¸í˜• ì´ë¯¸ì§€ì™€ ë…¸ì„  ì •ë³´ê°€ ë¯¸ë¦¬ë³´ê¸°ë¡œ í‘œì‹œë©ë‹ˆë‹¤.";
    }
  }
}


const trainFamilyEl=document.getElementById('trainFamily');
const trainSeriesEl=document.getElementById('trainSeries');
const trainLengthEl=document.getElementById('trainLength');

function setTrainLengthOptions(lengths){
  trainLengthEl.innerHTML="";
  lengths.forEach(len=>{
    const opt=document.createElement('option');
    opt.value=String(len); opt.textContent=`${len}ëŸ‰`;
    trainLengthEl.appendChild(opt);
  });
  // updateTrainLength();
  // If the 3D scene has already created platform signs, refresh their textures
  try {
    if (window.__refreshPlatformSignTextures) window.__refreshPlatformSignTextures();
  } catch (e) { /* non-fatal */ }
}




function loadVehicleFile(filePath){
  fetch(filePath + cacheBust(), { cache: 'no-store' })
    .then(res => res.json())
    .then(data => {
      vehicle = data;
      vehicle.notches = (vehicle.notch_accels || []).length;
      document.getElementById('carName').textContent = vehicle.name;

            // ğŸ”¹ mini HUD í—¤ë”ë„ ì°¨ëŸ‰ ì´ë¦„ìœ¼ë¡œ ê°±ì‹ 
      if (miniTitle) {
        miniTitle.textContent = vehicle.name || "RUN";
      }
      brakeDecels = {};
      if (vehicle.notch_accels && vehicle.notches) {
        for (let i = 0; i < vehicle.notches; i++) {
          brakeDecels[i] = Math.abs(vehicle.notch_accels[vehicle.notches - 1 - i] ?? 0);
        }
      }

      
// ğŸ”¹ (ìƒˆ) vehicle íŒŒì¼ ê¸°ì¤€ìœ¼ë¡œ cab ì „ì²´ ì˜¤ë²„ë ˆì´ êµì²´
      const layoutKey = getCabLayoutKeyFromVehicle(filePath);
      buildCabOverlay(layoutKey);

         try {
        const opt = trainSeriesEl.selectedOptions[0];
        if (opt) {
          const lengths = JSON.parse(opt.dataset.lengths || "[]");
          updateTrainPreview({
            file: opt.value,
            code: opt.dataset.code || vehicle.name,
            lines: opt.dataset.lines || "",
            family: opt.dataset.family || "",
            lengths: lengths,
            description: vehicle.description || "" // ğŸ‘ˆ í•µì‹¬
          });
        }
      } catch (e) {
        console.debug("preview update failed", e);
      }

     updateTrainDifficultyBadges(vehicle);

      // ì•„ë˜ëŠ” ì›ë˜ ìˆë˜ WebSocket ì „ì†¡, í”Œë«í¼ ê¸¸ì´ ì¡°ì • ë“± ê·¸ëŒ€ë¡œ ìœ ì§€
      if (ws.readyState === WebSocket.OPEN) {
        const justName = filePath.split('/').pop();
        ws.send(JSON.stringify({ type: "cmd", payload: { name: "setVehicleFile", file: justName } }));
        let len = parseInt(document.getElementById("trainLength").value, 10);
        if (Number.isNaN(len)) len = 8;
        const loadRate = parseFloat(document.getElementById("inputLoadRate").value) || 0;

        setTimeout(() => {
          ws.send(JSON.stringify({ type: "cmd", payload: { name: "setTrainLength", length: len } }));
          ws.send(JSON.stringify({ type: "cmd", payload: { name: "setLoadRate", loadRate, length: len } }));
        }, 10);

        const desiredPlatLen =
        /n700s_3000/i.test(filePath) ||
        /e26/i.test(filePath) ||
        /ktx1/i.test(filePath)
          ? 405
          : 205;

        if (window.__updatePlatformLength) window.__updatePlatformLength(desiredPlatLen);
        
      }
      
// í”Œë«í¼ ê¸¸ì´
const desiredPlatLen =
  /n700s_3000/i.test(filePath) ||
  /e26/i.test(filePath) ||
  /ktx1/i.test(filePath)
    ? 405 // ì¥ëŒ€í¸ì„± (ì‹ ì¹¸ì„¼, KTX, ì¹´ì‹œì˜¤í˜ì•„ ë“±)
    : 205; // ì¼ë°˜ í†µê·¼í˜•

if (window.__updatePlatformLength) {
  window.__updatePlatformLength(desiredPlatLen);
}

//  ì—¬ê¸°ì„œ platRemoveë„ ê°™ì´ ì¡°ì •
const newPlatRemove =
  /n700s_3000/i.test(filePath) ||
  /e26/i.test(filePath) ||
  /ktx1/i.test(filePath)
    ? 415 // í”Œë«í¼ ë¹„ì›Œì¤„ ê¸¸ì´ (ì¥ëŒ€í¸ì„±ìš©)
    : 215; // ì¼ë°˜ ì—´ì°¨ìš©

if (window.rebuildLeftPoles) {
  window.rebuildLeftPoles(newPlatRemove);
}
      // Try to load route CSV distances if available.
      try {
        const justName = (filePath || '').split('/').pop() || '';
        const base = justName.replace(/\.json$/i, '');
        if (base) {
          const csvPath = `/static/route/${base}.csv`;
          fetch(csvPath + cacheBust(), { cache: 'no-store' })
            .then(r => {
              if (!r.ok) throw new Error('no-csv');
              return r.text();
            })
            .then(txt => {
              const lines = txt.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
              if (lines.length <= 1) throw new Error('empty-csv');
              const headers = lines[0].split(',').map(h => h.trim());
              // Find relevant columns: distance to next station, arrival time, travel time
              let colIdx = -1;
              let arrIdx = -1;
              let departIdx = -1;
              let travIdx = -1;
              let stationIdx = -1;
              let endIdx = -1;
              let atsIdx = -1;
              for (let i = 0; i < headers.length; i++) {
                const raw = headers[i] || '';
                const h = raw.toLowerCase().replace(/\s+/g, '');
                if (colIdx === -1 && (h.includes('distancetonext') || h.includes('distance') || h.includes('nextstation'))) { colIdx = i; }
                if (arrIdx === -1 && (h.includes('arrival') || h.includes('arrivaltime') || h.includes('arrivaltime'))) { arrIdx = i; }
                if (departIdx === -1 && (h.includes('depart') || h.includes('departure') || h.includes('departuretime'))) { departIdx = i; }
                if (travIdx === -1 && (h.includes('traveltime') || h.includes('traveltimetonext') || h.includes('traveltimetonextsec') || h.includes('travel') || h.includes('travel_time') || h.includes('time_to_next') )) { travIdx = i; }
                if (stationIdx === -1 && (h.includes('station') && h.includes('name'))) { stationIdx = i; }
                if (endIdx === -1 && (h === 'end' || h === 'isend' || h === 'isterminal' || h === 'terminal')) { endIdx = i; }
                if (atsIdx === -1 && (h === 'ats' || h.includes('ats') || h.includes('speedlimit') || h.includes('maxspeed'))) { atsIdx = i; }
              }
              if (colIdx === -1) throw new Error('no-col');
              const distances = [];
              const travelTimes = [];
              const stationNames = [];
              const endFlags = [];
              const atsValues = [];
              for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].split(',');
                if (cols.length > colIdx) {
                  const val = Number(cols[colIdx].trim());
                  if (!Number.isNaN(val)) distances.push(Math.round(val));
                }
                if (travIdx !== -1 && cols.length > travIdx) {
                  const t = Number(cols[travIdx].trim());
                  if (!Number.isNaN(t)) travelTimes.push(Math.round(t));
                }
                if (stationIdx !== -1 && cols.length > stationIdx) {
                  const sname = cols[stationIdx].trim();
                  stationNames.push(sname);
                }
                // Parse 'end' column (1 = terminal, 0 or missing = not terminal)
                if (endIdx !== -1 && cols.length > endIdx) {
                  const endVal = Number(cols[endIdx].trim());
                  endFlags.push(!Number.isNaN(endVal) ? (endVal === 1 ? 1 : 0) : 0);
                } else {
                  endFlags.push(0);
                }
                // Parse ATS column if present
                if (atsIdx !== -1 && cols.length > atsIdx) {
                  const atsHal = Number(cols[atsIdx].trim());
                  if (!Number.isNaN(atsHal)) atsValues.push(Math.round(atsHal));
                  else atsValues.push(null);
                } else {
                  atsValues.push(null);
                }
              }
              if (distances.length > 0) {
                window.__routeDistances = distances;
                window.__routeDistancesIndex = 0;
                window.__routeEndFlags = endFlags;
                // store travel times if present
                if (travelTimes.length > 0) {
                  window.__routeTravelTimes = travelTimes;
                  window.__routeTravelTimesIndex = 0;
                } else {
                  window.__routeTravelTimes = null;
                  window.__routeTravelTimesIndex = 0;
                }
                // store station names if present
                if (stationNames.length > 0) {
                  window.__routeStationNames = stationNames;
                  window.__routeStationNamesIndex = 0;
                } else {
                  window.__routeStationNames = null;
                  window.__routeStationNamesIndex = 0;
                }
                // store ATS values if present
                if (atsValues.length > 0) {
                  window.__routeAtsValues = atsValues;
                  window.__routeAtsIndex = 0;
                } else {
                  window.__routeAtsValues = null;
                  window.__routeAtsIndex = 0;
                }
                // also parse departure times column if available for per-run timer trigger
                try {
                  const departTimes = [];
                  const useIdx = (departIdx !== -1) ? departIdx : arrIdx;
                  if (useIdx !== -1) {
                    for (let i = 1; i < lines.length; i++) {
                      const cols = lines[i].split(',');
                      const dval = (cols[useIdx] || '').trim();
                      if (!dval) { departTimes.push(null); continue; }
                      const m = String(dval).match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
                      if (m) {
                        const hh = String(m[1]).padStart(2,'0');
                        const mm = String(m[2]).padStart(2,'0');
                        const ss = String(m[3] || '00').padStart(2,'0');
                        departTimes.push(`${hh}:${mm}:${ss}`);
                      }
                      else departTimes.push(null);
                    }
                  }
                  if (departTimes.length > 0) {
                    window.__routeDepartures = departTimes;
                    window.__routeDeparturesIndex = 0;
                  } else {
                    window.__routeDepartures = null;
                    window.__routeDeparturesIndex = 0;
                  }
                } catch (e) { window.__routeDepartures = null; window.__routeDeparturesIndex = 0; }
                // Also try to capture the first arrival time (HH:MM:SS) if available
                try{
                  if (arrIdx !== -1 && lines.length > 1) {
                    const firstCols = lines[1].split(',');
                    const cand = (firstCols[arrIdx] || '').trim();
                    if (cand) {
                      const m = String(cand).match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
                      if (m) {
                          const hh = String(m[1]).padStart(2,'0');
                          const mm = String(m[2]).padStart(2,'0');
                          const ss = String(m[3] || '00').padStart(2,'0');
                          const tt = `${hh}:${mm}:${ss}`;
                          window.__routeClockStart = tt;
                        }
                    }
                  }
                }catch(e){}
                console.debug('route distances loaded', csvPath, distances.length, 'travelTimes', travelTimes.length, 'departures', window.__routeDepartures ? window.__routeDepartures.length : 0);
                if (window.__routeDepartures && window.__routeDepartures.length > 0) {
                  console.debug('departure times sample:', window.__routeDepartures.slice(0, 3));
                }
                if (window.__routeClockStart) {
                  console.debug('clock start time from CSV:', window.__routeClockStart);
                }
              } else {
                window.__routeDistances = null;
                window.__routeDistancesIndex = 0;
                window.__routeTravelTimes = null;
                window.__routeTravelTimesIndex = 0;
              }
            })
            .catch(err => {
              window.__routeDistances = null;
              window.__routeDistancesIndex = 0;
              console.debug('route csv load failed', err);
            });
        }
      } catch (e) {
        window.__routeDistances = null; window.__routeDistancesIndex = 0;
      }

      // ğŸ”¹ Load ATC CSV (trainname.csv) from /static/route/atc/ folder
      try {
        const justName = (filePath || '').split('/').pop() || '';
        const base = justName.replace(/\.json$/i, '');
        if (base) {
          const atcCsvPath = `/static/route/atc/${base}.csv`;
          fetch(atcCsvPath + cacheBust(), { cache: 'no-store' })
            .then(r => {
              if (!r.ok) throw new Error('no-atc-csv');
              return r.text();
            })
            .then(txt => {
              const lines = txt.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
              if (lines.length <= 1) throw new Error('empty-atc-csv');
              
              const headers = lines[0].split(',').map(h => h.trim());
              let distIdx = -1;
              let atcIdx = -1;
              let bellIdx = -1;
              
              // Find column headers (case-insensitive)
              for (let i = 0; i < headers.length; i++) {
                const h = (headers[i] || '').toLowerCase().replace(/\s+/g, '');
                if (distIdx === -1 && h.includes('distance')) distIdx = i;
                if (atcIdx === -1 && (h.includes('atc') || h.includes('change'))) atcIdx = i;
                if (bellIdx === -1 && h.includes('bell')) bellIdx = i;
              }
              
              if (distIdx === -1 || atcIdx === -1) throw new Error('missing-columns');
              
              const atcData = [];
              for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].split(',');
                if (cols.length > distIdx && cols.length > atcIdx) {
                  const dist = Number(cols[distIdx].trim());
                  const atc = Number(cols[atcIdx].trim());
                  const bell = bellIdx !== -1 && cols.length > bellIdx ? Number(cols[bellIdx].trim()) : 0;
                  if (!Number.isNaN(dist) && !Number.isNaN(atc)) {
                    atcData.push({ distance: Math.round(dist), atc_change: Math.round(atc), atc_bell: Number.isNaN(bell) ? 0 : bell });
                  }
                }
              }
              
              if (atcData.length > 0) {
                window.__routeAtcData = atcData;
                console.debug('ATC data loaded', atcCsvPath, 'entries:', atcData.length, 'sample:', atcData.slice(0, 3));
              } else {
                window.__routeAtcData = null;
              }
            })
            .catch(err => {
              window.__routeAtcData = null;
              console.debug('ATC csv load failed (not critical)', err);
            });
        }
      } catch (e) {
        window.__routeAtcData = null;
      }
    })
    .catch(console.error);
}



function populateSeries(){
  const fam = trainFamilyEl.value;
  const list = TRAIN_DB[fam] || [];
  trainSeriesEl.innerHTML = "";

  list.forEach((s, i) => {
    const opt = document.createElement('option');
    opt.value = s.file;
    opt.dataset.lengths = JSON.stringify(s.lengths);
    opt.dataset.code = s.code;
    opt.dataset.lines = s.lines;
    opt.dataset.family = fam;
    opt.textContent = `${s.code}`;
    if (i === 0) opt.selected = true;
    trainSeriesEl.appendChild(opt);
  });

  if (list[0]) {
    setTrainLengthOptions(list[0].lengths);

    //  ì²« ì§„ì… ì‹œ ìš°ì¸¡ í”„ë¦¬ë·°ë„ ë™ê¸°í™”
    updateTrainPreview({
      file: list[0].file,
      code: list[0].code,
      lines: list[0].lines,
      family: fam,
      lengths: list[0].lengths
    });

    loadVehicleFile(list[0].file);
  }
}


trainSeriesEl.addEventListener('change',(e)=>{
  const opt = e.target.selectedOptions[0];
  if (!opt) return;

  const lengths = JSON.parse(opt.dataset.lengths || "[]");

  // í¸ì„± ì˜µì…˜ ê°±ì‹ 
  setTrainLengthOptions(lengths);

  //  ìš°ì¸¡ í”„ë¦¬ë·° ê°±ì‹ 
  updateTrainPreview({
    file: opt.value,
    code: opt.dataset.code,
    lines: opt.dataset.lines,
    family: opt.dataset.family,
    lengths: lengths,
  });

  // ì‹¤ì œ ì°¨ëŸ‰ JSON ë¡œë“œ + ì„œë²„ í†µì‹ 
  loadVehicleFile(opt.value);

});

trainFamilyEl.addEventListener('change', populateSeries);
populateSeries(); // ìµœì´ˆ ì„¸íŒ…


</script>

<!-- ===== 10s ì–¸ì–´ í† ê¸€ (ko <-> en), í”¼ë“œë°± í¬í•¨ ===== -->
<script>
window.__brakeGuideOn = true;

// ===== ì–¸ì–´ í† ê¸€ =====
(function(){

  const dict = {
    ko: {
      htmlLang: "ko",
      docTitle: "Super Express trainsim",
      labelRemainTime: "ë‚¨ì€ì‹œê°„",
      labelSpeed: "ì†ë„",
      labelRemainDist: "ì •ì°¨",
      labelGrade: "êµ¬ë°°",
      labelNotch: "ë…¸ì¹˜",
      labelStartKey: "ì‹œì‘",
      labelUp: "ê°•í™”",
      labelDown: "ì™„í™”",
      labelRelease: "ì¤‘ë¦½",
      subtitleIntro: 
  "E235ê³„ì—´ ì°¨ëŸ‰ì˜ TASC í™œì„±í™” ì‹œ ì‚¬ìš©ë²•: <b>300m</b> ì§€ì  ì „ì— ì£¼ê°„ì œì–´ê¸°ë¥¼ <b>B1ë‹¨</b>ìœ¼ë¡œ ì²´ê²°í•´ì£¼ì„¸ìš”. ê·¸ ì´í›„ì—ëŠ” <b>TASC, ìë™ì •ì°¨</b>ê°€ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤.",

      labelTASC: "TASC",
      labelTrain: "ì „ë™ì°¨",
      labelSeries: "ì‹œë¦¬ì¦ˆ",
      labelInitSpeed: "ì´ˆê¸° ì†ë„ (km/h)",
      labelInitDist: "ê±°ë¦¬ (m)",
      labelGradeInput: "ê²½ì‚¬ë„ (â€°)",
      labelTimeofDay: "ì‹œê°„ëŒ€",
      labelWeather: "ë‚ ì”¨",
      labelLoadRate: "ìŠ¹ê° íƒ‘ìŠ¹ë¥  (%)",
      labelTrainLength: "í¸ì„±",
      btnStart: "Start (Space)",
      btnMobileRestart: "ì¬ì‹œì‘",
      feedback: {
        early_good: "ì´ˆì œë™ì„ ìˆ˜í–‰í•¨ â€” ë¶€ë“œëŸ½ê²Œ ì œë™ ì§„ì…",
        early_bad: "ì´ˆì œë™ì„ ê²Œì„ë¦¬í•¨ â€” ìŠ¹ì°¨ê° ë¶ˆì¾Œ",
        stop_good: "ì •ì°¨ ì‹œ B1/B2ë¡œ ì •ì°¨í•¨ â€” ì •ì°¨ ìŠ¹ì°¨ê° ì–‘í˜¸",
        stop_bad: "ì •ì°¨ ì‹œ B1/B2ë¡œ ì •ì°¨í•˜ì§€ ì•ŠìŒ â€” ìŠ¹ì°¨ê° ë¶ˆì¾Œ",
        step_good: "ê¸°ë³¸ì œë™ (ê³„ë‹¨ì œë™/ì™„í•´) ìˆ˜í–‰í•¨",
        step_bad: "ê¸°ë³¸ì œë™ (ê³„ë‹¨ì œë™/ì™„í•´) ë¯¸í¡ â€” ë¶ˆê·œì¹™í•œ ì œë™ íŒ¨í„´ìœ¼ë¡œ ì¸í•œ ìŠ¹ì°¨ê° ë¶ˆì¾Œ",
        eb_good: "ì˜ì—… ì•ˆì „ ì œë™ë²”ìœ„ ì¤€ìˆ˜",
        eb_bad: "ë¹„ìƒì œë™(EB) ì²´ê²° â€” ê¸‰ê°ì† ì¶©ê²©",
        score: n=>`ìµœì¢… ì ìˆ˜: ${n}/100ì `,
        stopErr: m=>`ì •ì§€ ì˜¤ì°¨: ${m.toFixed(2)} m`,
         hintIdle: () => {
          const tips = [
            "íŒ: TASC ì •ì°¨ í‘œì‹œë“±ì´ ì¼œì§€ë©´ TASCê°€ ìë™ ì œë™ì„ ì‹œì‘í–ˆìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.",
            "íŒ: TASC ì •ì°¨ í‘œì‹œë“±ì´ ê¹œë¹¡ì´ë©´, TASC ê°œì… ì „ì— ìˆ˜ë™ ì¡°ì‘ì´ ê°€ëŠ¥í•˜ë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.",
            "íŒ: ì—´ì°¨ê°€ ì •ìœ„ì¹˜ì— ë„ë‹¬í•˜ë©´ TASC ì •ìœ„ì¹˜ í‘œì‹œë“±ì´ ì¼œì§‘ë‹ˆë‹¤.",
            "íŒ: ë‚¨ì€ ê±°ë¦¬ë¥¼ í™•ì¸í•˜ë©° ì—¬ìœ  ìˆê²Œ B1ìœ¼ë¡œ ì •ì°¨í•˜ì—¬ ìŠ¹ì°¨ê°ì„ í™•ë³´í•˜ì„¸ìš”.",
            "íŒ: Aí‚¤ëŠ” 6ë‹¨(í˜¹ì€ 5ë‹¨) ì œë™, Dí‚¤ëŠ” B1 ì œë™, Eí‚¤ëŠ” ë¹„ìƒì œë™ì„ ë°œë™ì‹œí‚µë‹ˆë‹¤.",
            "íŒ: Qí‚¤ëŠ” ìµœëŒ€ ìƒìš© ê°€ì†ì„ ë°œë™ì‹œí‚µë‹ˆë‹¤.",
            "íŒ: ì •ì°¨ ì§ì „ ë§ˆìŠ¤ì½˜ì„ í’€ì—ˆë‹¤ ë‹¤ì‹œ ì¡°ì‘í•˜ëŠ” ì¼ëª… \"í†±ì§ˆ\" í–‰ìœ„ëŠ” ìŠ¹ì°¨ê°ì„ í¬ê²Œ ì €í•˜ì‹œí‚µë‹ˆë‹¤.",
            "íŒ: ì •ì°¨ ë„ì¤‘ ì—­í–‰(ì¬ê°€ì†) ì·¨ê¸‰ì€ ì ˆëŒ€ ê¸ˆë¬¼ì…ë‹ˆë‹¤.",
            "íŒ: ëœë¤ í† ê¸€ì„ ì¼œë©´ ì¼ì • í™•ë¥ ë¡œ ì„ ë¡œ ìœ„ì— ì¥ì• ë¬¼ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤. ì£¼í–‰ ì‹œ í•­ìƒ ì£¼ì˜ë¥¼ ê¸°ìš¸ì´ì„¸ìš”."
          ];

          return tips[Math.floor(Math.random() * tips.length)];
        },
        hintAgain: "Spaceë¡œ ë‹¤ì‹œ ì‹œì‘ Â· N ì¤‘ë¦½ Â· W/Së¡œ ì¡°ì‘"
      }
    },
    en: {
      htmlLang: "en",
      docTitle: "Super Express trainsim",
      labelRemainTime: "STA",
      labelSpeed: "Speed",
      labelRemainDist: "Distance",
      labelGrade: "Gradient",
      labelNotch: "Notch",
      labelStartKey: "Start",
      labelUp: "B+",
      labelDown: "B-",
      labelRelease: "Release",
      subtitleIntro: 
"E235 series TASC instructions: Before the <b>300m</b> point, put the master controller at <b>B1</b>. After that, TASC will handle automatic stopping.",
      labelTASC: "TASC",
      labelTrain: "EMU",
      labelSeries: "Series",
      labelInitSpeed: "Initial Speed (km/h)",
      labelInitDist: "Distance (m)",
      labelGradeInput: "Grade (â€°)",
      labelTimeofDay: "Time of Day",
      labelWeather: "Weather",
      labelLoadRate: "Passenger Load (%)",
      labelTrainLength: "Formation",
      btnStart: "Start (Space)",
      btnMobileRestart: "Restart",
      feedback: {
  early_good: "Performed initial braking with B1 â€” smooth initial deceleration",
  early_bad: "Failed to perform initial braking  â€” the ride felt rough",
  stop_good: "Stopped with B1/B2 â€” smooth stop",
  stop_bad: "Failed to stop with B1/B2 â€” rough stop",
  step_good: "Stepwise braking was applied correctly",
  step_bad: "Stepwise braking was poor, causing jolts and discomfort for passengers",
  eb_good: "Safe braking range observed",
  eb_bad: "EB applied, causing a harsh jolt",
  score: n => `Final score: ${n}/100`,
  stopErr: m => `Stopping error: ${m.toFixed(2)} m`,
  hintIdle: () => {
    const tips = [
      "Tip: If the TASC stop indicator lights up, it means TASC has started automatic braking.",
      "Tip: If the TASC stop indicator flashes, you can manually intervene before TASC takes over.",
      "Tip: When the train reaches the exact stop position, the TASC stop-position indicator will light up.",
      "Tip: Press A for the recommended maximum service brake, D for B1 brake, and E for emergency brake.",
      "Tip: Press Q for maximum acceleration.",
      "Tip: Check the remaining distance and stop gently with B1/B2 to ensure a smooth ride.",
      "Tip: Reapplying and releasing the master controller just before stopping can severely affect ride comfort.",
      "Tip: Never consider re-acceleration while bringing the train to a stop.",
      "Tip: Enabling the Random toggle introduces a slight chance of obstacles appearing on track. Stay alert while driving."
    ];

    return tips[Math.floor(Math.random() * tips.length)];
  },

  hintAgain: "Press Space to restart, N to release, W/S to brake."
}
    }
  };

  const nodes = {
    labelRemainTime: document.getElementById("labelRemainTime"),
    labelSpeed: document.getElementById("labelSpeed"),
    labelRemainDist: document.getElementById("labelRemainDist"),
    labelGrade: document.getElementById("labelGrade"),
    labelNotch: document.getElementById("labelNotch"),
    subtitleIntro: document.getElementById("subtitleIntro"),
    labelTASC: document.getElementById("labelTASC"),
    labelTrain: document.getElementById("labelTrain"),
    labelSeries: document.getElementById("labelSeries"),
    labelInitSpeed: document.getElementById("labelInitSpeed"),
    labelInitDist: document.getElementById("labelInitDist"),
    labelGradeInput: document.getElementById("labelGradeInput"),
    labelTimeofDay: document.getElementById("labelTimeofDay"),
    labelWeather: document.getElementById("labelWeather"),
    labelLoadRate: document.getElementById("labelLoadRate"),
    labelTrainLength: document.getElementById("labelTrainLength"),
    btnStart: document.getElementById("btnStart"),
    btnMobileRestart: document.getElementById("btnMobileRestart"),
    fb: document.getElementById("fb")
  };

  function setLang(lang){
    const d = dict[lang];
    document.documentElement.lang = d.htmlLang;
    document.title = d.docTitle;

    [
      "labelRemainTime","labelSpeed","labelRemainDist","labelGrade","labelNotch",
      "labelStartKey","labelUp","labelDown","labelRelease",
      "labelTASC","labelTrain","labelSeries","labelInitSpeed","labelInitDist",
      "labelGradeInput","labelWeather","labelLoadRate","labelTrainLength", "labelTimeofDay"
    ].forEach(k => { if(nodes[k]) nodes[k].innerText = d[k]; });

    if(nodes.subtitleIntro) nodes.subtitleIntro.innerHTML = d.subtitleIntro;
    if(nodes.btnStart) nodes.btnStart.textContent = d.btnStart;
    if(nodes.btnMobileRestart) nodes.btnMobileRestart.textContent = d.btnMobileRestart;

    // ---- í”¼ë“œë°± ë²ˆì—­ ----
    if (nodes.fb) {
      const fbd = d.feedback;
      const st = window.st;
      if (st && st.finished) {
        const issues = st.issues ?? {};
        let rows = [];
        rows.push({ bad: !!issues.early_brake_too_short, goodText: fbd.early_good, badText: fbd.early_bad });
        rows.push({ bad: !!issues.stop_not_b1,           goodText: fbd.stop_good,  badText: fbd.stop_bad  });
        const veh_name = vehicle.name.toLowerCase()
        const isSpecial =
          veh_name.toLowerCase().includes("ktx") ||
          veh_name.toLowerCase().includes("n700s") ||
          veh_name.toLowerCase().includes("e26");

        rows.push({
          bad: isSpecial ? false : !!issues.step_brake_incomplete,
          goodText: fbd.step_good,
          badText: fbd.step_bad,
        });

        rows.push({ bad: !!issues.unnecessary_eb_usage,  goodText: fbd.eb_good,    badText: fbd.eb_bad    });

        let html = rows.map(r =>
          `<div class="${r.bad ? "bad" : "ok"}">${r.bad ? r.badText : r.goodText}</div>`
        ).join("");

        const stopErr = Number(st.stop_error_m ?? 0);
        let score = Number(st.score ?? 0);
        
        if (veh_name.includes("ktx") || veh_name.includes("n700s") || veh_name.includes("e26")) {
          if (score > 0) {
            score +=40; //ê³ ì†ì—´ì°¨ ë° ì „ê¸°ê¸°ê´€ì°¨ëŠ” ì™„ë²½í•œ ê¸°ë³¸ì œë™ì´ ì‚¬ì‹¤ìƒ ë¶ˆê°€í•˜ë¯€ë¡œ ê¸°ë³¸ì œë™ ì ìˆ˜ ì–´ë“œë°´í‹°ì§€ ë¶€ì—¬
            if (score >100) {
              score = 100;
            }
          }
        }
        const goodErr = Math.abs(stopErr) <= 2;

        html += `<div class="${goodErr ? "ok" : "warn"}">${fbd.stopErr(stopErr)}</div>`;
        // html += `<div class="${goodErr ? "ok" : "warn"}">${fbd.score(score)}</div>`;
        html += `<div style="margin-top:8px;font-size:12px;color:#a6b7d1">${fbd.hintAgain}</div>`;
        nodes.fb.innerHTML = html;
      } else {
        nodes.fb.textContent = fbd.hintIdle();
      }
    }
  }

  // ===== 5ì´ˆë§ˆë‹¤ í† ê¸€ =====
  let current = "ko";
  setLang(current);
  setInterval(()=>{
    current = (current==="ko") ? "en" : "ko";
    setLang(current);
  }, 6000);
})();

</script>

<footer style="text-align:center; font-size:12px; color:#888; padding:8px 0; user-select:none;">
  Â©2025 Hyungsuk Choi, University of Maryland
</footer>

<!-- ì¥ì• ë¬¼ ì¶©ëŒ ê²½ê³  íŒì—… -->
<div id="obstacleFailPopup" class="obstacle-popup">
  <div class="obstacle-card obstacle-danger">
<div class="obstacle-title">ğŸš¨ Obstacle Collision Occurred ğŸš¨</div>
<p class="obstacle-body">
  You ran over an obstacle on track.<br>
  In a real situation, you must immediately apply emergency brakes and report to control.
</p>
<div class="obstacle-hint">
  Press SPACE to close the window and continue driving.
</div>

  </div>
</div>

<!-- ì¥ì• ë¬¼ ì•ˆì „ ì •ì§€ íŒì—… -->
<div id="obstacleSuccessPopup" class="obstacle-popup">
  <div class="obstacle-card obstacle-success">
<div class="obstacle-title">ğŸŸ¢ Emergency Stop Successful ğŸŸ¢</div>
<p class="obstacle-body">
  You stopped safely in front of the obstacle.<br>
  Please wait until the obstacle is completely cleared, then resume driving.
</p>
<div class="obstacle-hint">
  Press SPACE to close the window and continue driving.
</div>

  </div>
</div>
</body>
</html>